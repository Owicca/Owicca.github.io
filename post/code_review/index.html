<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="OWicca"><meta name=generator content="Hugo 0.121.2"><title>Code Review — Down the wabbit's hole</title>
<meta name=description content><link rel=canonical href=https://www.dinudev.com/post/code_review/><link href rel=alternate type=application/rss+xml title="Down the wabbit's hole"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=https://www.dinudev.com/css/highlight.css><link rel=stylesheet href=https://www.dinudev.com/css/paperback.css><link rel=stylesheet href=https://www.dinudev.com/css/main.css><link rel=stylesheet href=https://www.dinudev.com/css/tabs.css></head><body><div class=container><header><h1>Code Review</h1><nav class=site-nav><a href=/>Home</a>
<a href=/post/>All posts</a>
<a href=/thoughts/>Thoughts</a>
<a href=/paper/>Papers</a></nav></header><h3>Table of Contents</h3><aside><nav id=TableOfContents><ul><li><ul><li><a href=#high-level-code-review-checklist>high level code review checklist:</a></li><li><a href=#low-level-code-review-checklist>low level code review checklist:</a></li><li><a href=#architectural-code-smells-checklist>architectural code smells checklist:</a></li><li><a href=#cr-impact>cr impact:</a></li><li><a href=#failure-categories>failure categories:</a></li><li><a href=#types>types:</a></li><li><a href=#dead-giveaways>dead giveaways:</a></li><li><a href=#baseline>baseline:</a></li><li><a href=#smart>SMART:</a></li><li><a href=#health-status>Health status:</a></li><li><a href=#api-design>API design:</a></li></ul></li></ul></nav></aside><article><h3 id=high-level-code-review-checklist>high level code review checklist:</h3><ol><li>Does the actual implementation reflect the architecture?</li><li>Is the code easy to understand?</li><li>Is the code too long?</li><li>Is cohesion in place?</li><li>Is the code modular?</li><li>Are components cohesive?</li><li>Is the code loosely coupled?</li><li>Is the code reusable?</li><li>Is the code readable?</li><li>Is the code easy to maintain and test?</li><li>Are premature optimizations in place?</li><li>Is composition preferred?</li><li>Is inheritance properly used?</li><li>Is the flow easy to understand?</li><li>Are interactions between different components easy to
catch?</li><li>Are conditional flows completely defined?</li><li>Is there any undefined behavior?</li><li>Are APIs consistent and as clean as the overall code?</li></ol><h3 id=low-level-code-review-checklist>low level code review checklist:</h3><ol><li>Are data structures appropriately used?</li><li>Is the data structure appropriate based on the data size
the code is dealing with?</li><li>Are potential changes to data size considered and
handled?</li><li>Is the data structured forced to do operations not
natively supported?</li><li>Does the data structure support growth (i.e., scalability)?</li><li>Does the data structure reflect the need for relationships
between elements?</li><li>Does the data structure optimally support the operations
you need to perform on it?</li><li>Is the choice of a specific data structure overcomplicating
the code?</li><li>Is the data structure chosen based on most frequent
operations to be performed on data?</li><li>Are you using stacks for problems that do not require
FIFO?</li><li>Are you using queues for problems that do not require
LIFO?</li><li>Does the data structure reflect any ordering on sorting
requirements?</li><li>From a logical perspective, is the code meant to update
the key within a hash map? If so, rethink the problem
and see if hash maps are the best data structure to deal
with it.</li></ol><h3 id=architectural-code-smells-checklist>architectural code smells checklist:</h3><ol><li>cyclic dependencies:<ul><li>two or more components that depend on eachother</li><li>improper design of responsibilities</li></ul></li><li>feature density:<ul><li>a component implements more than one functionality</li></ul></li><li>unstable dependency:<ul><li>a component depends on a less stable one</li></ul></li><li>mashed components:<ul><li>a component that instead of begin a single unit,
it is scattered across multiple places</li></ul></li><li>ambiguous interface:<ul><li>api should extensible and flexible,
not unclear or ambiguous</li></ul></li><li>mesh components:<ul><li>highly coupled</li></ul></li><li>do-it-all components:<ul><li>a component that atteps to do everything,</li><li>it becomes too big, logically complex and expensive to maintain</li></ul></li></ol><h3 id=cr-impact>cr impact:</h3><ul><li>ROI is immediate and can be see in the long tail,
subsequent code reviews will be constant/shorter</li><li>mantaining clean code, feature development time will remain constant or become smaller,
you tame complexity</li><li>automated testing does not ensure quality code(only that there are no bugs),
cr comes and tries to fix that</li><li>a learning experience for the auditor and auditee</li></ul><h3 id=failure-categories>failure categories:</h3><ul><li>bug</li><li>readability</li><li>maintainability</li><li>usability</li><li>extensibility</li><li>security</li><li>performance</li></ul><h3 id=types>types:</h3><ul><li>static code analysis:<ul><li>performance issues</li><li>standard violations(code style)</li></ul></li><li>manual code analysis</li></ul><h3 id=dead-giveaways>dead giveaways:</h3><ul><li>no design pre implementation, no architectural concerns</li><li>use global variables</li><li>use OOP but don&rsquo;t use it for its benefits(polymorphism, inheritance, etc)</li><li>never use design patterns(that does not mean it should never be used)</li><li>big classess with multiple responsabilities</li><li>highly coupled components</li><li>never think about API, an chose your prefered components</li></ul><h3 id=baseline>baseline:</h3><ul><li><a href=http://www.python.org/dev/peps/pep-0020/><code>The Zen of Python</code></a></li><li>KISS(keep it simple, stupid):<ul><li>if you want to branch based on a flag,
don&rsquo;t abstract away the logic in a class,
simply write an <code>if-else</code></li></ul></li><li>reusability:<ul><li>avoid repetition of logic and/or data</li><li>aim to write code that can be used in some shape or form by other components</li></ul></li><li>readability:<ul><li>naming</li><li>commenting</li><li>indentation</li><li>following code standards and maintaining consistent conventions</li><li>functions, methods and classes are short and on point</li></ul></li><li>modularity:<ul><li>cohesive(should have a clearly defined function)</li><li>loosely coupled(the dependencies should be minimal)</li><li>modifying a component should have minimal impact on adjacent ones</li><li>always look for code that can be generalized,
put in its own component and
reused elsewhere in code</li></ul></li><li>maintainability:<ul><li>how easy will be to extend, refactor/rework the code in the future</li><li>modularity and readability highly impact maintainability</li></ul></li><li>testability:<ul><li>ensure corectedness by writing tests that validate the functionality</li><li>ideally the code author and test writer should not be the same person</li></ul></li><li>composition vs inheritance:<ul><li>to achieve polymorphism you REQUIRE inheritance</li><li>composition is easier to mantain, because the objects are simpler and
you don&rsquo;t need to potentially restructure the hierarchy every time you create a new object</li><li>RULE: if to many method forwardings are used, inheritance is preferred</li></ul></li><li>premature optimisation:</li></ul><h3 id=smart>SMART:</h3><ul><li>specific</li><li>measurable:<ul><li>usability</li><li>maintainability</li><li>performance</li></ul></li><li>achievable/realistic:<ul><li>simple is often better</li></ul></li><li>time-bound:<ul><li>makes clients and shareholders happy</li></ul></li></ul><h3 id=health-status>Health status:</h3><ol><li>problem definition:<ul><li>the requirements should be as clear as possible</li><li>what is in scope and what is not?</li><li>what is the mvp?</li><li>what is the roadmap?</li></ul></li><li>validate the architecture:<ul><li>the resulting solution should validate the proposed design</li></ul></li><li>rethink technologies:<ul><li>use the right tool for the right job,
because if you only have a hammer, everything looks like a nail</li></ul></li><li>knowledge:<ul><li>use the right man for the job,
because if you only have a programmer, everything looks like an object hierarchy waiting to be implemented</li><li>if there is no domain knowledge, training is the way to go</li></ul></li><li>processes:<ul><li>systematic processes should be clear and available,
otherways even the most well-rounded team won&rsquo;t be productive</li></ul></li></ol><h3 id=api-design>API design:</h3><ul><li>error-handling and security should be at the forefront</li></ul></article><nav class=site-nav><a href=https://www.dinudev.com//>Home</a>
<a href=https://www.dinudev.com//post/>All posts</a>
<a href=https://www.dinudev.com//thoughts/>Thoughts</a>
<a href=https://www.dinudev.com//paper/>Papers</a>
<a href=https://github.com/Owicca>GitHub</a></nav><footer class=site-footer><span class=owner>©2024 OWicca</span></footer></div><script src=https://www.dinudev.com/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><script src=https://www.dinudev.com/js/tabs.js></script></body></html>