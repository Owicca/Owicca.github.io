<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="OWicca"><meta name=generator content="Hugo 0.102.3"><title>Tests â€” Down the wabbit's hole</title><meta name=description content><link rel=canonical href=https://www.dinudev.com/post/tests/><link href rel=alternate type=application/rss+xml title="Down the wabbit's hole"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=https://www.dinudev.com/css/highlight.css><link rel=stylesheet href=https://www.dinudev.com/css/paperback.css><link rel=stylesheet href=https://www.dinudev.com/css/main.css></head><body><div class=container><header><h1>Tests</h1><nav class=site-nav><a href=/>Home</a>
<a href=/post/>All posts</a>
<a href=/journey/>The journey</a>
<a href=/paper/>Papers</a></nav></header><article><h3 id=unit-testlondon>unit test(london):</h3><ul><li>automated</li><li>verifies a small piece of code(a unit)</li><li>does it quickly</li><li>does it in an isolated manner</li></ul><h3 id=unit-testclassical>unit test(classical):</h3><ul><li>automated</li><li>verifies a small piece of behaviour(a unit)</li><li>does it quickly</li><li>does it in isolation(from other tests)</li></ul><h3 id=integration-test>integration test:</h3><ul><li>does not follow one(any) or more ut criteria</li><li>it involves two or more units</li></ul><h3 id=schools-of-tought>schools of tought:</h3><ul><li>classical:<ul><li>if you test an unit, you are implicitly testing its dependencies</li></ul></li><li>london:<ul><li>all colaborators(shared or mutable dependency) are mocked,
this way only SUT is tested</li></ul></li></ul><h3 id=caracteristics-of-unit-teststhese-can-be-run-after-every-code-line-change>caracteristics of unit tests(these can be run after every code line change):</h3><ul><li>they run fast</li><li>they help us localize errors</li></ul><h3 id=not-unit-teststhese-can-be-run-at-larger-intervals>NOT unit tests(these can be run at larger intervals):</h3><ul><li>talks to the db</li><li>communicates across the network</li><li>uses the fs</li><li>you need to edit the environment(ex: config files) to run them</li></ul><h3 id=philo>philo:</h3><ul><li>london allows you to build outside-in:<ul><li>start from high-level tests that set expectations for the whole system</li><li>continue to write tests for every SUT in the graph of dependencies(mocks allows this)</li></ul></li><li>classical forces you to start inside-out:<ul><li>starting from the domain model you test and build out until the user facing SUTs</li></ul></li></ul><h3 id=cons>cons:</h3><ul><li>london:<ul><li>if you mock every collaborator, the tests end up more coupled</li></ul></li></ul><h3 id=unit-test-structure>unit test structure:</h3><ul><li>3a(aaa):<ul><li>arrange:<ul><li>setup SUT and collaborators in a desired state</li></ul></li><li>act:<ul><li>execute the behaviour and capture the output</li></ul></li><li>assert:<ul><li>assert the output and state is the expected one</li></ul></li></ul></li><li>3a is usually written starting with arrange,
but it is easier to start with assert,
because you do not yet know the behaviour,
just the desired outcome</li><li>recommendations:<ul><li>make shared fixtures only when all or almost all tests will use them(ex: DB connection):<ul><li>you might duplicate the same arrange for multiple tests,
but this will make the tests self-sustaining and more readable</li><li>if you do not want duplication, create private factory methods to be used in arrange</li></ul></li><li>name the test as if you were describing to a domain expert or business analyst</li><li>each test is a fact about the behaviour of the SUT</li></ul></li><li>code smell:<ul><li>multiple or intertwined aaa sections in the same test means its not an unit test(tests more than one unit)</li><li>an <code>if</code> in a test means it verifies too many things at once(not an unit test)</li><li>if act is larger than 2-3 lines or larger than assert, there might be a problem with the SUT API</li><li>if assert is too big it might signify a missing abstraction in the SUT API</li></ul></li></ul><h3 id=misc>misc:</h3><ul><li>ideal unit test:<ul><li>because of the CAP theorem ideal tests are unatainable</li><li>if you focus on maxing any two facets, the last one will be useless,
thus making the whole test useless</li><li>it is impossible to achieve a perfect score in all four attributes
because the three &ldquo;protection against regressions&rdquo;, &ldquo;resistance to refactoring&rdquo; and &ldquo;fast feedback&rdquo; are mutually exclusive,
meaning only two of the three can have perfect scores</li><li>&ldquo;resistance to refactoring&rdquo; is non-negociable because is binary, you either have resistance to refactoring or you don&rsquo;t</li><li>a &ldquo;slider&rdquo; moves the importance between &ldquo;fast feedback&rdquo; and &ldquo;protection against regressions&rdquo; based on context,
because the two are more malleable than &ldquo;resistance to refactoring&rdquo;:<ol><li>e2e: more towards &ldquo;regressions&rdquo;</li><li>integration: middle point</li><li>unit: faster than any other</li></ol></li><li>attributes:<ul><li>integrated into the development lifecycle</li><li>targets only the most important parts of the codebase</li><li>provides maximum value with minimum maintenance costs</li></ul></li></ul></li><li>test pyramid:<ol><li><code>many</code> unit tests, highly abstract</li><li><code>medium</code> amount of integration tests, more human</li><li><code>low</code> amount of end-to-end tests, closest to emulating a user</li></ol></li><li>if you have very few business rules or any other complexity,
e2e are redundant or useless</li><li>if you do not have algorithmic complexity or business complexity,
many unit tests are useless because they quickly delve in trivial checks</li><li>black-box vs white-box testing:<ul><li>black-box(what):<ul><li>used based on a specification</li><li>use when <code>writing</code> tests</li></ul></li><li>white-box(how):<ul><li>derived from source code, not a specification</li><li>more thorough, but more brittle(tight coupling)</li><li>tend to produce more false positives</li><li>use when <code>analysing</code> tests</li></ul></li></ul></li><li>a test against a behaviour that is not meaningful to a business person lacks value and is fragile</li><li>decoupling means testing the observable behaviour(the end results),
not the steps to do that</li><li>maximising test accuracy:<ul><li>by decreasing the false positives(the test is flexible to refactoring)
and decreasing the false negatives(the test is good against regression),
the accuracy of the test increases</li></ul></li><li>set a high value threshold for tests and only allow tests above that value in the codebase,
test code is also code and less good code is better than more mediocre code:<ul><li>value = [0..1] * [0..1] * [0..1] * [0..1]</li><li>in order to be valuable, a test must score something in every category,
0 in one category results in a total 0</li></ul></li></ul><h3 id=fundamental-pillars-of-good-unit-testing>fundamental pillars of good unit testing:</h3><ol><li>protection against regressions:<ul><li>the amount of code:<ul><li>more code tested increases the risk of finding a regression, which is good</li></ul></li><li>the complexity of the code:<ul><li>complex code is more important than boilerplate</li></ul></li><li>the code&rsquo;s domain significance</li></ul></li><li>resistance to refactoring:<ul><li>it is decreased by testing the behaviour(output),
not the steps to get to the end(or internal state)</li><li>false positives after a refactoring are a bad sign</li></ul></li><li>fast feedback:<ul><li>the faster the tests are, the more you can have and
you can run them more often</li><li>a fast feedback loop notifies you of the bugs as soon as they are introduced,
reducing the cost of solving them</li></ul></li><li>maintainability:<ul><li>how hard is it to understand the test?:<ul><li>test code is itself code, so make it readable</li></ul></li><li>how hard is it to run the test?:<ul><li>out-of-process dependencies need to be managed when testing(database restarts, fs cleanup, etc)</li></ul></li></ul></li></ol><h3 id=false-positives>false positives:</h3><ul><li>tight coupling of tests and SUT tend to generate more false positives</li></ul><h3 id=mocks>mocks:</h3><ul><li>mocks vs stubs</li><li>observable behaviour vs implementation details</li><li>mocks and test fragility</li><li>mocks without compromising resistance to refactoring</li></ul><h3 id=tools>tools:</h3><ul><li>test double:<ul><li>info:<ul><li>non-production-ready fake dependencies in a test</li></ul></li><li>fakes:<ul><li>a thin class that has the same api of a dependency of the tested class</li><li>it is used to separate real logic from checking if the logic was run</li><li>the tests are external to a fake</li></ul></li><li>mocks:<ul><li>a fake that has internal checks</li></ul></li></ul></li></ul><h3 id=styles>styles:</h3><ul><li>output:<ul><li>highest quality</li><li>can not be used everywhere, because functional programming can not be used everywhere:<ul><li>not usefull when SUT changes global state or internal private state</li></ul></li><li>run the SUT, then simply check the output</li><li>viable only if you know all the inputs up front</li></ul></li><li>state:<ul><li>SUT can mantain state that needs to be checked</li></ul></li><li>communication:<ul><li>should only be used ocassionally</li><li>mock SUT dependencies and check if they are called corectly</li></ul></li></ul><h3 id=functional-programming-principles>functional programming principles:</h3><ul><li>a function should be pure:<ul><li>it should not contain hidden inputs or outputs</li><li>all inputs and outputs should be declared in its signature</li><li>a pure function produces the same output from the same input, no matter how many times it&rsquo;s called,
it is deterministic</li><li>types of hidden inputs/outputs:<ul><li>side-effects:<ul><li>changing internal state or global state</li></ul></li><li>exceptions:<ul><li>thrown exception are caught on the stack not returned</li></ul></li></ul></li><li>rule of thumb:<ul><li>if you can replace the function call with its return value and the behaviour is still valid(referential transparency)</li></ul></li></ul></li><li>functional architecture should separate business logic from code that incurs side-effects,
by pushing the side-effects to the edges of the business logic:<ul><li>code that makes a decision</li><li>code that acts upon that decision</li></ul></li></ul><h3 id=what-to-refactor-and-how>what to refactor and how?:</h3><ul><li>what to test(unit-testing these helps alot with protection against regression):<ul><li>domain code:<ul><li>business logic that pertains directly to the usage of the application</li></ul></li><li>complex code</li></ul></li><li>types of code:<ul><li>domain model and algorithms(best ROI when testing):<ul><li>high domain/complex</li><li>low collaborators</li></ul></li><li>trivial code(never this this):<ul><li>low domain/complex</li><li>low collaborators</li></ul></li><li>controllers(test scarcely in itegration testing):<ul><li>low domain/complex</li><li>hight collaborators</li></ul></li><li>overcomplicated code(reduce this by splitting in domain and controllers):<ul><li>high domain/complex</li><li>high collaborators</li></ul></li></ul></li><li>misc:<ul><li>the more complex/domain a code is, the less collaborators it should have</li><li>getting rid of overcomplicated code and testing fully the domain is the path to a healthy test suite</li></ul></li></ul></article><nav class=site-nav><a href=https://www.dinudev.com//>Home</a>
<a href=https://www.dinudev.com//post/>All posts</a>
<a href=https://www.dinudev.com//journey/>The journey</a>
<a href=https://www.dinudev.com//paper/>Papers</a>
<a href=https://github.com/Owicca>GitHub</a></nav><footer class=site-footer><span class=owner>Â©2023 OWicca</span></footer></div><script src=https://www.dinudev.com/js/highlight.pack.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>