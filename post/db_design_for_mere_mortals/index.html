<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="OWicca"><meta name=generator content="Hugo 0.121.2"><title>DB design for mere mortals — Down the wabbit's hole</title>
<meta name=description content><link rel=canonical href=https://www.dinudev.com/post/db_design_for_mere_mortals/><link href rel=alternate type=application/rss+xml title="Down the wabbit's hole"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=https://www.dinudev.com/css/highlight.css><link rel=stylesheet href=https://www.dinudev.com/css/paperback.css><link rel=stylesheet href=https://www.dinudev.com/css/main.css><link rel=stylesheet href=https://www.dinudev.com/css/tabs.css></head><body><div class=container><header><h1>DB design for mere mortals</h1><nav class=site-nav><a href=/>Home</a>
<a href=/post/>All posts</a>
<a href=/thoughts/>Thoughts</a>
<a href=/paper/>Papers</a></nav></header><h3>Table of Contents</h3><aside><nav id=TableOfContents><ul><li><ul><li><a href=#relational-db-design>relational db design:</a></li><li><a href=#the-design-process>the design process</a></li><li><a href=#other-db-design-issues>other db design issues</a></li></ul></li></ul></nav></aside><article><h3 id=relational-db-design>relational db design:</h3><ol><li>relational db:</li></ol><ul><li>what is a database?:<ul><li>a collection of structured data, used to model a system&rsquo;s process</li><li>organised data for a specific purpose</li></ul></li><li>types of dbs? operational vs analytical databases:<ul><li>operational:<ul><li>dbs where data changes often(daily) and fresh changes need to be available almost instantly</li></ul></li><li>analytical:<ul><li>dbs where change happens rarely and are mainly used to model trends, extract statistics or archive data</li></ul></li></ul></li><li>what is a relational database?:<ul><li>created in 1969 by Edgar F. Codd (IBM) to solve the problem of handling large amounts of data</li><li>he was a mathematician so he used set theory and first-order predicate logic to solve problems such as:<ul><li>data redundancy</li><li>weak data integrity</li><li>database structure&rsquo;s overdependence on its physical implementation</li></ul></li></ul></li><li>relations in a relational db:<ul><li>the term comes from set-theory not from the common missconception that in a rdbms, a table could be related to another</li><li>data is stored in relations(perceived as tables):<ul><li>tuples(records)</li><li>attributes(fields)</li></ul></li><li>the physical order of the records is irelevant, every record is identified by a field that contains a unique value</li><li>relations are categorised in:<ul><li>one-to-one</li><li>one-to-many</li><li>many-to-many</li></ul></li><li>a relationship between two tables is established by matching a value in a field shared by both tables</li></ul></li><li>retrieving data:<ul><li>data is retrieved using SQL(Structured Query Language),
a language tightly connected to the relational model</li><li>basic structure:<ul><li>select: <code>SELECT field1, field2, fieldN</code></li><li>source: <code>FROM table1, table2, tableN</code></li><li>filter: <code>WHERE field1 > field2</code></li><li>sort: <code>ORDER BY field1</code></li></ul></li></ul></li><li>relational database management systems(rdbms):<ul><li>an software aplication that helps in managing a relational db</li><li>advantages:<ul><li>multi-level integrity:<ul><li>field level: by constraning the domain of the values</li><li>table level: to ensure records are not duplicated or primary keys are mission</li><li>relation level: to ensure relations are valid</li></ul></li><li>logical and physical data independence:<ul><li>it does not matter for the user if the data is stored in ram, disk, network attached disk</li><li>it does not affect the user in which way parts of the records are saved(if sparse, if fields are fragmented in multiple places, if indexes are stored separatedly, etc)</li><li>the user is only concerned with the table schema and the primary key</li></ul></li><li>data consistency and accuracy:<ul><li>data is consistent because it constraints the input to certain domains(field types)</li></ul></li><li>easy data retrieval:<ul><li>same data can be joined and viewed in almost unlimited ways</li></ul></li></ul></li></ul></li><li>what next?:<ul><li>hardware evolved and software techniques are better, which in turn enable better rdbms</li><li>new types of data appear which are not well suited for the relational model:<ul><li>photos</li><li>read-only</li><li>graph</li><li>geospatial</li><li>analytics</li></ul></li></ul></li></ul><ol start=2><li>design objectives:</li></ol><ul><li>why is db design important?<ul><li>bad/no design results in innacurate information</li><li>its easier to plan 3 days and work for 1,
than to plan 1 day and work for 3</li><li>when planning you can take into account the C.I.A. triad:<ul><li>consistency</li><li>integrity</li><li>accuracy</li></ul></li><li>steps:<ol><li>design the logical structure(it&rsquo;s abstract)</li><li>implement the logical structure using the tools the rdbms provides</li></ol></li></ul></li><li>why is theory(principles) important?<ul><li>theory is important because it is general and helps predict outcomes</li><li>the relational model is based on sound mathematical models from set-theory and first-order predicate logic,
which makes it highly reliable</li></ul></li><li>[] what is set-theory?</li><li>[] what is first-order predicate logic?</li><li>what are the objectives of good design?<ul><li>the db supports both required and ad-hoc retrieval:<ul><li>store required data</li><li>retrieve data with custom queries</li></ul></li><li>accuracy:<ul><li>each table represents a single subject</li><li>each field is distinct</li><li>each record is identified by a field with an unique value</li><li>redundant data is at a minimum</li></ul></li><li>integrity:<ul><li>fields, records and relations should be always valid</li></ul></li><li>supports business rules relevant to the organisation:<ul><li>example:<ul><li>never return a birth date before 1850(nobody alive is that old)</li><li>never return negative prices</li><li>never return negative unit counts(you can&rsquo;t have -4 chairs)</li></ul></li></ul></li><li>the db is easy to expand</li></ul></li><li>what are the benefits of good design?:<ul><li>db structure is easy to modify and mantain:<ul><li>modifications to a field, table or relation don&rsquo;t affect others</li></ul></li><li>data is easy to modify:<ul><li>modifying a field won&rsquo;t affect other fields</li><li>duplication is minimum, so 1 change affects only one value</li></ul></li><li>information is easy to retrieve:<ul><li>table relationships are obvious in well-designed dbs</li></ul></li><li>end-user applications are easier to develop:<ul><li>you don&rsquo;t have to waste time on fixing problems in poorly designed dbs,
instead you can focus on app development</li></ul></li></ul></li><li>what are some database-design methods?:<ul><li>traditional:<ol><li>requirements analysis:<ul><li>gather the business and informational requirements(from users, admins, etc)</li></ul></li><li>data modeling:<ul><li>model the structure using a data-modeling method:<ul><li>entity-relationship diagraming(ER)</li><li>semantic-object modeling</li><li>object-role modeling</li><li>UML modeling</li></ul></li><li>identify and implement data integrity levels(domains, primary keys, foreign keys)</li></ul></li><li>normalization:<ul><li>the process of spliting data into multiple tables,
to avoid duplication and redundancy</li><li>it helps in avoiding various errors:<ul><li>insertion</li><li>updating</li><li>deletion</li></ul></li><li>normalization uses a set of normal forms to test for particular problems(to achieve a particular normal form, changes to the table might be needed):<ul><li>first normal form</li><li>second normal form</li><li>third normal form</li><li>fourth normal form</li><li>fifth normal form</li><li>sixth normal form</li><li>boyce-codd normal form</li><li>domain/key normal form</li></ul></li></ul></li></ol></li></ul></li><li>what is normalization?</li><li>what is a primary key?</li></ul><ol start=3><li>terminology:</li></ol><ul><li>why is terminology important?:<ul><li>db design is based in logic and set-theory and
terminology is used to express the concepts and ideeas from theory</li><li>terms are used to process and describe the db design process itself</li><li>terms are used by every rdbms(and it&rsquo;s documentation or tutorials about it),
so knowing the terms will help you in handling a rdbms</li></ul></li><li>value-related terms(there is a difference between data and information):<ul><li>value:<ul><li>data:<ul><li>raw value</li><li>db values that are static until you change them</li><li>values you store</li></ul></li><li>information:<ul><li>processed data</li><li>it is resulting from an sql query, printed to the console or structured in a html table, etc</li><li>values you retrieve</li></ul></li></ul></li><li>null:<ul><li>missing or unknown value</li><li>pros:<ul><li>it is a placeholder for missing or unknown values</li></ul></li><li>cons:<ul><li>mathematical operations result in null if any operand is null(db does not notify you)</li><li>aggregate functions result in null if any value is null(db does not notify you)</li></ul></li></ul></li></ul></li><li>structure-related terms:<ul><li>table(relation):<ul><li>a representation for a relation</li><li>record order in the relation is irrelevant</li><li>can contain objects(and their relevant attributes) and
events(attributes of something that occured at a point in time)</li><li>structure:<ul><li>a list of fields</li><li>a list of records</li><li>each record has the same fields, with different values</li></ul></li><li>types:<ul><li>data: prone to change</li><li>validation:<ul><li>values rarely change</li><li>values in it are used to validate other data</li><li>used to store values that help with data integrity</li></ul></li></ul></li></ul></li><li>record(tuple):<ul><li>a uniquely identified subject in a relation(identified by a primary key)</li><li>contains all the fields of the table treated as a unit,
each field holding a value of an attribute of that particular subject</li></ul></li><li>field(attribute):<ul><li>structure:<ul><li>a name that hits to its type</li><li>one and only one value</li></ul></li><li>types of fields in improperly designed db:<ul><li>multipart: multiple values in a field</li><li>multivalued: multiple instances of the same type</li><li>calculated: concatenatex text value or result of mathematical expression</li></ul></li></ul></li><li>view:<ul><li>a &ldquo;virtual&rdquo; table composed from a combination of fields from one or more tables(base tables)</li></ul></li><li>key:<ul><li>special fields</li><li>types:<ul><li>primary:<ul><li>uniquely identifies a record in a relation</li><li>enforces table-level integrity and helps establish relations between tables</li></ul></li><li>foreign:<ul><li>embed the primary key of another table(that&rsquo;s why it&rsquo;s &ldquo;foreign&rdquo;),
to signify a relation with it</li><li>enforces relation integrity, because a foreign key MUST exist as a primary key of some record in the referenced relation</li></ul></li></ul></li></ul></li><li>index:<ul><li>a physical structure used to optimize data processing</li><li>it is an implementation detail of the rdbms</li></ul></li></ul></li><li>relationship-related terms(relations are connections between pairs of tables):<ul><li>association of two tables through primary-foreign keys or through a linking-table(pivot table)</li><li>reduces redundant and duplicated data</li><li>enables views</li><li>types:<ul><li>one-to-one:<ul><li>a &ldquo;parent&rdquo; to &ldquo;child&rdquo; relationship</li><li>the child holds a foreign key to the parent&rsquo;s primary key</li></ul></li><li>one-to-many:<ul><li>another &ldquo;parent&rdquo; to &ldquo;child&rdquo; relationship</li><li>this type presumes a parent can have zero, one or many children</li></ul></li><li>many-to-many:<ul><li>a linking table is composed from the primary keys of both tables in m2m relationship</li><li>both primary keys(from the tables) will also be foreign keys(in the privot) and a composite primary key(of the pivot)</li></ul></li></ul></li><li>participation:<ul><li>mandatory:<ul><li>in a one2one, a parent is mandatory for the children</li></ul></li><li>optional</li></ul></li><li>degree of participation(!?!?!)</li></ul></li><li>integrity-related terms(data integrity is the primary benefit of database-design):<ul><li>field specification(the domain, the type):<ul><li>general:<ul><li>name</li><li>description</li><li>parent table</li></ul></li><li>physical:<ul><li>data type</li><li>length</li><li>character support</li></ul></li><li>logical:<ul><li>required value</li><li>range of values</li><li>null support</li></ul></li></ul></li><li>types:<ul><li>table-level(entity integrity):<ul><li>ensure no duplicate records exist</li><li>every record is identified by a field with a unique and non-null value</li></ul></li><li>field-level(domain integrity)</li><li>relationship-level(referential integrity):<ul><li>tables in a relationship are synchronized whenever a change is made(insert, update, delete)</li></ul></li><li>business rules(?!!?)</li></ul></li></ul></li></ul><h3 id=the-design-process>the design process</h3><h3 id=other-db-design-issues>other db design issues</h3></article><nav class=site-nav><a href=https://www.dinudev.com//>Home</a>
<a href=https://www.dinudev.com//post/>All posts</a>
<a href=https://www.dinudev.com//thoughts/>Thoughts</a>
<a href=https://www.dinudev.com//paper/>Papers</a>
<a href=https://github.com/Owicca>GitHub</a></nav><footer class=site-footer><span class=owner>©2024 OWicca</span></footer></div><script src=https://www.dinudev.com/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><script src=https://www.dinudev.com/js/tabs.js></script></body></html>