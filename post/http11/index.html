<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="OWicca">
  <meta name="generator" content="Hugo 0.69.0-DEV" />
  <title>HTTP 1.1 RFC â€” Down the wabbit&#39;s hole</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://www.dinudev.com/post/http11/">
  <link href="" rel="alternate"
    type="application/rss+xml" title="Down the wabbit&#39;s hole">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://www.dinudev.com/css/highlight.css">
  <link rel="stylesheet" href="https://www.dinudev.com/css/paperback.css">
  <link rel="stylesheet" href="https://www.dinudev.com//main.css">
</head>


<body>
  <div class="container">

    <header>
  
  <h1>HTTP 1.1 RFC</h1>

  
  <time datetime="2020-03-22 19:53:00 &#43;0200 EET">2020/03/22</time>
  

  
  <nav class="site-nav">
  <a href="/">Home</a>
  <a href="/post/">All posts</a>

  

  

  
</nav>

</header>

	
	
	<h3>Table of Contents</h3>
	<aside>
		<nav id="TableOfContents"></nav>
	</aside>
	
    <article>
      <p>Network Working Group                                      R. Fielding
Request for Comments: 2068                                   UC Irvine
Category: Standards Track                                    J. Gettys
J. Mogul
DEC
H. Frystyk
T. Berners-Lee
MIT/LCS
January 1997</p>
<pre><code>            Hypertext Transfer Protocol -- HTTP/1.1
</code></pre>
<p>Status of this Memo</p>
<p>This document specifies an Internet standards track protocol for the
Internet community, and requests discussion and suggestions for
improvements.  Please refer to the current edition of the &ldquo;Internet
Official Protocol Standards&rdquo; (STD 1) for the standardization state
and status of this protocol.  Distribution of this memo is unlimited.</p>
<p>Abstract</p>
<p>The Hypertext Transfer Protocol (HTTP) is an application-level
protocol for distributed, collaborative, hypermedia information
systems. It is a generic, stateless, object-oriented protocol which
can be used for many tasks, such as name servers and distributed
object management systems, through extension of its request methods.
A feature of HTTP is the typing and negotiation of data
representation, allowing systems to be built independently of the
data being transferred.</p>
<p>HTTP has been in use by the World-Wide Web global information
initiative since 1990. This specification defines the protocol
referred to as &ldquo;HTTP/1.1&rdquo;.</p>
<p>Table of Contents</p>
<p>1 Introduction&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;7
1.1 Purpose &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.7
1.2 Requirements &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..7
1.3 Terminology &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;8
1.4 Overall Operation &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..11
2 Notational Conventions and Generic Grammar&hellip;&hellip;&hellip;&hellip;..13
2.1 Augmented BNF &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;13
2.2 Basic Rules &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..15
3 Protocol Parameters&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.17
3.1 HTTP Version &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.17</p>
<p>Fielding, et. al.           Standards Track                     [Page 1]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>3.2 Uniform Resource Identifiers ........................18
 3.2.1 General Syntax ...................................18
 3.2.2 http URL .........................................19
 3.2.3 URI Comparison ...................................20
3.3 Date/Time Formats ...................................21
 3.3.1 Full Date ........................................21
 3.3.2 Delta Seconds ....................................22
3.4 Character Sets ......................................22
3.5 Content Codings .....................................23
3.6 Transfer Codings ....................................24
3.7 Media Types .........................................25
 3.7.1 Canonicalization and Text Defaults ...............26
 3.7.2 Multipart Types ..................................27
3.8 Product Tokens ......................................28
3.9 Quality Values ......................................28
3.10 Language Tags ......................................28
3.11 Entity Tags ........................................29
3.12 Range Units ........................................30
</code></pre>
<p>4 HTTP Message&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..30
4.1 Message Types &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;30
4.2 Message Headers &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.31
4.3 Message Body &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.32
4.4 Message Length &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..32
4.5 General Header Fields &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.34
5 Request&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.34
5.1 Request-Line &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.34
5.1.1 Method &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.35
5.1.2 Request-URI &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..35
5.2 The Resource Identified by a Request &hellip;&hellip;&hellip;&hellip;&hellip;.37
5.3 Request Header Fields &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.37
6 Response&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;38
6.1 Status-Line &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..38
6.1.1 Status Code and Reason Phrase &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..39
6.2 Response Header Fields &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;41
7 Entity&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..41
7.1 Entity Header Fields &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..41
7.2 Entity Body &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..42
7.2.1 Type &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;42
7.2.2 Length &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.43
8 Connections&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;43
8.1 Persistent Connections &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;43
8.1.1 Purpose &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;43
8.1.2 Overall Operation &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..44
8.1.3 Proxy Servers &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;45
8.1.4 Practical Considerations &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.45
8.2 Message Transmission Requirements &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.46
9 Method Definitions&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..48
9.1 Safe and Idempotent Methods &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.48</p>
<p>Fielding, et. al.           Standards Track                     [Page 2]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> 9.1.1 Safe Methods .....................................48
 9.1.2 Idempotent Methods ...............................49
9.2 OPTIONS .............................................49
9.3 GET .................................................50
9.4 HEAD ................................................50
9.5 POST ................................................51
9.6 PUT .................................................52
9.7 DELETE ..............................................53
9.8 TRACE ...............................................53
</code></pre>
<p>10 Status Code Definitions&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..53
10.1 Informational 1xx &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.54
10.1.1 100 Continue &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;54
10.1.2 101 Switching Protocols &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.54
10.2 Successful 2xx &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.54
10.2.1 200 OK &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;54
10.2.2 201 Created &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.55
10.2.3 202 Accepted &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;55
10.2.4 203 Non-Authoritative Information &hellip;&hellip;&hellip;&hellip;&hellip;55
10.2.5 204 No Content &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.55
10.2.6 205 Reset Content &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.56
10.2.7 206 Partial Content &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..56
10.3 Redirection 3xx &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;56
10.3.1 300 Multiple Choices &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.57
10.3.2 301 Moved Permanently &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;57
10.3.3 302 Moved Temporarily &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;58
10.3.4 303 See Other &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..58
10.3.5 304 Not Modified &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..58
10.3.6 305 Use Proxy &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..59
10.4 Client Error 4xx &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..59
10.4.1 400 Bad Request &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;60
10.4.2 401 Unauthorized &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..60
10.4.3 402 Payment Required &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.60
10.4.4 403 Forbidden &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..60
10.4.5 404 Not Found &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..60
10.4.6 405 Method Not Allowed &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..61
10.4.7 406 Not Acceptable &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;61
10.4.8 407 Proxy Authentication Required &hellip;&hellip;&hellip;&hellip;&hellip;61
10.4.9 408 Request Timeout &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..62
10.4.10 409 Conflict &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..62
10.4.11 410 Gone &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;62
10.4.12 411 Length Required &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.63
10.4.13 412 Precondition Failed &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;63
10.4.14 413 Request Entity Too Large &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.63
10.4.15 414 Request-URI Too Long &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..63
10.4.16 415 Unsupported Media Type &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;63
10.5 Server Error 5xx &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..64
10.5.1 500 Internal Server Error &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..64
10.5.2 501 Not Implemented &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..64</p>
<p>Fielding, et. al.           Standards Track                     [Page 3]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> 10.5.3 502 Bad Gateway .................................64
 10.5.4 503 Service Unavailable .........................64
 10.5.5 504 Gateway Timeout .............................64
 10.5.6 505 HTTP Version Not Supported ..................65
</code></pre>
<p>11 Access Authentication&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.65
11.1 Basic Authentication Scheme &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;66
11.2 Digest Authentication Scheme &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..67
12 Content Negotiation&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;67
12.1 Server-driven Negotiation &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..68
12.2 Agent-driven Negotiation &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;69
12.3 Transparent Negotiation &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.70
13 Caching in HTTP&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.70
13.1.1 Cache Correctness &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.72
13.1.2 Warnings &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.73
13.1.3 Cache-control Mechanisms &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;74
13.1.4 Explicit User Agent Warnings &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..74
13.1.5 Exceptions to the Rules and Warnings &hellip;&hellip;&hellip;&hellip;75
13.1.6 Client-controlled Behavior &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.75
13.2 Expiration Model &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..75
13.2.1 Server-Specified Expiration &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;75
13.2.2 Heuristic Expiration &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.76
13.2.3 Age Calculations &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..77
13.2.4 Expiration Calculations &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.79
13.2.5 Disambiguating Expiration Values &hellip;&hellip;&hellip;&hellip;&hellip;.80
13.2.6 Disambiguating Multiple Responses &hellip;&hellip;&hellip;&hellip;&hellip;80
13.3 Validation Model &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..81
13.3.1 Last-modified Dates &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..82
13.3.2 Entity Tag Cache Validators &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;82
13.3.3 Weak and Strong Validators &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.82
13.3.4 Rules for When to Use Entity Tags and Last-
modified Dates&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;85
13.3.5 Non-validating Conditionals &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;86
13.4 Response Cachability &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.86
13.5 Constructing Responses From Caches &hellip;&hellip;&hellip;&hellip;&hellip;..87
13.5.1 End-to-end and Hop-by-hop Headers &hellip;&hellip;&hellip;&hellip;&hellip;88
13.5.2 Non-modifiable Headers &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..88
13.5.3 Combining Headers &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.89
13.5.4 Combining Byte Ranges &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;90
13.6 Caching Negotiated Responses &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..90
13.7 Shared and Non-Shared Caches &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..91
13.8 Errors or Incomplete Response Cache Behavior &hellip;&hellip;.91
13.9 Side Effects of GET and HEAD &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..92
13.10 Invalidation After Updates or Deletions &hellip;&hellip;&hellip;..92
13.11 Write-Through Mandatory &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;93
13.12 Cache Replacement &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;93
13.13 History Lists &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.93
14 Header Field Definitions&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.94
14.1 Accept &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;95</p>
<p>Fielding, et. al.           Standards Track                     [Page 4]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>14.2 Accept-Charset .....................................97
14.3 Accept-Encoding ....................................97
14.4 Accept-Language ....................................98
14.5 Accept-Ranges ......................................99
14.6 Age ................................................99
14.7 Allow .............................................100
14.8 Authorization .....................................100
14.9 Cache-Control .....................................101
 14.9.1 What is Cachable ...............................103
 14.9.2 What May be Stored by Caches ...................103
 14.9.3 Modifications of the Basic Expiration Mechanism 104
 14.9.4 Cache Revalidation and Reload Controls .........105
 14.9.5 No-Transform Directive .........................107
 14.9.6 Cache Control Extensions .......................108
14.10 Connection .......................................109
14.11 Content-Base .....................................109
14.12 Content-Encoding .................................110
14.13 Content-Language .................................110
14.14 Content-Length ...................................111
14.15 Content-Location .................................112
14.16 Content-MD5 ......................................113
14.17 Content-Range ....................................114
14.18 Content-Type .....................................116
14.19 Date .............................................116
14.20 ETag .............................................117
14.21 Expires ..........................................117
14.22 From .............................................118
14.23 Host .............................................119
14.24 If-Modified-Since ................................119
14.25 If-Match .........................................121
14.26 If-None-Match ....................................122
14.27 If-Range .........................................123
14.28 If-Unmodified-Since ..............................124
14.29 Last-Modified ....................................124
14.30 Location .........................................125
14.31 Max-Forwards .....................................125
14.32 Pragma ...........................................126
14.33 Proxy-Authenticate ...............................127
14.34 Proxy-Authorization ..............................127
14.35 Public ...........................................127
14.36 Range ............................................128
 14.36.1 Byte Ranges ...................................128
 14.36.2 Range Retrieval Requests ......................130
14.37 Referer ..........................................131
14.38 Retry-After ......................................131
14.39 Server ...........................................132
14.40 Transfer-Encoding ................................132
14.41 Upgrade ..........................................132
</code></pre>
<p>Fielding, et. al.           Standards Track                     [Page 5]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>14.42 User-Agent .......................................134
14.43 Vary .............................................134
14.44 Via ..............................................135
14.45 Warning ..........................................137
14.46 WWW-Authenticate .................................139
</code></pre>
<p>15 Security Considerations&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.139
15.1 Authentication of Clients &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.139
15.2 Offering a Choice of Authentication Schemes &hellip;&hellip;.140
15.3 Abuse of Server Log Information &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.141
15.4 Transfer of Sensitive Information &hellip;&hellip;&hellip;&hellip;&hellip;..141
15.5 Attacks Based On File and Path Names &hellip;&hellip;&hellip;&hellip;..142
15.6 Personal Information &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;143
15.7 Privacy Issues Connected to Accept Headers &hellip;&hellip;..143
15.8 DNS Spoofing &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..144
15.9 Location Headers and Spoofing &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;144
16 Acknowledgments&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;144
17 References&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..146
18 Authors&rsquo; Addresses&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;149
19 Appendices&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..150
19.1 Internet Media Type message/http &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;150
19.2 Internet Media Type multipart/byteranges &hellip;&hellip;&hellip;.150
19.3 Tolerant Applications &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..151
19.4 Differences Between HTTP Entities and
MIME Entities&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.152
19.4.1 Conversion to Canonical Form &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.152
19.4.2 Conversion of Date Formats &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;153
19.4.3 Introduction of Content-Encoding &hellip;&hellip;&hellip;&hellip;&hellip;153
19.4.4 No Content-Transfer-Encoding &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.153
19.4.5 HTTP Header Fields in Multipart Body-Parts &hellip;..153
19.4.6 Introduction of Transfer-Encoding &hellip;&hellip;&hellip;&hellip;..154
19.4.7 MIME-Version &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..154
19.5 Changes from HTTP/1.0 &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..154
19.5.1 Changes to Simplify Multi-homed Web Servers and
Conserve IP Addresses &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;155
19.6 Additional Features &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.156
19.6.1 Additional Request Methods &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;156
19.6.2 Additional Header Field Definitions &hellip;&hellip;&hellip;&hellip;156
19.7 Compatibility with Previous Versions &hellip;&hellip;&hellip;&hellip;..160
19.7.1 Compatibility with HTTP/1.0 Persistent
Connections&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..161</p>
<p>Fielding, et. al.           Standards Track                     [Page 6]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>1 Introduction</p>
<p>1.1 Purpose</p>
<p>The Hypertext Transfer Protocol (HTTP) is an application-level
protocol for distributed, collaborative, hypermedia information
systems. HTTP has been in use by the World-Wide Web global
information initiative since 1990. The first version of HTTP,
referred to as HTTP/0.9, was a simple protocol for raw data transfer
across the Internet. HTTP/1.0, as defined by RFC 1945 [6], improved
the protocol by allowing messages to be in the format of MIME-like
messages, containing metainformation about the data transferred and
modifiers on the request/response semantics. However, HTTP/1.0 does
not sufficiently take into consideration the effects of hierarchical
proxies, caching, the need for persistent connections, and virtual
hosts. In addition, the proliferation of incompletely-implemented
applications calling themselves &ldquo;HTTP/1.0&rdquo; has necessitated a
protocol version change in order for two communicating applications
to determine each other&rsquo;s true capabilities.</p>
<p>This specification defines the protocol referred to as &ldquo;HTTP/1.1&rdquo;.
This protocol includes more stringent requirements than HTTP/1.0 in
order to ensure reliable implementation of its features.</p>
<p>Practical information systems require more functionality than simple
retrieval, including search, front-end update, and annotation. HTTP
allows an open-ended set of methods that indicate the purpose of a
request. It builds on the discipline of reference provided by the
Uniform Resource Identifier (URI) [3][20], as a location (URL) [4] or
name (URN) , for indicating the resource to which a method is to be
applied. Messages are passed in a format similar to that used by
Internet mail as defined by the Multipurpose Internet Mail Extensions
(MIME).</p>
<p>HTTP is also used as a generic protocol for communication between
user agents and proxies/gateways to other Internet systems, including
those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],
and WAIS [10] protocols. In this way, HTTP allows basic hypermedia
access to resources available from diverse applications.</p>
<p>1.2 Requirements</p>
<p>This specification uses the same words as RFC 1123 [8] for defining
the significance of each particular requirement. These words are:</p>
<p>MUST
This word or the adjective &ldquo;required&rdquo; means that the item is an
absolute requirement of the specification.</p>
<p>Fielding, et. al.           Standards Track                     [Page 7]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>SHOULD
This word or the adjective &ldquo;recommended&rdquo; means that there may
exist valid reasons in particular circumstances to ignore this
item, but the full implications should be understood and the case
carefully weighed before choosing a different course.</p>
<p>MAY
This word or the adjective &ldquo;optional&rdquo; means that this item is
truly optional. One vendor may choose to include the item because
a particular marketplace requires it or because it enhances the
product, for example; another vendor may omit the same item.</p>
<p>An implementation is not compliant if it fails to satisfy one or more
of the MUST requirements for the protocols it implements. An
implementation that satisfies all the MUST and all the SHOULD
requirements for its protocols is said to be &ldquo;unconditionally
compliant&rdquo;; one that satisfies all the MUST requirements but not all
the SHOULD requirements for its protocols is said to be
&ldquo;conditionally compliant.&rdquo;</p>
<p>1.3 Terminology</p>
<p>This specification uses a number of terms to refer to the roles
played by participants in, and objects of, the HTTP communication.</p>
<p>connection
A transport layer virtual circuit established between two programs
for the purpose of communication.</p>
<p>message
The basic unit of HTTP communication, consisting of a structured
sequence of octets matching the syntax defined in section 4 and
transmitted via the connection.</p>
<p>request
An HTTP request message, as defined in section 5.</p>
<p>response
An HTTP response message, as defined in section 6.</p>
<p>resource
A network data object or service that can be identified by a URI,
as defined in section 3.2. Resources may be available in multiple
representations (e.g. multiple languages, data formats, size,
resolutions) or vary in other ways.</p>
<p>Fielding, et. al.           Standards Track                     [Page 8]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>entity
The information transferred as the payload of a request or
response. An entity consists of metainformation in the form of
entity-header fields and content in the form of an entity-body, as
described in section 7.</p>
<p>representation
An entity included with a response that is subject to content
negotiation, as described in section 12. There may exist multiple
representations associated with a particular response status.</p>
<p>content negotiation
The mechanism for selecting the appropriate representation when
servicing a request, as described in section 12. The
representation of entities in any response can be negotiated
(including error responses).</p>
<p>variant
A resource may have one, or more than one, representation(s)
associated with it at any given instant. Each of these
representations is termed a <code>variant.' Use of the term </code>variant&rsquo;
does not necessarily imply that the resource is subject to content
negotiation.</p>
<p>client
A program that establishes connections for the purpose of sending
requests.</p>
<p>user agent
The client which initiates a request. These are often browsers,
editors, spiders (web-traversing robots), or other end user tools.</p>
<p>server
An application program that accepts connections in order to
service requests by sending back responses. Any given program may
be capable of being both a client and a server; our use of these
terms refers only to the role being performed by the program for a
particular connection, rather than to the program&rsquo;s capabilities
in general.  Likewise, any server may act as an origin server,
proxy, gateway, or tunnel, switching behavior based on the nature
of each request.</p>
<p>origin server
The server on which a given resource resides or is to be created.</p>
<p>Fielding, et. al.           Standards Track                     [Page 9]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>proxy
An intermediary program which acts as both a server and a client
for the purpose of making requests on behalf of other clients.
Requests are serviced internally or by passing them on, with
possible translation, to other servers. A proxy must implement
both the client and server requirements of this specification.</p>
<p>gateway
A server which acts as an intermediary for some other server.
Unlike a proxy, a gateway receives requests as if it were the
origin server for the requested resource; the requesting client
may not be aware that it is communicating with a gateway.</p>
<p>tunnel
An intermediary program which is acting as a blind relay between
two connections. Once active, a tunnel is not considered a party
to the HTTP communication, though the tunnel may have been
initiated by an HTTP request. The tunnel ceases to exist when both
ends of the relayed connections are closed.</p>
<p>cache
A program&rsquo;s local store of response messages and the subsystem
that controls its message storage, retrieval, and deletion. A
cache stores cachable responses in order to reduce the response
time and network bandwidth consumption on future, equivalent
requests. Any client or server may include a cache, though a cache
cannot be used by a server that is acting as a tunnel.</p>
<p>cachable
A response is cachable if a cache is allowed to store a copy of
the response message for use in answering subsequent requests. The
rules for determining the cachability of HTTP responses are
defined in section 13. Even if a resource is cachable, there may
be additional constraints on whether a cache can use the cached
copy for a particular request.</p>
<p>first-hand
A response is first-hand if it comes directly and without
unnecessary delay from the origin server, perhaps via one or more
proxies. A response is also first-hand if its validity has just
been checked directly with the origin server.</p>
<p>explicit expiration time
The time at which the origin server intends that an entity should
no longer be returned by a cache without further validation.</p>
<p>Fielding, et. al.           Standards Track                    [Page 10]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>heuristic expiration time
An expiration time assigned by a cache when no explicit expiration
time is available.</p>
<p>age
The age of a response is the time since it was sent by, or
successfully validated with, the origin server.</p>
<p>freshness lifetime
The length of time between the generation of a response and its
expiration time.</p>
<p>fresh
A response is fresh if its age has not yet exceeded its freshness
lifetime.</p>
<p>stale
A response is stale if its age has passed its freshness lifetime.</p>
<p>semantically transparent
A cache behaves in a &ldquo;semantically transparent&rdquo; manner, with
respect to a particular response, when its use affects neither the
requesting client nor the origin server, except to improve
performance. When a cache is semantically transparent, the client
receives exactly the same response (except for hop-by-hop headers)
that it would have received had its request been handled directly
by the origin server.</p>
<p>validator
A protocol element (e.g., an entity tag or a Last-Modified time)
that is used to find out whether a cache entry is an equivalent
copy of an entity.</p>
<p>1.4 Overall Operation</p>
<p>The HTTP protocol is a request/response protocol. A client sends a
request to the server in the form of a request method, URI, and
protocol version, followed by a MIME-like message containing request
modifiers, client information, and possible body content over a
connection with a server. The server responds with a status line,
including the message&rsquo;s protocol version and a success or error code,
followed by a MIME-like message containing server information, entity
metainformation, and possible entity-body content. The relationship
between HTTP and MIME is described in appendix 19.4.</p>
<p>Fielding, et. al.           Standards Track                    [Page 11]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Most HTTP communication is initiated by a user agent and consists of
a request to be applied to a resource on some origin server. In the
simplest case, this may be accomplished via a single connection (v)
between the user agent (UA) and the origin server (O).</p>
<pre><code>         request chain ------------------------&gt;
      UA -------------------v------------------- O
         &lt;----------------------- response chain
</code></pre>
<p>A more complicated situation occurs when one or more intermediaries
are present in the request/response chain. There are three common
forms of intermediary: proxy, gateway, and tunnel. A proxy is a
forwarding agent, receiving requests for a URI in its absolute form,
rewriting all or part of the message, and forwarding the reformatted
request toward the server identified by the URI. A gateway is a
receiving agent, acting as a layer above some other server(s) and, if
necessary, translating the requests to the underlying server&rsquo;s
protocol. A tunnel acts as a relay point between two connections
without changing the messages; tunnels are used when the
communication needs to pass through an intermediary (such as a
firewall) even when the intermediary cannot understand the contents
of the messages.</p>
<pre><code>         request chain --------------------------------------&gt;
      UA -----v----- A -----v----- B -----v----- C -----v----- O
         &lt;------------------------------------- response chain
</code></pre>
<p>The figure above shows three intermediaries (A, B, and C) between the
user agent and origin server. A request or response message that
travels the whole chain will pass through four separate connections.
This distinction is important because some HTTP communication options
may apply only to the connection with the nearest, non-tunnel
neighbor, only to the end-points of the chain, or to all connections
along the chain.  Although the diagram is linear, each participant
may be engaged in multiple, simultaneous communications. For example,
B may be receiving requests from many clients other than A, and/or
forwarding requests to servers other than C, at the same time that it
is handling A&rsquo;s request.</p>
<p>Any party to the communication which is not acting as a tunnel may
employ an internal cache for handling requests. The effect of a cache
is that the request/response chain is shortened if one of the
participants along the chain has a cached response applicable to that
request. The following illustrates the resulting chain if B has a
cached copy of an earlier response from O (via C) for a request which
has not been cached by UA or A.</p>
<p>Fielding, et. al.           Standards Track                    [Page 12]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>         request chain ----------&gt;
      UA -----v----- A -----v----- B - - - - - - C - - - - - - O
         &lt;--------- response chain
</code></pre>
<p>Not all responses are usefully cachable, and some requests may
contain modifiers which place special requirements on cache behavior.
HTTP requirements for cache behavior and cachable responses are
defined in section 13.</p>
<p>In fact, there are a wide variety of architectures and configurations
of caches and proxies currently being experimented with or deployed
across the World Wide Web; these systems include national hierarchies
of proxy caches to save transoceanic bandwidth, systems that
broadcast or multicast cache entries, organizations that distribute
subsets of cached data via CD-ROM, and so on. HTTP systems are used
in corporate intranets over high-bandwidth links, and for access via
PDAs with low-power radio links and intermittent connectivity. The
goal of HTTP/1.1 is to support the wide diversity of configurations
already deployed while introducing protocol constructs that meet the
needs of those who build web applications that require high
reliability and, failing that, at least reliable indications of
failure.</p>
<p>HTTP communication usually takes place over TCP/IP connections. The
default port is TCP 80, but other ports can be used. This does not
preclude HTTP from being implemented on top of any other protocol on
the Internet, or on other networks. HTTP only presumes a reliable
transport; any protocol that provides such guarantees can be used;
the mapping of the HTTP/1.1 request and response structures onto the
transport data units of the protocol in question is outside the scope
of this specification.</p>
<p>In HTTP/1.0, most implementations used a new connection for each
request/response exchange. In HTTP/1.1, a connection may be used for
one or more request/response exchanges, although connections may be
closed for a variety of reasons (see section 8.1).</p>
<p>2 Notational Conventions and Generic Grammar</p>
<p>2.1 Augmented BNF</p>
<p>All of the mechanisms specified in this document are described in
both prose and an augmented Backus-Naur Form (BNF) similar to that
used by RFC 822 [9]. Implementers will need to be familiar with the
notation in order to understand this specification. The augmented BNF
includes the following constructs:</p>
<p>Fielding, et. al.           Standards Track                    [Page 13]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>name = definition
The name of a rule is simply the name itself (without any enclosing
&ldquo;&lt;&rdquo; and &ldquo;&gt;&rdquo;) and is separated from its definition by the equal &ldquo;=&rdquo;
character. Whitespace is only significant in that indentation of
continuation lines is used to indicate a rule definition that spans
more than one line. Certain basic rules are in uppercase, such as
SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle brackets are used
within definitions whenever their presence will facilitate
discerning the use of rule names.</p>
<p>&ldquo;literal&rdquo;
Quotation marks surround literal text. Unless stated otherwise, the
text is case-insensitive.</p>
<p>rule1 | rule2
Elements separated by a bar (&ldquo;|&rdquo;) are alternatives, e.g., &ldquo;yes |
no&rdquo; will accept yes or no.</p>
<p>(rule1 rule2)
Elements enclosed in parentheses are treated as a single element.
Thus, &ldquo;(elem (foo | bar) elem)&rdquo; allows the token sequences &ldquo;elem
foo elem&rdquo; and &ldquo;elem bar elem&rdquo;.</p>
<p><em>rule
The character &ldquo;</em>&rdquo; preceding an element indicates repetition. The
full form is &ldquo;<!-- raw HTML omitted --><em><!-- raw HTML omitted -->element&rdquo; indicating at least <!-- raw HTML omitted --> and at most
<!-- raw HTML omitted --> occurrences of element. Default values are 0 and infinity so
that &ldquo;</em>(element)&rdquo; allows any number, including zero; &ldquo;1<em>element&rdquo;
requires at least one; and &ldquo;1</em>2element&rdquo; allows one or two.</p>
<p>[rule]
Square brackets enclose optional elements; &ldquo;[foo bar]&rdquo; is
equivalent to &ldquo;*1(foo bar)&quot;.</p>
<p>N rule
Specific repetition: &ldquo;<!-- raw HTML omitted -->(element)&rdquo; is equivalent to
&ldquo;<!-- raw HTML omitted -->*<!-- raw HTML omitted -->(element)&quot;; that is, exactly <!-- raw HTML omitted --> occurrences of (element).
Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three
alphabetic characters.</p>
<p>#rule
A construct &ldquo;#&rdquo; is defined, similar to &ldquo;*&quot;, for defining lists of
elements. The full form is &ldquo;<!-- raw HTML omitted -->#<!-- raw HTML omitted -->element &quot; indicating at least
<!-- raw HTML omitted --> and at most <!-- raw HTML omitted --> elements, each separated by one or more commas
(&quot;,&quot;) and optional linear whitespace (LWS). This makes the usual
form of lists very easy; a rule such as &ldquo;( *LWS element *( *LWS &ldquo;,&rdquo;
*LWS element )) &quot; can be shown as &ldquo;1#element&rdquo;. Wherever this
construct is used, null elements are allowed, but do not contribute</p>
<p>Fielding, et. al.           Standards Track                    [Page 14]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> to the count of elements present.  That is, &quot;(element), , (element)
 &quot; is permitted, but counts as only two elements. Therefore, where
 at least one element is required, at least one non-null element
 must be present. Default values are 0 and infinity so that
 &quot;#element&quot; allows any number, including zero; &quot;1#element&quot; requires
 at least one; and &quot;1#2element&quot; allows one or two.
</code></pre>
<p>; comment
A semi-colon, set off some distance to the right of rule text,
starts a comment that continues to the end of line. This is a
simple way of including useful notes in parallel with the
specifications.</p>
<p>implied *LWS
The grammar described by this specification is word-based. Except
where noted otherwise, linear whitespace (LWS) can be included
between any two adjacent words (token or quoted-string), and
between adjacent tokens and delimiters (tspecials), without
changing the interpretation of a field. At least one delimiter
(tspecials) must exist between any two tokens, since they would
otherwise be interpreted as a single token.</p>
<p>2.2 Basic Rules</p>
<p>The following rules are used throughout this specification to
describe basic parsing constructs. The US-ASCII coded character set
is defined by ANSI X3.4-1986 [21].</p>
<pre><code>      OCTET          = &lt;any 8-bit sequence of data&gt;
      CHAR           = &lt;any US-ASCII character (octets 0 - 127)&gt;
      UPALPHA        = &lt;any US-ASCII uppercase letter &quot;A&quot;..&quot;Z&quot;&gt;
      LOALPHA        = &lt;any US-ASCII lowercase letter &quot;a&quot;..&quot;z&quot;&gt;
      ALPHA          = UPALPHA | LOALPHA
      DIGIT          = &lt;any US-ASCII digit &quot;0&quot;..&quot;9&quot;&gt;
      CTL            = &lt;any US-ASCII control character
                       (octets 0 - 31) and DEL (127)&gt;
      CR             = &lt;US-ASCII CR, carriage return (13)&gt;
      LF             = &lt;US-ASCII LF, linefeed (10)&gt;
      SP             = &lt;US-ASCII SP, space (32)&gt;
      HT             = &lt;US-ASCII HT, horizontal-tab (9)&gt;
      &lt;&quot;&gt;            = &lt;US-ASCII double-quote mark (34)&gt;
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 15]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
protocol elements except the entity-body (see appendix 19.3 for
tolerant applications). The end-of-line marker within an entity-body
is defined by its associated media type, as described in section 3.7.</p>
<pre><code>      CRLF           = CR LF
</code></pre>
<p>HTTP/1.1 headers can be folded onto multiple lines if the
continuation line begins with a space or horizontal tab. All linear
white space, including folding, has the same semantics as SP.</p>
<pre><code>      LWS            = [CRLF] 1*( SP | HT )
</code></pre>
<p>The TEXT rule is only used for descriptive field contents and values
that are not intended to be interpreted by the message parser. Words
of *TEXT may contain characters from character sets other than ISO
8859-1 [22] only when encoded according to the rules of RFC 1522
[14].</p>
<pre><code>      TEXT           = &lt;any OCTET except CTLs,
                       but including LWS&gt;
</code></pre>
<p>Hexadecimal numeric characters are used in several protocol elements.</p>
<pre><code>      HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                     | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT
</code></pre>
<p>Many HTTP/1.1 header field values consist of words separated by LWS
or special characters. These special characters MUST be in a quoted
string to be used within a parameter value.</p>
<pre><code>      token          = 1*&lt;any CHAR except CTLs or tspecials&gt;

      tspecials      = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;
                     | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;
                     | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                     | &quot;{&quot; | &quot;}&quot; | SP | HT
</code></pre>
<p>Comments can be included in some HTTP header fields by surrounding
the comment text with parentheses. Comments are only allowed in
fields containing &ldquo;comment&rdquo; as part of their field value definition.
In all other fields, parentheses are considered part of the field
value.</p>
<pre><code>      comment        = &quot;(&quot; *( ctext | comment ) &quot;)&quot;
      ctext          = &lt;any TEXT excluding &quot;(&quot; and &quot;)&quot;&gt;
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 16]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>A string of text is parsed as a single word if it is quoted using
double-quote marks.</p>
<pre><code>      quoted-string  = ( &lt;&quot;&gt; *(qdtext) &lt;&quot;&gt; )

      qdtext         = &lt;any TEXT except &lt;&quot;&gt;&gt;
</code></pre>
<p>The backslash character (&quot;&quot;) may be used as a single-character quoting
mechanism only within quoted-string and comment constructs.</p>
<pre><code>      quoted-pair    = &quot;\&quot; CHAR
</code></pre>
<p>3 Protocol Parameters</p>
<p>3.1 HTTP Version</p>
<p>HTTP uses a &ldquo;<!-- raw HTML omitted -->.<!-- raw HTML omitted -->&rdquo; numbering scheme to indicate versions
of the protocol. The protocol versioning policy is intended to allow
the sender to indicate the format of a message and its capacity for
understanding further HTTP communication, rather than the features
obtained via that communication. No change is made to the version
number for the addition of message components which do not affect
communication behavior or which only add to extensible field values.
The <!-- raw HTML omitted --> number is incremented when the changes made to the
protocol add features which do not change the general message parsing
algorithm, but which may add to the message semantics and imply
additional capabilities of the sender. The <!-- raw HTML omitted --> number is
incremented when the format of a message within the protocol is
changed.</p>
<p>The version of an HTTP message is indicated by an HTTP-Version field
in the first line of the message.</p>
<pre><code>      HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT
</code></pre>
<p>Note that the major and minor numbers MUST be treated as separate
integers and that each may be incremented higher than a single digit.
Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
MUST NOT be sent.</p>
<p>Applications sending Request or Response messages, as defined by this
specification, MUST include an HTTP-Version of &ldquo;HTTP/1.1&rdquo;. Use of
this version number indicates that the sending application is at
least conditionally compliant with this specification.</p>
<p>The HTTP version of an application is the highest HTTP version for
which the application is at least conditionally compliant.</p>
<p>Fielding, et. al.           Standards Track                    [Page 17]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Proxy and gateway applications must be careful when forwarding
messages in protocol versions different from that of the application.
Since the protocol version indicates the protocol capability of the
sender, a proxy/gateway MUST never send a message with a version
indicator which is greater than its actual version; if a higher
version request is received, the proxy/gateway MUST either downgrade
the request version, respond with an error, or switch to tunnel
behavior. Requests with a version lower than that of the
proxy/gateway&rsquo;s version MAY be upgraded before being forwarded; the
proxy/gateway&rsquo;s response to that request MUST be in the same major
version as the request.</p>
<pre><code> Note: Converting between versions of HTTP may involve modification
 of header fields required or forbidden by the versions involved.
</code></pre>
<p>3.2 Uniform Resource Identifiers</p>
<p>URIs have been known by many names: WWW addresses, Universal Document
Identifiers, Universal Resource Identifiers , and finally the
combination of Uniform Resource Locators (URL)  and Names (URN). As
far as HTTP is concerned, Uniform Resource Identifiers are simply
formatted strings which identify&ndash;via name, location, or any other
characteristic&ndash;a resource.</p>
<p>3.2.1 General Syntax</p>
<p>URIs in HTTP can be represented in absolute form or relative to some
known base URI, depending upon the context of their use. The two
forms are differentiated by the fact that absolute URIs always begin
with a scheme name followed by a colon.</p>
<pre><code>      URI            = ( absoluteURI | relativeURI ) [ &quot;#&quot; fragment ]

      absoluteURI    = scheme &quot;:&quot; *( uchar | reserved )

      relativeURI    = net_path | abs_path | rel_path

      net_path       = &quot;//&quot; net_loc [ abs_path ]
      abs_path       = &quot;/&quot; rel_path
      rel_path       = [ path ] [ &quot;;&quot; params ] [ &quot;?&quot; query ]

      path           = fsegment *( &quot;/&quot; segment )
      fsegment       = 1*pchar
      segment        = *pchar

      params         = param *( &quot;;&quot; param )
      param          = *( pchar | &quot;/&quot; )
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 18]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>      scheme         = 1*( ALPHA | DIGIT | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )
      net_loc        = *( pchar | &quot;;&quot; | &quot;?&quot; )

      query          = *( uchar | reserved )
      fragment       = *( uchar | reserved )

      pchar          = uchar | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot;
      uchar          = unreserved | escape
      unreserved     = ALPHA | DIGIT | safe | extra | national

      escape         = &quot;%&quot; HEX HEX
      reserved       = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot;
      extra          = &quot;!&quot; | &quot;*&quot; | &quot;'&quot; | &quot;(&quot; | &quot;)&quot; | &quot;,&quot;
      safe           = &quot;$&quot; | &quot;-&quot; | &quot;_&quot; | &quot;.&quot;
      unsafe         = CTL | SP | &lt;&quot;&gt; | &quot;#&quot; | &quot;%&quot; | &quot;&lt;&quot; | &quot;&gt;&quot;
      national       = &lt;any OCTET excluding ALPHA, DIGIT,
                       reserved, extra, safe, and unsafe&gt;
</code></pre>
<p>For definitive information on URL syntax and semantics, see RFC 1738
[4] and RFC 1808 [11]. The BNF above includes national characters not
allowed in valid URLs as specified by RFC 1738, since HTTP servers
are not restricted in the set of unreserved characters allowed to
represent the rel_path part of addresses, and HTTP proxies may
receive requests for URIs not defined by RFC 1738.</p>
<p>The HTTP protocol does not place any a priori limit on the length of
a URI. Servers MUST be able to handle the URI of any resource they
serve, and SHOULD be able to handle URIs of unbounded length if they
provide GET-based forms that could generate such URIs. A server
SHOULD return 414 (Request-URI Too Long) status if a URI is longer
than the server can handle (see section 10.4.15).</p>
<pre><code> Note: Servers should be cautious about depending on URI lengths
 above 255 bytes, because some older client or proxy implementations
 may not properly support these lengths.
</code></pre>
<p>3.2.2 http URL</p>
<p>The &ldquo;http&rdquo; scheme is used to locate network resources via the HTTP
protocol. This section defines the scheme-specific syntax and
semantics for http URLs.</p>
<p>Fielding, et. al.           Standards Track                    [Page 19]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>      http_URL       = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path ]

      host           = &lt;A legal Internet host domain name
                        or IP address (in dotted-decimal form),
                        as defined by Section 2.1 of RFC 1123&gt;

      port           = *DIGIT
</code></pre>
<p>If the port is empty or not given, port 80 is assumed. The semantics
are that the identified resource is located at the server listening
for TCP connections on that port of that host, and the Request-URI
for the resource is abs_path. The use of IP addresses in URL&rsquo;s SHOULD
be avoided whenever possible (see RFC 1900 [24]). If the abs_path is
not present in the URL, it MUST be given as &ldquo;/&rdquo; when used as a
Request-URI for a resource (section 5.1.2).</p>
<p>3.2.3 URI Comparison</p>
<p>When comparing two URIs to decide if they match or not, a client
SHOULD use a case-sensitive octet-by-octet comparison of the entire
URIs, with these exceptions:</p>
<pre><code> o  A port that is empty or not given is equivalent to the default
    port for that URI;

 o  Comparisons of host names MUST be case-insensitive;

 o  Comparisons of scheme names MUST be case-insensitive;

 o  An empty abs_path is equivalent to an abs_path of &quot;/&quot;.
</code></pre>
<p>Characters other than those in the &ldquo;reserved&rdquo; and &ldquo;unsafe&rdquo; sets (see
section 3.2) are equivalent to their &ldquo;&quot;%&rdquo; HEX HEX&rdquo; encodings.</p>
<p>For example, the following three URIs are equivalent:</p>
<pre><code>     http://abc.com:80/~smith/home.html
     http://ABC.com/%7Esmith/home.html
     http://ABC.com:/%7esmith/home.html
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 20]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>3.3 Date/Time Formats</p>
<p>3.3.1 Full Date</p>
<p>HTTP applications have historically allowed three different formats
for the representation of date/time stamps:</p>
<pre><code>      Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
      Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
</code></pre>
<p>The first format is preferred as an Internet standard and represents
a fixed-length subset of that defined by RFC 1123  (an update to RFC
822).  The second format is in common use, but is based on the
obsolete RFC 850 [12] date format and lacks a four-digit year.
HTTP/1.1 clients and servers that parse the date value MUST accept
all three formats (for compatibility with HTTP/1.0), though they MUST
only generate the RFC 1123 format for representing HTTP-date values
in header fields.</p>
<pre><code> Note: Recipients of date values are encouraged to be robust in
 accepting date values that may have been sent by non-HTTP
 applications, as is sometimes the case when retrieving or posting
 messages via proxies/gateways to SMTP or NNTP.
</code></pre>
<p>All HTTP date/time stamps MUST be represented in Greenwich Mean Time
(GMT), without exception. This is indicated in the first two formats
by the inclusion of &ldquo;GMT&rdquo; as the three-letter abbreviation for time
zone, and MUST be assumed when reading the asctime format.</p>
<pre><code>      HTTP-date    = rfc1123-date | rfc850-date | asctime-date

      rfc1123-date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot;
      rfc850-date  = weekday &quot;,&quot; SP date2 SP time SP &quot;GMT&quot;
      asctime-date = wkday SP date3 SP time SP 4DIGIT

      date1        = 2DIGIT SP month SP 4DIGIT
                     ; day month year (e.g., 02 Jun 1982)
      date2        = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT
                     ; day-month-year (e.g., 02-Jun-82)
      date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                     ; month day (e.g., Jun  2)

      time         = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT
                     ; 00:00:00 - 23:59:59

      wkday        = &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot;
                   | &quot;Thu&quot; | &quot;Fri&quot; | &quot;Sat&quot; | &quot;Sun&quot;
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 21]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>      weekday      = &quot;Monday&quot; | &quot;Tuesday&quot; | &quot;Wednesday&quot;
                   | &quot;Thursday&quot; | &quot;Friday&quot; | &quot;Saturday&quot; | &quot;Sunday&quot;

      month        = &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot;
                   | &quot;May&quot; | &quot;Jun&quot; | &quot;Jul&quot; | &quot;Aug&quot;
                   | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;

 Note: HTTP requirements for the date/time stamp format apply only
 to their usage within the protocol stream. Clients and servers are
 not required to use these formats for user presentation, request
 logging, etc.
</code></pre>
<p>3.3.2 Delta Seconds</p>
<p>Some HTTP header fields allow a time value to be specified as an
integer number of seconds, represented in decimal, after the time
that the message was received.</p>
<pre><code>      delta-seconds  = 1*DIGIT
</code></pre>
<p>3.4 Character Sets</p>
<p>HTTP uses the same definition of the term &ldquo;character set&rdquo; as that
described for MIME:</p>
<pre><code> The term &quot;character set&quot; is used in this document to refer to a
 method used with one or more tables to convert a sequence of octets
 into a sequence of characters. Note that unconditional conversion
 in the other direction is not required, in that not all characters
 may be available in a given character set and a character set may
 provide more than one sequence of octets to represent a particular
 character. This definition is intended to allow various kinds of
 character encodings, from simple single-table mappings such as US-
 ASCII to complex table switching methods such as those that use ISO
 2022's techniques. However, the definition associated with a MIME
 character set name MUST fully specify the mapping to be performed
 from octets to characters. In particular, use of external profiling
 information to determine the exact mapping is not permitted.

 Note: This use of the term &quot;character set&quot; is more commonly
 referred to as a &quot;character encoding.&quot; However, since HTTP and MIME
 share the same registry, it is important that the terminology also
 be shared.
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 22]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>HTTP character sets are identified by case-insensitive tokens. The
complete set of tokens is defined by the IANA Character Set registry
[19].</p>
<pre><code>      charset = token
</code></pre>
<p>Although HTTP allows an arbitrary token to be used as a charset
value, any token that has a predefined value within the IANA
Character Set registry MUST represent the character set defined by
that registry.  Applications SHOULD limit their use of character sets
to those defined by the IANA registry.</p>
<p>3.5 Content Codings</p>
<p>Content coding values indicate an encoding transformation that has
been or can be applied to an entity. Content codings are primarily
used to allow a document to be compressed or otherwise usefully
transformed without losing the identity of its underlying media type
and without loss of information. Frequently, the entity is stored in
coded form, transmitted directly, and only decoded by the recipient.</p>
<pre><code>      content-coding   = token
</code></pre>
<p>All content-coding values are case-insensitive. HTTP/1.1 uses
content-coding values in the Accept-Encoding (section 14.3) and
Content-Encoding (section 14.12) header fields. Although the value
describes the content-coding, what is more important is that it
indicates what decoding mechanism will be required to remove the
encoding.</p>
<p>The Internet Assigned Numbers Authority (IANA) acts as a registry for
content-coding value tokens. Initially, the registry contains the
following tokens:</p>
<p>gzip An encoding format produced by the file compression program &ldquo;gzip&rdquo;
(GNU zip) as described in RFC 1952 [25]. This format is a Lempel-
Ziv coding (LZ77) with a 32 bit CRC.</p>
<p>compress
The encoding format produced by the common UNIX file compression
program &ldquo;compress&rdquo;. This format is an adaptive Lempel-Ziv-Welch
coding (LZW).</p>
<p>Fielding, et. al.           Standards Track                    [Page 23]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> Note: Use of program names for the identification of encoding
 formats is not desirable and should be discouraged for future
 encodings. Their use here is representative of historical practice,
 not good design. For compatibility with previous implementations of
 HTTP, applications should consider &quot;x-gzip&quot; and &quot;x-compress&quot; to be
 equivalent to &quot;gzip&quot; and &quot;compress&quot; respectively.
</code></pre>
<p>deflate The &ldquo;zlib&rdquo; format defined in RFC 1950[31] in combination with
the &ldquo;deflate&rdquo; compression mechanism described in RFC 1951[29].</p>
<p>New content-coding value tokens should be registered; to allow
interoperability between clients and servers, specifications of the
content coding algorithms needed to implement a new value should be
publicly available and adequate for independent implementation, and
conform to the purpose of content coding defined in this section.</p>
<p>3.6 Transfer Codings</p>
<p>Transfer coding values are used to indicate an encoding
transformation that has been, can be, or may need to be applied to an
entity-body in order to ensure &ldquo;safe transport&rdquo; through the network.
This differs from a content coding in that the transfer coding is a
property of the message, not of the original entity.</p>
<pre><code>      transfer-coding         = &quot;chunked&quot; | transfer-extension

      transfer-extension      = token
</code></pre>
<p>All transfer-coding values are case-insensitive. HTTP/1.1 uses
transfer coding values in the Transfer-Encoding header field (section
14.40).</p>
<p>Transfer codings are analogous to the Content-Transfer-Encoding
values of MIME , which were designed to enable safe transport of
binary data over a 7-bit transport service. However, safe transport
has a different focus for an 8bit-clean transfer protocol. In HTTP,
the only unsafe characteristic of message-bodies is the difficulty in
determining the exact body length (section 7.2.2), or the desire to
encrypt data over a shared transport.</p>
<p>The chunked encoding modifies the body of a message in order to
transfer it as a series of chunks, each with its own size indicator,
followed by an optional footer containing entity-header fields. This
allows dynamically-produced content to be transferred along with the
information necessary for the recipient to verify that it has
received the full message.</p>
<p>Fielding, et. al.           Standards Track                    [Page 24]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>   Chunked-Body   = *chunk
                    &quot;0&quot; CRLF
                    footer
                    CRLF

   chunk          = chunk-size [ chunk-ext ] CRLF
                    chunk-data CRLF

   hex-no-zero    = &lt;HEX excluding &quot;0&quot;&gt;

   chunk-size     = hex-no-zero *HEX
   chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-value ] )
   chunk-ext-name = token
   chunk-ext-val  = token | quoted-string
   chunk-data     = chunk-size(OCTET)

   footer         = *entity-header
</code></pre>
<p>The chunked encoding is ended by a zero-sized chunk followed by the
footer, which is terminated by an empty line. The purpose of the
footer is to provide an efficient way to supply information about an
entity that is generated dynamically; applications MUST NOT send
header fields in the footer which are not explicitly defined as being
appropriate for the footer, such as Content-MD5 or future extensions
to HTTP for digital signatures or other facilities.</p>
<p>An example process for decoding a Chunked-Body is presented in
appendix 19.4.6.</p>
<p>All HTTP/1.1 applications MUST be able to receive and decode the
&ldquo;chunked&rdquo; transfer coding, and MUST ignore transfer coding extensions
they do not understand. A server which receives an entity-body with a
transfer-coding it does not understand SHOULD return 501
(Unimplemented), and close the connection. A server MUST NOT send
transfer-codings to an HTTP/1.0 client.</p>
<p>3.7 Media Types</p>
<p>HTTP uses Internet Media Types  in the Content-Type (section 14.18)
and Accept (section 14.1) header fields in order to provide open and
extensible data typing and type negotiation.</p>
<pre><code>      media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
      type           = token
      subtype        = token
</code></pre>
<p>Parameters may follow the type/subtype in the form of attribute/value
pairs.</p>
<p>Fielding, et. al.           Standards Track                    [Page 25]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>      parameter      = attribute &quot;=&quot; value
      attribute      = token
      value          = token | quoted-string
</code></pre>
<p>The type, subtype, and parameter attribute names are case-
insensitive.  Parameter values may or may not be case-sensitive,
depending on the semantics of the parameter name. Linear white space
(LWS) MUST NOT be used between the type and subtype, nor between an
attribute and its value. User agents that recognize the media-type
MUST process (or arrange to be processed by any external applications
used to process that type/subtype by the user agent) the parameters
for that MIME type as described by that type/subtype definition to
the and inform the user of any problems discovered.</p>
<pre><code> Note: some older HTTP applications do not recognize media type
 parameters. When sending data to older HTTP applications,
 implementations should only use media type parameters when they are
 required by that type/subtype definition.
</code></pre>
<p>Media-type values are registered with the Internet Assigned Number
Authority (IANA). The media type registration process is outlined in
RFC 2048 [17]. Use of non-registered media types is discouraged.</p>
<p>3.7.1 Canonicalization and Text Defaults</p>
<p>Internet media types are registered with a canonical form. In
general, an entity-body transferred via HTTP messages MUST be
represented in the appropriate canonical form prior to its
transmission; the exception is &ldquo;text&rdquo; types, as defined in the next
paragraph.</p>
<p>When in canonical form, media subtypes of the &ldquo;text&rdquo; type use CRLF as
the text line break. HTTP relaxes this requirement and allows the
transport of text media with plain CR or LF alone representing a line
break when it is done consistently for an entire entity-body. HTTP
applications MUST accept CRLF, bare CR, and bare LF as being
representative of a line break in text media received via HTTP. In
addition, if the text is represented in a character set that does not
use octets 13 and 10 for CR and LF respectively, as is the case for
some multi-byte character sets, HTTP allows the use of whatever octet
sequences are defined by that character set to represent the
equivalent of CR and LF for line breaks. This flexibility regarding
line breaks applies only to text media in the entity-body; a bare CR
or LF MUST NOT be substituted for CRLF within any of the HTTP control
structures (such as header fields and multipart boundaries).</p>
<p>If an entity-body is encoded with a Content-Encoding, the underlying
data MUST be in a form defined above prior to being encoded.</p>
<p>Fielding, et. al.           Standards Track                    [Page 26]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The &ldquo;charset&rdquo; parameter is used with some media types to define the
character set (section 3.4) of the data. When no explicit charset
parameter is provided by the sender, media subtypes of the &ldquo;text&rdquo;
type are defined to have a default charset value of &ldquo;ISO-8859-1&rdquo; when
received via HTTP. Data in character sets other than &ldquo;ISO-8859-1&rdquo; or
its subsets MUST be labeled with an appropriate charset value.</p>
<p>Some HTTP/1.0 software has interpreted a Content-Type header without
charset parameter incorrectly to mean &ldquo;recipient should guess.&rdquo;
Senders wishing to defeat this behavior MAY include a charset
parameter even when the charset is ISO-8859-1 and SHOULD do so when
it is known that it will not confuse the recipient.</p>
<p>Unfortunately, some older HTTP/1.0 clients did not deal properly with
an explicit charset parameter. HTTP/1.1 recipients MUST respect the
charset label provided by the sender; and those user agents that have
a provision to &ldquo;guess&rdquo; a charset MUST use the charset from the
content-type field if they support that charset, rather than the
recipient&rsquo;s preference, when initially displaying a document.</p>
<p>3.7.2 Multipart Types</p>
<p>MIME provides for a number of &ldquo;multipart&rdquo; types &ndash; encapsulations of
one or more entities within a single message-body. All multipart
types share a common syntax, as defined in  MIME [7], and MUST
include a boundary parameter as part of the media type value. The
message body is itself a protocol element and MUST therefore use only
CRLF to represent line breaks between body-parts. Unlike in MIME, the
epilogue of any multipart message MUST be empty; HTTP applications
MUST NOT transmit the epilogue (even if the original multipart
contains an epilogue).</p>
<p>In HTTP, multipart body-parts MAY contain header fields which are
significant to the meaning of that part. A Content-Location header
field (section 14.15) SHOULD be included in the body-part of each
enclosed entity that can be identified by a URL.</p>
<p>In general, an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type.
If an application receives an unrecognized multipart subtype, the
application MUST treat it as being equivalent to &ldquo;multipart/mixed&rdquo;.</p>
<pre><code> Note: The &quot;multipart/form-data&quot; type has been specifically defined
 for carrying form data suitable for processing via the POST request
 method, as described in RFC 1867 [15].
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 27]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>3.8 Product Tokens</p>
<p>Product tokens are used to allow communicating applications to
identify themselves by software name and version. Most fields using
product tokens also allow sub-products which form a significant part
of the application to be listed, separated by whitespace. By
convention, the products are listed in order of their significance
for identifying the application.</p>
<pre><code>      product         = token [&quot;/&quot; product-version]
      product-version = token
</code></pre>
<p>Examples:</p>
<pre><code>      User-Agent: CERN-LineMode/2.15 libwww/2.17b3
      Server: Apache/0.8.4
</code></pre>
<p>Product tokens should be short and to the point &ndash; use of them for
advertising or other non-essential information is explicitly
forbidden.  Although any token character may appear in a product-
version, this token SHOULD only be used for a version identifier
(i.e., successive versions of the same product SHOULD only differ in
the product-version portion of the product value).</p>
<p>3.9 Quality Values</p>
<p>HTTP content negotiation (section 12) uses short &ldquo;floating point&rdquo;
numbers to indicate the relative importance (&ldquo;weight&rdquo;) of various
negotiable parameters. A weight is normalized to a real number in the
range 0 through 1, where 0 is the minimum and 1 the maximum value.
HTTP/1.1 applications MUST NOT generate more than three digits after
the decimal point. User configuration of these values SHOULD also be
limited in this fashion.</p>
<pre><code>      qvalue         = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                     | ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )
</code></pre>
<p>&ldquo;Quality values&rdquo; is a misnomer, since these values merely represent
relative degradation in desired quality.</p>
<p>3.10 Language Tags</p>
<p>A language tag identifies a natural language spoken, written, or
otherwise conveyed by human beings for communication of information
to other human beings. Computer languages are explicitly excluded.
HTTP uses language tags within the Accept-Language and Content-
Language fields.</p>
<p>Fielding, et. al.           Standards Track                    [Page 28]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The syntax and registry of HTTP language tags is the same as that
defined by RFC 1766 [1]. In summary, a language tag is composed of 1
or more parts: A primary language tag and a possibly empty series of
subtags:</p>
<pre><code>       language-tag  = primary-tag *( &quot;-&quot; subtag )

       primary-tag   = 1*8ALPHA
       subtag        = 1*8ALPHA
</code></pre>
<p>Whitespace is not allowed within the tag and all tags are case-
insensitive. The name space of language tags is administered by the
IANA. Example tags include:</p>
<pre><code>      en, en-US, en-cockney, i-cherokee, x-pig-latin
</code></pre>
<p>where any two-letter primary-tag is an ISO 639 language abbreviation
and any two-letter initial subtag is an ISO 3166 country code. (The
last three tags above are not registered tags; all but the last are
examples of tags which could be registered in future.)</p>
<p>3.11 Entity Tags</p>
<p>Entity tags are used for comparing two or more entities from the same
requested resource. HTTP/1.1 uses entity tags in the ETag (section
14.20), If-Match (section 14.25), If-None-Match (section 14.26), and
If-Range (section 14.27) header fields. The definition of how they
are used and compared as cache validators is in section 13.3.3. An
entity tag consists of an opaque quoted string, possibly prefixed by
a weakness indicator.</p>
<pre><code>     entity-tag = [ weak ] opaque-tag

     weak       = &quot;W/&quot;
     opaque-tag = quoted-string
</code></pre>
<p>A &ldquo;strong entity tag&rdquo; may be shared by two entities of a resource
only if they are equivalent by octet equality.</p>
<p>A &ldquo;weak entity tag,&rdquo; indicated by the &ldquo;W/&rdquo; prefix, may be shared by
two entities of a resource only if the entities are equivalent and
could be substituted for each other with no significant change in
semantics. A weak entity tag can only be used for weak comparison.</p>
<p>An entity tag MUST be unique across all versions of all entities
associated with a particular resource. A given entity tag value may
be used for entities obtained by requests on different URIs without
implying anything about the equivalence of those entities.</p>
<p>Fielding, et. al.           Standards Track                    [Page 29]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>3.12 Range Units</p>
<p>HTTP/1.1 allows a client to request that only part (a range of) the
response entity be included within the response. HTTP/1.1 uses range
units in the Range (section 14.36) and Content-Range (section 14.17)
header fields. An entity may be broken down into subranges according
to various structural units.</p>
<pre><code>     range-unit       = bytes-unit | other-range-unit

     bytes-unit       = &quot;bytes&quot;
     other-range-unit = token
</code></pre>
<p>The only range unit defined by HTTP/1.1 is &ldquo;bytes&rdquo;. HTTP/1.1
implementations may ignore ranges specified using other units.
HTTP/1.1 has been designed to allow implementations of applications
that do not depend on knowledge of ranges.</p>
<p>4 HTTP Message</p>
<p>4.1 Message Types</p>
<p>HTTP messages consist of requests from client to server and responses
from server to client.</p>
<pre><code>      HTTP-message   = Request | Response     ; HTTP/1.1 messages
</code></pre>
<p>Request (section 5) and Response (section 6) messages use the generic
message format of RFC 822 [9] for transferring entities (the payload
of the message). Both types of message consist of a start-line, one
or more header fields (also known as &ldquo;headers&rdquo;), an empty line (i.e.,
a line with nothing preceding the CRLF) indicating the end of the
header fields, and an optional message-body.</p>
<pre><code>       generic-message = start-line
                         *message-header
                         CRLF
                         [ message-body ]

       start-line      = Request-Line | Status-Line
</code></pre>
<p>In the interest of robustness, servers SHOULD ignore any empty
line(s) received where a Request-Line is expected. In other words, if
the server is reading the protocol stream at the beginning of a
message and receives a CRLF first, it should ignore the CRLF.</p>
<p>Fielding, et. al.           Standards Track                    [Page 30]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> Note: certain buggy HTTP/1.0 client implementations generate an
 extra CRLF's after a POST request. To restate what is explicitly
 forbidden by the BNF, an HTTP/1.1 client must not preface or follow
 a request with an extra CRLF.
</code></pre>
<p>4.2 Message Headers</p>
<p>HTTP header fields, which include general-header (section 4.5),
request-header (section 5.3), response-header (section 6.2), and
entity-header (section 7.1) fields, follow the same generic format as
that given in Section 3.1 of RFC 822 [9]. Each header field consists
of a name followed by a colon (&quot;:&quot;) and the field value. Field names
are case-insensitive. The field value may be preceded by any amount
of LWS, though a single SP is preferred. Header fields can be
extended over multiple lines by preceding each extra line with at
least one SP or HT.  Applications SHOULD follow &ldquo;common form&rdquo; when
generating HTTP constructs, since there might exist some
implementations that fail to accept anything beyond the common forms.</p>
<pre><code>      message-header = field-name &quot;:&quot; [ field-value ] CRLF

      field-name     = token
      field-value    = *( field-content | LWS )

      field-content  = &lt;the OCTETs making up the field-value
                       and consisting of either *TEXT or combinations
                       of token, tspecials, and quoted-string&gt;
</code></pre>
<p>The order in which header fields with differing field names are
received is not significant. However, it is &ldquo;good practice&rdquo; to send
general-header fields first, followed by request-header or response-
header fields, and ending with the entity-header fields.</p>
<p>Multiple message-header fields with the same field-name may be
present in a message if and only if the entire field-value for that
header field is defined as a comma-separated list [i.e., #(values)].
It MUST be possible to combine the multiple header fields into one
&ldquo;field-name: field-value&rdquo; pair, without changing the semantics of the
message, by appending each subsequent field-value to the first, each
separated by a comma. The order in which header fields with the same
field-name are received is therefore significant to the
interpretation of the combined field value, and thus a proxy MUST NOT
change the order of these field values when a message is forwarded.</p>
<p>Fielding, et. al.           Standards Track                    [Page 31]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>4.3 Message Body</p>
<p>The message-body (if any) of an HTTP message is used to carry the
entity-body associated with the request or response. The message-body
differs from the entity-body only when a transfer coding has been
applied, as indicated by the Transfer-Encoding header field (section
14.40).</p>
<pre><code>      message-body = entity-body
                   | &lt;entity-body encoded as per Transfer-Encoding&gt;
</code></pre>
<p>Transfer-Encoding MUST be used to indicate any transfer codings
applied by an application to ensure safe and proper transfer of the
message.  Transfer-Encoding is a property of the message, not of the
entity, and thus can be added or removed by any application along the
request/response chain.</p>
<p>The rules for when a message-body is allowed in a message differ for
requests and responses.</p>
<p>The presence of a message-body in a request is signaled by the
inclusion of a Content-Length or Transfer-Encoding header field in
the request&rsquo;s message-headers. A message-body MAY be included in a
request only when the request method (section 5.1.1) allows an
entity-body.</p>
<p>For response messages, whether or not a message-body is included with
a message is dependent on both the request method and the response
status code (section 6.1.1). All responses to the HEAD request method
MUST NOT include a message-body, even though the presence of entity-
header fields might lead one to believe they do. All 1xx
(informational), 204 (no content), and 304 (not modified) responses
MUST NOT include a message-body. All other responses do include a
message-body, although it may be of zero length.</p>
<p>4.4 Message Length</p>
<p>When a message-body is included with a message, the length of that
body is determined by one of the following (in order of precedence):</p>
<ol>
<li>
<p>Any response message which MUST NOT include a message-body
(such as the 1xx, 204, and 304 responses and any response to a HEAD
request) is always terminated by the first empty line after the
header fields, regardless of the entity-header fields present in the
message.</p>
</li>
<li>
<p>If a Transfer-Encoding header field (section 14.40) is present and
indicates that the &ldquo;chunked&rdquo; transfer coding has been applied, then</p>
</li>
</ol>
<p>Fielding, et. al.           Standards Track                    [Page 32]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> the length is defined by the chunked encoding (section 3.6).
</code></pre>
<ol start="3">
<li>
<p>If a Content-Length header field (section 14.14) is present, its
value in bytes represents the length of the message-body.</p>
</li>
<li>
<p>If the message uses the media type &ldquo;multipart/byteranges&rdquo;, which is
self-delimiting, then that defines the length. This media type MUST
NOT be used unless the sender knows that the recipient can parse it;
the presence in a request of a Range header with multiple byte-range
specifiers implies that the client can parse multipart/byteranges
responses.</p>
</li>
<li>
<p>By the server closing the connection. (Closing the connection
cannot be used to indicate the end of a request body, since that
would leave no possibility for the server to send back a response.)</p>
</li>
</ol>
<p>For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
containing a message-body MUST include a valid Content-Length header
field unless the server is known to be HTTP/1.1 compliant. If a
request contains a message-body and a Content-Length is not given,
the server SHOULD respond with 400 (bad request) if it cannot
determine the length of the message, or with 411 (length required) if
it wishes to insist on receiving a valid Content-Length.</p>
<p>All HTTP/1.1 applications that receive entities MUST accept the
&ldquo;chunked&rdquo; transfer coding (section 3.6), thus allowing this mechanism
to be used for messages when the message length cannot be determined
in advance.</p>
<p>Messages MUST NOT include both a Content-Length header field and the
&ldquo;chunked&rdquo; transfer coding. If both are received, the Content-Length
MUST be ignored.</p>
<p>When a Content-Length is given in a message where a message-body is
allowed, its field value MUST exactly match the number of OCTETs in
the message-body. HTTP/1.1 user agents MUST notify the user when an
invalid length is received and detected.</p>
<p>Fielding, et. al.           Standards Track                    [Page 33]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>4.5 General Header Fields</p>
<p>There are a few header fields which have general applicability for
both request and response messages, but which do not apply to the
entity being transferred. These header fields apply only to the
message being transmitted.</p>
<pre><code>      general-header = Cache-Control            ; Section 14.9
                     | Connection               ; Section 14.10
                     | Date                     ; Section 14.19
                     | Pragma                   ; Section 14.32
                     | Transfer-Encoding        ; Section 14.40
                     | Upgrade                  ; Section 14.41
                     | Via                      ; Section 14.44
</code></pre>
<p>General-header field names can be extended reliably only in
combination with a change in the protocol version. However, new or
experimental header fields may be given the semantics of general
header fields if all parties in the communication recognize them to
be general-header fields.  Unrecognized header fields are treated as
entity-header fields.</p>
<p>5 Request</p>
<p>A request message from a client to a server includes, within the
first line of that message, the method to be applied to the resource,
the identifier of the resource, and the protocol version in use.</p>
<pre><code>       Request       = Request-Line              ; Section 5.1
                       *( general-header         ; Section 4.5
                        | request-header         ; Section 5.3
                        | entity-header )        ; Section 7.1
                       CRLF
                       [ message-body ]          ; Section 7.2
</code></pre>
<p>5.1 Request-Line</p>
<p>The Request-Line begins with a method token, followed by the
Request-URI and the protocol version, and ending with CRLF. The
elements are separated by SP characters. No CR or LF are allowed
except in the final CRLF sequence.</p>
<pre><code>      Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 34]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>5.1.1 Method</p>
<p>The Method token indicates the method to be performed on the resource
identified by the Request-URI. The method is case-sensitive.</p>
<pre><code>      Method         = &quot;OPTIONS&quot;                ; Section 9.2
                     | &quot;GET&quot;                    ; Section 9.3
                     | &quot;HEAD&quot;                   ; Section 9.4
                     | &quot;POST&quot;                   ; Section 9.5
                     | &quot;PUT&quot;                    ; Section 9.6
                     | &quot;DELETE&quot;                 ; Section 9.7
                     | &quot;TRACE&quot;                  ; Section 9.8
                     | extension-method

      extension-method = token
</code></pre>
<p>The list of methods allowed by a resource can be specified in an
Allow header field (section 14.7). The return code of the response
always notifies the client whether a method is currently allowed on a
resource, since the set of allowed methods can change dynamically.
Servers SHOULD return the status code 405 (Method Not Allowed) if the
method is known by the server but not allowed for the requested
resource, and 501 (Not Implemented) if the method is unrecognized or
not implemented by the server. The list of methods known by a server
can be listed in a Public response-header field (section 14.35).</p>
<p>The methods GET and HEAD MUST be supported by all general-purpose
servers. All other methods are optional; however, if the above
methods are implemented, they MUST be implemented with the same
semantics as those specified in section 9.</p>
<p>5.1.2 Request-URI</p>
<p>The Request-URI is a Uniform Resource Identifier (section 3.2) and
identifies the resource upon which to apply the request.</p>
<pre><code>      Request-URI    = &quot;*&quot; | absoluteURI | abs_path
</code></pre>
<p>The three options for Request-URI are dependent on the nature of the
request. The asterisk &ldquo;*&rdquo; means that the request does not apply to a
particular resource, but to the server itself, and is only allowed
when the method used does not necessarily apply to a resource. One
example would be</p>
<pre><code>      OPTIONS * HTTP/1.1
</code></pre>
<p>The absoluteURI form is required when the request is being made to a
proxy. The proxy is requested to forward the request or service it</p>
<p>Fielding, et. al.           Standards Track                    [Page 35]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>from a valid cache, and return the response. Note that the proxy MAY
forward the request on to another proxy or directly to the server
specified by the absoluteURI. In order to avoid request loops, a
proxy MUST be able to recognize all of its server names, including
any aliases, local variations, and the numeric IP address. An example
Request-Line would be:</p>
<pre><code>      GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
</code></pre>
<p>To allow for transition to absoluteURIs in all requests in future
versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
form in requests, even though HTTP/1.1 clients will only generate
them in requests to proxies.</p>
<p>The most common form of Request-URI is that used to identify a
resource on an origin server or gateway. In this case the absolute
path of the URI MUST be transmitted (see section 3.2.1, abs_path) as
the Request-URI, and the network location of the URI (net_loc) MUST
be transmitted in a Host header field. For example, a client wishing
to retrieve the resource above directly from the origin server would
create a TCP connection to port 80 of the host &ldquo;<a href="http://www.w3.org">www.w3.org</a>&rdquo; and send
the lines:</p>
<pre><code>      GET /pub/WWW/TheProject.html HTTP/1.1
      Host: www.w3.org
</code></pre>
<p>followed by the remainder of the Request. Note that the absolute path
cannot be empty; if none is present in the original URI, it MUST be
given as &ldquo;/&rdquo; (the server root).</p>
<p>If a proxy receives a request without any path in the Request-URI and
the method specified is capable of supporting the asterisk form of
request, then the last proxy on the request chain MUST forward the
request with &ldquo;*&rdquo; as the final Request-URI. For example, the request</p>
<pre><code>      OPTIONS http://www.ics.uci.edu:8001 HTTP/1.1
</code></pre>
<p>would be forwarded by the proxy as</p>
<pre><code>      OPTIONS * HTTP/1.1
      Host: www.ics.uci.edu:8001
</code></pre>
<p>after connecting to port 8001 of host &ldquo;<a href="http://www.ics.uci.edu">www.ics.uci.edu</a>&rdquo;.</p>
<p>The Request-URI is transmitted in the format specified in section
3.2.1.  The origin server MUST decode the Request-URI in order to
properly interpret the request. Servers SHOULD respond to invalid
Request-URIs with an appropriate status code.</p>
<p>Fielding, et. al.           Standards Track                    [Page 36]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>In requests that they forward, proxies MUST NOT rewrite the
&ldquo;abs_path&rdquo; part of a Request-URI in any way except as noted above to
replace a null abs_path with &ldquo;*&quot;, no matter what the proxy does in
its internal implementation.</p>
<pre><code> Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
 meaning of the request when the origin server is improperly using a
 non-reserved URL character for a reserved purpose. Implementers
 should be aware that some pre-HTTP/1.1 proxies have been known to
 rewrite the Request-URI.
</code></pre>
<p>5.2 The Resource Identified by a Request</p>
<p>HTTP/1.1 origin servers SHOULD be aware that the exact resource
identified by an Internet request is determined by examining both the
Request-URI and the Host header field.</p>
<p>An origin server that does not allow resources to differ by the
requested host MAY ignore the Host header field value. (But see
section 19.5.1 for other requirements on Host support in HTTP/1.1.)</p>
<p>An origin server that does differentiate resources based on the host
requested (sometimes referred to as virtual hosts or vanity
hostnames) MUST use the following rules for determining the requested
resource on an HTTP/1.1 request:</p>
<pre><code> 1. If Request-URI is an absoluteURI, the host is part of the
    Request-URI. Any Host header field value in the request MUST be
    ignored.

 2. If the Request-URI is not an absoluteURI, and the request
    includes a Host header field, the host is determined by the Host
    header field value.

 3. If the host as determined by rule 1 or 2 is not a valid host on
    the server, the response MUST be a 400 (Bad Request) error
    message.
</code></pre>
<p>Recipients of an HTTP/1.0 request that lacks a Host header field MAY
attempt to use heuristics (e.g., examination of the URI path for
something unique to a particular host) in order to determine what
exact resource is being requested.</p>
<p>5.3 Request Header Fields</p>
<p>The request-header fields allow the client to pass additional
information about the request, and about the client itself, to the
server. These fields act as request modifiers, with semantics</p>
<p>Fielding, et. al.           Standards Track                    [Page 37]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>equivalent to the parameters on a programming language method
invocation.</p>
<pre><code>      request-header = Accept                   ; Section 14.1
                     | Accept-Charset           ; Section 14.2
                     | Accept-Encoding          ; Section 14.3
                     | Accept-Language          ; Section 14.4
                     | Authorization            ; Section 14.8
                     | From                     ; Section 14.22
                     | Host                     ; Section 14.23
                     | If-Modified-Since        ; Section 14.24
                     | If-Match                 ; Section 14.25
                     | If-None-Match            ; Section 14.26
                     | If-Range                 ; Section 14.27
                     | If-Unmodified-Since      ; Section 14.28
                     | Max-Forwards             ; Section 14.31
                     | Proxy-Authorization      ; Section 14.34
                     | Range                    ; Section 14.36
                     | Referer                  ; Section 14.37
                     | User-Agent               ; Section 14.42
</code></pre>
<p>Request-header field names can be extended reliably only in
combination with a change in the protocol version. However, new or
experimental header fields MAY be given the semantics of request-
header fields if all parties in the communication recognize them to
be request-header fields.  Unrecognized header fields are treated as
entity-header fields.</p>
<p>6 Response</p>
<p>After receiving and interpreting a request message, a server responds
with an HTTP response message.</p>
<pre><code>   Response      = Status-Line               ; Section 6.1
                   *( general-header         ; Section 4.5
                    | response-header        ; Section 6.2
                    | entity-header )        ; Section 7.1
                   CRLF
                   [ message-body ]          ; Section 7.2
</code></pre>
<p>6.1 Status-Line</p>
<p>The first line of a Response message is the Status-Line, consisting
of the protocol version followed by a numeric status code and its
associated textual phrase, with each element separated by SP
characters.  No CR or LF is allowed except in the final CRLF
sequence.</p>
<p>Fielding, et. al.           Standards Track                    [Page 38]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>   Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
</code></pre>
<p>6.1.1 Status Code and Reason Phrase</p>
<p>The Status-Code element is a 3-digit integer result code of the
attempt to understand and satisfy the request. These codes are fully
defined in section 10. The Reason-Phrase is intended to give a short
textual description of the Status-Code. The Status-Code is intended
for use by automata and the Reason-Phrase is intended for the human
user. The client is not required to examine or display the Reason-
Phrase.</p>
<p>The first digit of the Status-Code defines the class of response. The
last two digits do not have any categorization role. There are 5
values for the first digit:</p>
<pre><code> o  1xx: Informational - Request received, continuing process

 o  2xx: Success - The action was successfully received, understood,
    and accepted

 o  3xx: Redirection - Further action must be taken in order to
    complete the request

 o  4xx: Client Error - The request contains bad syntax or cannot be
    fulfilled

 o  5xx: Server Error - The server failed to fulfill an apparently
    valid request
</code></pre>
<p>The individual values of the numeric status codes defined for
HTTP/1.1, and an example set of corresponding Reason-Phrase&rsquo;s, are
presented below. The reason phrases listed here are only recommended
&ndash; they may be replaced by local equivalents without affecting the
protocol.</p>
<pre><code>      Status-Code    = &quot;100&quot;   ; Continue
                     | &quot;101&quot;   ; Switching Protocols
                     | &quot;200&quot;   ; OK
                     | &quot;201&quot;   ; Created
                     | &quot;202&quot;   ; Accepted
                     | &quot;203&quot;   ; Non-Authoritative Information
                     | &quot;204&quot;   ; No Content
                     | &quot;205&quot;   ; Reset Content
                     | &quot;206&quot;   ; Partial Content
                     | &quot;300&quot;   ; Multiple Choices
                     | &quot;301&quot;   ; Moved Permanently
                     | &quot;302&quot;   ; Moved Temporarily
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 39]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>                     | &quot;303&quot;   ; See Other
                     | &quot;304&quot;   ; Not Modified
                     | &quot;305&quot;   ; Use Proxy
                     | &quot;400&quot;   ; Bad Request
                     | &quot;401&quot;   ; Unauthorized
                     | &quot;402&quot;   ; Payment Required
                     | &quot;403&quot;   ; Forbidden
                     | &quot;404&quot;   ; Not Found
                     | &quot;405&quot;   ; Method Not Allowed
                     | &quot;406&quot;   ; Not Acceptable
                     | &quot;407&quot;   ; Proxy Authentication Required
                     | &quot;408&quot;   ; Request Time-out
                     | &quot;409&quot;   ; Conflict
                     | &quot;410&quot;   ; Gone
                     | &quot;411&quot;   ; Length Required
                     | &quot;412&quot;   ; Precondition Failed
                     | &quot;413&quot;   ; Request Entity Too Large
                     | &quot;414&quot;   ; Request-URI Too Large
                     | &quot;415&quot;   ; Unsupported Media Type
                     | &quot;500&quot;   ; Internal Server Error
                     | &quot;501&quot;   ; Not Implemented
                     | &quot;502&quot;   ; Bad Gateway
                     | &quot;503&quot;   ; Service Unavailable
                     | &quot;504&quot;   ; Gateway Time-out
                     | &quot;505&quot;   ; HTTP Version not supported
                     | extension-code

      extension-code = 3DIGIT

      Reason-Phrase  = *&lt;TEXT, excluding CR, LF&gt;
</code></pre>
<p>HTTP status codes are extensible. HTTP applications are not required
to understand the meaning of all registered status codes, though such
understanding is obviously desirable. However, applications MUST
understand the class of any status code, as indicated by the first
digit, and treat any unrecognized response as being equivalent to the
x00 status code of that class, with the exception that an
unrecognized response MUST NOT be cached. For example, if an
unrecognized status code of 431 is received by the client, it can
safely assume that there was something wrong with its request and
treat the response as if it had received a 400 status code. In such
cases, user agents SHOULD present to the user the entity returned
with the response, since that entity is likely to include human-
readable information which will explain the unusual status.</p>
<p>Fielding, et. al.           Standards Track                    [Page 40]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>6.2 Response Header Fields</p>
<p>The response-header fields allow the server to pass additional
information about the response which cannot be placed in the Status-
Line. These header fields give information about the server and about
further access to the resource identified by the Request-URI.</p>
<pre><code>      response-header = Age                     ; Section 14.6
                      | Location                ; Section 14.30
                      | Proxy-Authenticate      ; Section 14.33
                      | Public                  ; Section 14.35
                      | Retry-After             ; Section 14.38
                      | Server                  ; Section 14.39
                      | Vary                    ; Section 14.43
                      | Warning                 ; Section 14.45
                      | WWW-Authenticate        ; Section 14.46
</code></pre>
<p>Response-header field names can be extended reliably only in
combination with a change in the protocol version. However, new or
experimental header fields MAY be given the semantics of response-
header fields if all parties in the communication recognize them to
be response-header fields. Unrecognized header fields are treated as
entity-header fields.</p>
<p>7 Entity</p>
<p>Request and Response messages MAY transfer an entity if not otherwise
restricted by the request method or response status code. An entity
consists of entity-header fields and an entity-body, although some
responses will only include the entity-headers.</p>
<p>In this section, both sender and recipient refer to either the client
or the server, depending on who sends and who receives the entity.</p>
<p>7.1 Entity Header Fields</p>
<p>Entity-header fields define optional metainformation about the
entity-body or, if no body is present, about the resource identified
by the request.</p>
<p>Fielding, et. al.           Standards Track                    [Page 41]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>      entity-header  = Allow                    ; Section 14.7
                     | Content-Base             ; Section 14.11
                     | Content-Encoding         ; Section 14.12
                     | Content-Language         ; Section 14.13
                     | Content-Length           ; Section 14.14
                     | Content-Location         ; Section 14.15
                     | Content-MD5              ; Section 14.16
                     | Content-Range            ; Section 14.17
                     | Content-Type             ; Section 14.18
                     | ETag                     ; Section 14.20
                     | Expires                  ; Section 14.21
                     | Last-Modified            ; Section 14.29
                     | extension-header

      extension-header = message-header
</code></pre>
<p>The extension-header mechanism allows additional entity-header fields
to be defined without changing the protocol, but these fields cannot
be assumed to be recognizable by the recipient. Unrecognized header
fields SHOULD be ignored by the recipient and forwarded by proxies.</p>
<p>7.2 Entity Body</p>
<p>The entity-body (if any) sent with an HTTP request or response is in
a format and encoding defined by the entity-header fields.</p>
<pre><code>      entity-body    = *OCTET
</code></pre>
<p>An entity-body is only present in a message when a message-body is
present, as described in section 4.3. The entity-body is obtained
from the message-body by decoding any Transfer-Encoding that may have
been applied to ensure safe and proper transfer of the message.</p>
<p>7.2.1 Type</p>
<p>When an entity-body is included with a message, the data type of that
body is determined via the header fields Content-Type and Content-
Encoding. These define a two-layer, ordered encoding model:</p>
<pre><code>      entity-body := Content-Encoding( Content-Type( data ) )
</code></pre>
<p>Content-Type specifies the media type of the underlying data.
Content-Encoding may be used to indicate any additional content
codings applied to the data, usually for the purpose of data
compression, that are a property of the requested resource. There is
no default encoding.</p>
<p>Fielding, et. al.           Standards Track                    [Page 42]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Any HTTP/1.1 message containing an entity-body SHOULD include a
Content-Type header field defining the media type of that body. If
and only if the media type is not given by a Content-Type field, the
recipient MAY attempt to guess the media type via inspection of its
content and/or the name extension(s) of the URL used to identify the
resource. If the media type remains unknown, the recipient SHOULD
treat it as type &ldquo;application/octet-stream&rdquo;.</p>
<p>7.2.2 Length</p>
<p>The length of an entity-body is the length of the message-body after
any transfer codings have been removed. Section 4.4 defines how the
length of a message-body is determined.</p>
<p>8 Connections</p>
<p>8.1 Persistent Connections</p>
<p>8.1.1 Purpose</p>
<p>Prior to persistent connections, a separate TCP connection was
established to fetch each URL, increasing the load on HTTP servers
and causing congestion on the Internet. The use of inline images and
other associated data often requires a client to make multiple
requests of the same server in a short amount of time. Analyses of
these performance problems are available [30][27]; analysis and
results from a prototype implementation are in [26].</p>
<p>Persistent HTTP connections have a number of advantages:</p>
<pre><code> o  By opening and closing fewer TCP connections, CPU time is saved,
    and memory used for TCP protocol control blocks is also saved.
 o  HTTP requests and responses can be pipelined on a connection.
    Pipelining allows a client to make multiple requests without
    waiting for each response, allowing a single TCP connection to be
    used much more efficiently, with much lower elapsed time.
 o  Network congestion is reduced by reducing the number of packets
    caused by TCP opens, and by allowing TCP sufficient time to
    determine the congestion state of the network.
 o  HTTP can evolve more gracefully; since errors can be reported
    without the penalty of closing the TCP connection. Clients using
    future versions of HTTP might optimistically try a new feature, but
    if communicating with an older server, retry with old semantics
    after an error is reported.
</code></pre>
<p>HTTP implementations SHOULD implement persistent connections.</p>
<p>Fielding, et. al.           Standards Track                    [Page 43]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>8.1.2 Overall Operation</p>
<p>A significant difference between HTTP/1.1 and earlier versions of
HTTP is that persistent connections are the default behavior of any
HTTP connection. That is, unless otherwise indicated, the client may
assume that the server will maintain a persistent connection.</p>
<p>Persistent connections provide a mechanism by which a client and a
server can signal the close of a TCP connection. This signaling takes
place using the Connection header field. Once a close has been
signaled, the client MUST not send any more requests on that
connection.</p>
<p>8.1.2.1 Negotiation</p>
<p>An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to
maintain a persistent connection unless a Connection header including
the connection-token &ldquo;close&rdquo; was sent in the request. If the server
chooses to close the connection immediately after sending the
response, it SHOULD send a Connection header including the
connection-token close.</p>
<p>An HTTP/1.1 client MAY expect a connection to remain open, but would
decide to keep it open based on whether the response from a server
contains a Connection header with the connection-token close. In case
the client does not want to maintain a connection for more than that
request, it SHOULD send a Connection header including the
connection-token close.</p>
<p>If either the client or the server sends the close token in the
Connection header, that request becomes the last one for the
connection.</p>
<p>Clients and servers SHOULD NOT assume that a persistent connection is
maintained for HTTP versions less than 1.1 unless it is explicitly
signaled. See section 19.7.1 for more information on backwards
compatibility with HTTP/1.0 clients.</p>
<p>In order to remain persistent, all messages on the connection must
have a self-defined message length (i.e., one not defined by closure
of the connection), as described in section 4.4.</p>
<p>8.1.2.2 Pipelining</p>
<p>A client that supports persistent connections MAY &ldquo;pipeline&rdquo; its
requests (i.e., send multiple requests without waiting for each
response). A server MUST send its responses to those requests in the
same order that the requests were received.</p>
<p>Fielding, et. al.           Standards Track                    [Page 44]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Clients which assume persistent connections and pipeline immediately
after connection establishment SHOULD be prepared to retry their
connection if the first pipelined attempt fails. If a client does
such a retry, it MUST NOT pipeline before it knows the connection is
persistent. Clients MUST also be prepared to resend their requests if
the server closes the connection before sending all of the
corresponding responses.</p>
<p>8.1.3 Proxy Servers</p>
<p>It is especially important that proxies correctly implement the
properties of the Connection header field as specified in 14.2.1.</p>
<p>The proxy server MUST signal persistent connections separately with
its clients and the origin servers (or other proxy servers) that it
connects to. Each persistent connection applies to only one transport
link.</p>
<p>A proxy server MUST NOT establish a persistent connection with an
HTTP/1.0 client.</p>
<p>8.1.4 Practical Considerations</p>
<p>Servers will usually have some time-out value beyond which they will
no longer maintain an inactive connection. Proxy servers might make
this a higher value since it is likely that the client will be making
more connections through the same server. The use of persistent
connections places no requirements on the length of this time-out for
either the client or the server.</p>
<p>When a client or server wishes to time-out it SHOULD issue a graceful
close on the transport connection. Clients and servers SHOULD both
constantly watch for the other side of the transport close, and
respond to it as appropriate. If a client or server does not detect
the other side&rsquo;s close promptly it could cause unnecessary resource
drain on the network.</p>
<p>A client, server, or proxy MAY close the transport connection at any
time. For example, a client MAY have started to send a new request at
the same time that the server has decided to close the &ldquo;idle&rdquo;
connection. From the server&rsquo;s point of view, the connection is being
closed while it was idle, but from the client&rsquo;s point of view, a
request is in progress.</p>
<p>This means that clients, servers, and proxies MUST be able to recover
from asynchronous close events. Client software SHOULD reopen the
transport connection and retransmit the aborted request without user
interaction so long as the request method is idempotent (see section</p>
<p>Fielding, et. al.           Standards Track                    [Page 45]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>9.1.2); other methods MUST NOT be automatically retried, although
user agents MAY offer a human operator the choice of retrying the
request.</p>
<p>However, this automatic retry SHOULD NOT be repeated if the second
request fails.</p>
<p>Servers SHOULD always respond to at least one request per connection,
if at all possible. Servers SHOULD NOT close a connection in the
middle of transmitting a response, unless a network or client failure
is suspected.</p>
<p>Clients that use persistent connections SHOULD limit the number of
simultaneous connections that they maintain to a given server. A
single-user client SHOULD maintain AT MOST 2 connections with any
server or proxy. A proxy SHOULD use up to 2*N connections to another
server or proxy, where N is the number of simultaneously active
users. These guidelines are intended to improve HTTP response times
and avoid congestion of the Internet or other networks.</p>
<p>8.2 Message Transmission Requirements</p>
<p>General requirements:</p>
<p>o  HTTP/1.1 servers SHOULD maintain persistent connections and use
TCP&rsquo;s flow control mechanisms to resolve temporary overloads,
rather than terminating connections with the expectation that
clients will retry. The latter technique can exacerbate network
congestion.</p>
<p>o  An HTTP/1.1 (or later) client sending a message-body SHOULD monitor
the network connection for an error status while it is transmitting
the request. If the client sees an error status, it SHOULD
immediately cease transmitting the body. If the body is being sent
using a &ldquo;chunked&rdquo; encoding (section 3.6), a zero length chunk and
empty footer MAY be used to prematurely mark the end of the
message. If the body was preceded by a Content-Length header, the
client MUST close the connection.</p>
<p>o  An HTTP/1.1 (or later) client MUST be prepared to accept a 100
(Continue) status followed by a regular response.</p>
<p>o  An HTTP/1.1 (or later) server that receives a request from a
HTTP/1.0 (or earlier) client MUST NOT transmit the 100 (continue)
response; it SHOULD either wait for the request to be completed
normally (thus avoiding an interrupted request) or close the
connection prematurely.</p>
<p>Fielding, et. al.           Standards Track                    [Page 46]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Upon receiving a method subject to these requirements from an
HTTP/1.1 (or later) client, an HTTP/1.1 (or later) server MUST either
respond with 100 (Continue) status and continue to read from the
input stream, or respond with an error status. If it responds with an
error status, it MAY close the transport (TCP) connection or it MAY
continue to read and discard the rest of the request. It MUST NOT
perform the requested method if it returns an error status.</p>
<p>Clients SHOULD remember the version number of at least the most
recently used server; if an HTTP/1.1 client has seen an HTTP/1.1 or
later response from the server, and it sees the connection close
before receiving any status from the server, the client SHOULD retry
the request without user interaction so long as the request method is
idempotent (see section 9.1.2); other methods MUST NOT be
automatically retried, although user agents MAY offer a human
operator the choice of retrying the request.. If the client does
retry the request, the client</p>
<pre><code> o  MUST first send the request header fields, and then

 o  MUST wait for the server to respond with either a 100 (Continue)
    response, in which case the client should continue, or with an
    error status.
</code></pre>
<p>If an HTTP/1.1 client has not seen an HTTP/1.1 or later response from
the server, it should assume that the server implements HTTP/1.0 or
older and will not use the 100 (Continue) response. If in this case
the client sees the connection close before receiving any status from
the server, the client SHOULD retry the request. If the client does
retry the request to this HTTP/1.0 server, it should use the
following &ldquo;binary exponential backoff&rdquo; algorithm to be assured of
obtaining a reliable response:</p>
<ol>
<li>
<p>Initiate a new connection to the server</p>
</li>
<li>
<p>Transmit the request-headers</p>
</li>
<li>
<p>Initialize a variable R to the estimated round-trip time to the
server (e.g., based on the time it took to establish the
connection), or to a constant value of 5 seconds if the round-trip
time is not available.</p>
</li>
<li>
<p>Compute T = R * (2**N), where N is the number of previous retries
of this request.</p>
</li>
<li>
<p>Wait either for an error response from the server, or for T seconds
(whichever comes first)</p>
</li>
</ol>
<p>Fielding, et. al.           Standards Track                    [Page 47]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<ol start="6">
<li>
<p>If no error response is received, after T seconds transmit the body
of the request.</p>
</li>
<li>
<p>If client sees that the connection is closed prematurely, repeat
from step 1 until the request is accepted, an error response is
received, or the user becomes impatient and terminates the retry
process.</p>
</li>
</ol>
<p>No matter what the server version, if an error status is received,
the client</p>
<p>o  MUST NOT continue and</p>
<p>o  MUST close the connection if it has not completed sending the
message.</p>
<p>An HTTP/1.1 (or later) client that sees the connection close after
receiving a 100 (Continue) but before receiving any other status
SHOULD retry the request, and need not wait for 100 (Continue)
response (but MAY do so if this simplifies the implementation).</p>
<p>9 Method Definitions</p>
<p>The set of common methods for HTTP/1.1 is defined below. Although
this set can be expanded, additional methods cannot be assumed to
share the same semantics for separately extended clients and servers.</p>
<p>The Host request-header field (section 14.23) MUST accompany all
HTTP/1.1 requests.</p>
<p>9.1 Safe and Idempotent Methods</p>
<p>9.1.1 Safe Methods</p>
<p>Implementers should be aware that the software represents the user in
their interactions over the Internet, and should be careful to allow
the user to be aware of any actions they may take which may have an
unexpected significance to themselves or others.</p>
<p>In particular, the convention has been established that the GET and
HEAD methods should never have the significance of taking an action
other than retrieval. These methods should be considered &ldquo;safe.&rdquo; This
allows user agents to represent other methods, such as POST, PUT and
DELETE, in a special way, so that the user is made aware of the fact
that a possibly unsafe action is being requested.</p>
<p>Naturally, it is not possible to ensure that the server does not
generate side-effects as a result of performing a GET request; in</p>
<p>Fielding, et. al.           Standards Track                    [Page 48]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>fact, some dynamic resources consider that a feature. The important
distinction here is that the user did not request the side-effects,
so therefore cannot be held accountable for them.</p>
<p>9.1.2 Idempotent Methods</p>
<p>Methods may also have the property of &ldquo;idempotence&rdquo; in that (aside
from error or expiration issues) the side-effects of  N &gt; 0 identical
requests is the same as for a single request. The methods GET, HEAD,
PUT and DELETE share this property.</p>
<p>9.2 OPTIONS</p>
<p>The OPTIONS method represents a request for information about the
communication options available on the request/response chain
identified by the Request-URI. This method allows the client to
determine the options and/or requirements associated with a resource,
or the capabilities of a server, without implying a resource action
or initiating a resource retrieval.</p>
<p>Unless the server&rsquo;s response is an error, the response MUST NOT
include entity information other than what can be considered as
communication options (e.g., Allow is appropriate, but Content-Type
is not). Responses to this method are not cachable.</p>
<p>If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
intended to apply to the server as a whole. A 200 response SHOULD
include any header fields which indicate optional features
implemented by the server (e.g., Public), including any extensions
not defined by this specification, in addition to any applicable
general or response-header fields. As described in section 5.1.2, an
&ldquo;OPTIONS *&rdquo; request can be applied through a proxy by specifying the
destination server in the Request-URI without any path information.</p>
<p>If the Request-URI is not an asterisk, the OPTIONS request applies
only to the options that are available when communicating with that
resource.  A 200 response SHOULD include any header fields which
indicate optional features implemented by the server and applicable
to that resource (e.g., Allow), including any extensions not defined
by this specification, in addition to any applicable general or
response-header fields. If the OPTIONS request passes through a
proxy, the proxy MUST edit the response to exclude those options
which apply to a proxy&rsquo;s capabilities and which are known to be
unavailable through that proxy.</p>
<p>Fielding, et. al.           Standards Track                    [Page 49]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>9.3 GET</p>
<p>The GET method means retrieve whatever information (in the form of an
entity) is identified by the Request-URI. If the Request-URI refers
to a data-producing process, it is the produced data which shall be
returned as the entity in the response and not the source text of the
process, unless that text happens to be the output of the process.</p>
<p>The semantics of the GET method change to a &ldquo;conditional GET&rdquo; if the
request message includes an If-Modified-Since, If-Unmodified-Since,
If-Match, If-None-Match, or If-Range header field. A conditional GET
method requests that the entity be transferred only under the
circumstances described by the conditional header field(s). The
conditional GET method is intended to reduce unnecessary network
usage by allowing cached entities to be refreshed without requiring
multiple requests or transferring data already held by the client.</p>
<p>The semantics of the GET method change to a &ldquo;partial GET&rdquo; if the
request message includes a Range header field. A partial GET requests
that only part of the entity be transferred, as described in section
14.36. The partial GET method is intended to reduce unnecessary
network usage by allowing partially-retrieved entities to be
completed without transferring data already held by the client.</p>
<p>The response to a GET request is cachable if and only if it meets the
requirements for HTTP caching described in section 13.</p>
<p>9.4 HEAD</p>
<p>The HEAD method is identical to GET except that the server MUST NOT
return a message-body in the response. The metainformation contained
in the HTTP headers in response to a HEAD request SHOULD be identical
to the information sent in response to a GET request. This method can
be used for obtaining metainformation about the entity implied by the
request without transferring the entity-body itself. This method is
often used for testing hypertext links for validity, accessibility,
and recent modification.</p>
<p>The response to a HEAD request may be cachable in the sense that the
information contained in the response may be used to update a
previously cached entity from that resource. If the new field values
indicate that the cached entity differs from the current entity (as
would be indicated by a change in Content-Length, Content-MD5, ETag
or Last-Modified), then the cache MUST treat the cache entry as
stale.</p>
<p>Fielding, et. al.           Standards Track                    [Page 50]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>9.5 POST</p>
<p>The POST method is used to request that the destination server accept
the entity enclosed in the request as a new subordinate of the
resource identified by the Request-URI in the Request-Line. POST is
designed to allow a uniform method to cover the following functions:</p>
<pre><code> o  Annotation of existing resources;

 o  Posting a message to a bulletin board, newsgroup, mailing list,
    or similar group of articles;

 o  Providing a block of data, such as the result of submitting a
    form, to a data-handling process;

 o  Extending a database through an append operation.
</code></pre>
<p>The actual function performed by the POST method is determined by the
server and is usually dependent on the Request-URI. The posted entity
is subordinate to that URI in the same way that a file is subordinate
to a directory containing it, a news article is subordinate to a
newsgroup to which it is posted, or a record is subordinate to a
database.</p>
<p>The action performed by the POST method might not result in a
resource that can be identified by a URI. In this case, either 200
(OK) or 204 (No Content) is the appropriate response status,
depending on whether or not the response includes an entity that
describes the result.</p>
<p>If a resource has been created on the origin server, the response
SHOULD be 201 (Created) and contain an entity which describes the
status of the request and refers to the new resource, and a Location
header (see section 14.30).</p>
<p>Responses to this method are not cachable, unless the response
includes appropriate Cache-Control or Expires header fields. However,
the 303 (See Other) response can be used to direct the user agent to
retrieve a cachable resource.</p>
<p>POST requests must obey the message transmission requirements set out
in section 8.2.</p>
<p>Fielding, et. al.           Standards Track                    [Page 51]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>9.6 PUT</p>
<p>The PUT method requests that the enclosed entity be stored under the
supplied Request-URI. If the Request-URI refers to an already
existing resource, the enclosed entity SHOULD be considered as a
modified version of the one residing on the origin server. If the
Request-URI does not point to an existing resource, and that URI is
capable of being defined as a new resource by the requesting user
agent, the origin server can create the resource with that URI. If a
new resource is created, the origin server MUST inform the user agent
via the 201 (Created) response.  If an existing resource is modified,
either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
to indicate successful completion of the request. If the resource
could not be created or modified with the Request-URI, an appropriate
error response SHOULD be given that reflects the nature of the
problem. The recipient of the entity MUST NOT ignore any Content-*
(e.g. Content-Range) headers that it does not understand or implement
and MUST return a 501 (Not Implemented) response in such cases.</p>
<p>If the request passes through a cache and the Request-URI identifies
one or more currently cached entities, those entries should be
treated as stale. Responses to this method are not cachable.</p>
<p>The fundamental difference between the POST and PUT requests is
reflected in the different meaning of the Request-URI. The URI in a
POST request identifies the resource that will handle the enclosed
entity.  That resource may be a data-accepting process, a gateway to
some other protocol, or a separate entity that accepts annotations.
In contrast, the URI in a PUT request identifies the entity enclosed
with the request &ndash; the user agent knows what URI is intended and the
server MUST NOT attempt to apply the request to some other resource.
If the server desires that the request be applied to a different URI,
it MUST send a 301 (Moved Permanently) response; the user agent MAY
then make its own decision regarding whether or not to redirect the
request.</p>
<p>A single resource MAY be identified by many different URIs. For
example, an article may have a URI for identifying &ldquo;the current
version&rdquo; which is separate from the URI identifying each particular
version. In this case, a PUT request on a general URI may result in
several other URIs being defined by the origin server.</p>
<p>HTTP/1.1 does not define how a PUT method affects the state of an
origin server.</p>
<p>PUT requests must obey the message transmission requirements set out
in section 8.2.</p>
<p>Fielding, et. al.           Standards Track                    [Page 52]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>9.7 DELETE</p>
<p>The DELETE method requests that the origin server delete the resource
identified by the Request-URI. This method MAY be overridden by human
intervention (or other means) on the origin server. The client cannot
be guaranteed that the operation has been carried out, even if the
status code returned from the origin server indicates that the action
has been completed successfully. However, the server SHOULD not
indicate success unless, at the time the response is given, it
intends to delete the resource or move it to an inaccessible
location.</p>
<p>A successful response SHOULD be 200 (OK) if the response includes an
entity describing the status, 202 (Accepted) if the action has not
yet been enacted, or 204 (No Content) if the response is OK but does
not include an entity.</p>
<p>If the request passes through a cache and the Request-URI identifies
one or more currently cached entities, those entries should be
treated as stale. Responses to this method are not cachable.</p>
<p>9.8 TRACE</p>
<p>The TRACE method is used to invoke a remote, application-layer loop-
back of the request message. The final recipient of the request
SHOULD reflect the message received back to the client as the
entity-body of a 200 (OK) response. The final recipient is either the
origin server or the first proxy or gateway to receive a Max-Forwards
value of zero (0) in the request (see section 14.31). A TRACE request
MUST NOT include an entity.</p>
<p>TRACE allows the client to see what is being received at the other
end of the request chain and use that data for testing or diagnostic
information. The value of the Via header field (section 14.44) is of
particular interest, since it acts as a trace of the request chain.
Use of the Max-Forwards header field allows the client to limit the
length of the request chain, which is useful for testing a chain of
proxies forwarding messages in an infinite loop.</p>
<p>If successful, the response SHOULD contain the entire request message
in the entity-body, with a Content-Type of &ldquo;message/http&rdquo;. Responses
to this method MUST NOT be cached.</p>
<p>10 Status Code Definitions</p>
<p>Each Status-Code is described below, including a description of which
method(s) it can follow and any metainformation required in the
response.</p>
<p>Fielding, et. al.           Standards Track                    [Page 53]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>10.1 Informational 1xx</p>
<p>This class of status code indicates a provisional response,
consisting only of the Status-Line and optional headers, and is
terminated by an empty line. Since HTTP/1.0 did not define any 1xx
status codes, servers MUST NOT send a 1xx response to an HTTP/1.0
client except under experimental conditions.</p>
<p>10.1.1 100 Continue</p>
<p>The client may continue with its request. This interim response is
used to inform the client that the initial part of the request has
been received and has not yet been rejected by the server. The client
SHOULD continue by sending the remainder of the request or, if the
request has already been completed, ignore this response. The server
MUST send a final response after the request has been completed.</p>
<p>10.1.2 101 Switching Protocols</p>
<p>The server understands and is willing to comply with the client&rsquo;s
request, via the Upgrade message header field (section 14.41), for a
change in the application protocol being used on this connection. The
server will switch protocols to those defined by the response&rsquo;s
Upgrade header field immediately after the empty line which
terminates the 101 response.</p>
<p>The protocol should only be switched when it is advantageous to do
so.  For example, switching to a newer version of HTTP is
advantageous over older versions, and switching to a real-time,
synchronous protocol may be advantageous when delivering resources
that use such features.</p>
<p>10.2 Successful 2xx</p>
<p>This class of status code indicates that the client&rsquo;s request was
successfully received, understood, and accepted.</p>
<p>10.2.1 200 OK</p>
<p>The request has succeeded. The information returned with the response
is dependent on the method used in the request, for example:</p>
<p>GET  an entity corresponding to the requested resource is sent in the
response;</p>
<p>HEAD the entity-header fields corresponding to the requested resource
are sent in the response without any message-body;</p>
<p>Fielding, et. al.           Standards Track                    [Page 54]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>POST an entity describing or containing the result of the action;</p>
<p>TRACE an entity containing the request message as received by the end
server.</p>
<p>10.2.2 201 Created</p>
<p>The request has been fulfilled and resulted in a new resource being
created. The newly created resource can be referenced by the URI(s)
returned in the entity of the response, with the most specific URL
for the resource given by a Location header field. The origin server
MUST create the resource before returning the 201 status code. If the
action cannot be carried out immediately, the server should respond
with 202 (Accepted) response instead.</p>
<p>10.2.3 202 Accepted</p>
<p>The request has been accepted for processing, but the processing has
not been completed. The request MAY or MAY NOT eventually be acted
upon, as it MAY be disallowed when processing actually takes place.
There is no facility for re-sending a status code from an
asynchronous operation such as this.</p>
<p>The 202 response is intentionally non-committal. Its purpose is to
allow a server to accept a request for some other process (perhaps a
batch-oriented process that is only run once per day) without
requiring that the user agent&rsquo;s connection to the server persist
until the process is completed. The entity returned with this
response SHOULD include an indication of the request&rsquo;s current status
and either a pointer to a status monitor or some estimate of when the
user can expect the request to be fulfilled.</p>
<p>10.2.4 203 Non-Authoritative Information</p>
<p>The returned metainformation in the entity-header is not the
definitive set as available from the origin server, but is gathered
from a local or a third-party copy. The set presented MAY be a subset
or superset of the original version. For example, including local
annotation information about the resource MAY result in a superset of
the metainformation known by the origin server. Use of this response
code is not required and is only appropriate when the response would
otherwise be 200 (OK).</p>
<p>10.2.5 204 No Content</p>
<p>The server has fulfilled the request but there is no new information
to send back. If the client is a user agent, it SHOULD NOT change its
document view from that which caused the request to be sent. This</p>
<p>Fielding, et. al.           Standards Track                    [Page 55]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>response is primarily intended to allow input for actions to take
place without causing a change to the user agent&rsquo;s active document
view. The response MAY include new metainformation in the form of
entity-headers, which SHOULD apply to the document currently in the
user agent&rsquo;s active view.</p>
<p>The 204 response MUST NOT include a message-body, and thus is always
terminated by the first empty line after the header fields.</p>
<p>10.2.6 205 Reset Content</p>
<p>The server has fulfilled the request and the user agent SHOULD reset
the document view which caused the request to be sent. This response
is primarily intended to allow input for actions to take place via
user input, followed by a clearing of the form in which the input is
given so that the user can easily initiate another input action. The
response MUST NOT include an entity.</p>
<p>10.2.7 206 Partial Content</p>
<p>The server has fulfilled the partial GET request for the resource.
The request must have included a Range header field (section 14.36)
indicating the desired range. The response MUST include either a
Content-Range header field (section 14.17) indicating the range
included with this response, or a multipart/byteranges Content-Type
including Content-Range fields for each part. If multipart/byteranges
is not used, the Content-Length header field in the response MUST
match the actual number of OCTETs transmitted in the message-body.</p>
<p>A cache that does not support the Range and Content-Range headers
MUST NOT cache 206 (Partial) responses.</p>
<p>10.3 Redirection 3xx</p>
<p>This class of status code indicates that further action needs to be
taken by the user agent in order to fulfill the request. The action
required MAY be carried out by the user agent without interaction
with the user if and only if the method used in the second request is
GET or HEAD. A user agent SHOULD NOT automatically redirect a request
more than 5 times, since such redirections usually indicate an
infinite loop.</p>
<p>Fielding, et. al.           Standards Track                    [Page 56]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>10.3.1 300 Multiple Choices</p>
<p>The requested resource corresponds to any one of a set of
representations, each with its own specific location, and agent-
driven negotiation information (section 12) is being provided so that
the user (or user agent) can select a preferred representation and
redirect its request to that location.</p>
<p>Unless it was a HEAD request, the response SHOULD include an entity
containing a list of resource characteristics and location(s) from
which the user or user agent can choose the one most appropriate. The
entity format is specified by the media type given in the Content-
Type header field. Depending upon the format and the capabilities of
the user agent, selection of the most appropriate choice may be
performed automatically.  However, this specification does not define
any standard for such automatic selection.</p>
<p>If the server has a preferred choice of representation, it SHOULD
include the specific URL for that representation in the Location
field; user agents MAY use the Location field value for automatic
redirection.  This response is cachable unless indicated otherwise.</p>
<p>10.3.2 301 Moved Permanently</p>
<p>The requested resource has been assigned a new permanent URI and any
future references to this resource SHOULD be done using one of the
returned URIs. Clients with link editing capabilities SHOULD
automatically re-link references to the Request-URI to one or more of
the new references returned by the server, where possible. This
response is cachable unless indicated otherwise.</p>
<p>If the new URI is a location, its URL SHOULD be given by the Location
field in the response. Unless the request method was HEAD, the entity
of the response SHOULD contain a short hypertext note with a
hyperlink to the new URI(s).</p>
<p>If the 301 status code is received in response to a request other
than GET or HEAD, the user agent MUST NOT automatically redirect the
request unless it can be confirmed by the user, since this might
change the conditions under which the request was issued.</p>
<pre><code> Note: When automatically redirecting a POST request after receiving
 a 301 status code, some existing HTTP/1.0 user agents will
 erroneously change it into a GET request.
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 57]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>10.3.3 302 Moved Temporarily</p>
<p>The requested resource resides temporarily under a different URI.
Since the redirection may be altered on occasion, the client SHOULD
continue to use the Request-URI for future requests. This response is
only cachable if indicated by a Cache-Control or Expires header
field.</p>
<p>If the new URI is a location, its URL SHOULD be given by the Location
field in the response. Unless the request method was HEAD, the entity
of the response SHOULD contain a short hypertext note with a
hyperlink to the new URI(s).</p>
<p>If the 302 status code is received in response to a request other
than GET or HEAD, the user agent MUST NOT automatically redirect the
request unless it can be confirmed by the user, since this might
change the conditions under which the request was issued.</p>
<pre><code> Note: When automatically redirecting a POST request after receiving
 a 302 status code, some existing HTTP/1.0 user agents will
 erroneously change it into a GET request.
</code></pre>
<p>10.3.4 303 See Other</p>
<p>The response to the request can be found under a different URI and
SHOULD be retrieved using a GET method on that resource. This method
exists primarily to allow the output of a POST-activated script to
redirect the user agent to a selected resource. The new URI is not a
substitute reference for the originally requested resource. The 303
response is not cachable, but the response to the second (redirected)
request MAY be cachable.</p>
<p>If the new URI is a location, its URL SHOULD be given by the Location
field in the response. Unless the request method was HEAD, the entity
of the response SHOULD contain a short hypertext note with a
hyperlink to the new URI(s).</p>
<p>10.3.5 304 Not Modified</p>
<p>If the client has performed a conditional GET request and access is
allowed, but the document has not been modified, the server SHOULD
respond with this status code. The response MUST NOT contain a
message-body.</p>
<p>Fielding, et. al.           Standards Track                    [Page 58]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The response MUST include the following header fields:</p>
<p>o  Date</p>
<p>o  ETag and/or Content-Location, if the header would have been sent in
a 200 response to the same request</p>
<p>o  Expires, Cache-Control, and/or Vary, if the field-value might
differ from that sent in any previous response for the same variant</p>
<p>If the conditional GET used a strong cache validator (see section
13.3.3), the response SHOULD NOT include other entity-headers.
Otherwise (i.e., the conditional GET used a weak validator), the
response MUST NOT include other entity-headers; this prevents
inconsistencies between cached entity-bodies and updated headers.</p>
<p>If a 304 response indicates an entity not currently cached, then the
cache MUST disregard the response and repeat the request without the
conditional.</p>
<p>If a cache uses a received 304 response to update a cache entry, the
cache MUST update the entry to reflect any new field values given in
the response.</p>
<p>The 304 response MUST NOT include a message-body, and thus is always
terminated by the first empty line after the header fields.</p>
<p>10.3.6 305 Use Proxy</p>
<p>The requested resource MUST be accessed through the proxy given by
the Location field. The Location field gives the URL of the proxy.
The recipient is expected to repeat the request via the proxy.</p>
<p>10.4 Client Error 4xx</p>
<p>The 4xx class of status code is intended for cases in which the
client seems to have erred. Except when responding to a HEAD request,
the server SHOULD include an entity containing an explanation of the
error situation, and whether it is a temporary or permanent
condition. These status codes are applicable to any request method.
User agents SHOULD display any included entity to the user.</p>
<pre><code> Note: If the client is sending data, a server implementation using
 TCP should be careful to ensure that the client acknowledges
 receipt of the packet(s) containing the response, before the server
 closes the input connection. If the client continues sending data
 to the server after the close, the server's TCP stack will send a
 reset packet to the client, which may erase the client's
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 59]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> unacknowledged input buffers before they can be read and
 interpreted by the HTTP application.
</code></pre>
<p>10.4.1 400 Bad Request</p>
<p>The request could not be understood by the server due to malformed
syntax. The client SHOULD NOT repeat the request without
modifications.</p>
<p>10.4.2 401 Unauthorized</p>
<p>The request requires user authentication. The response MUST include a
WWW-Authenticate header field (section 14.46) containing a challenge
applicable to the requested resource. The client MAY repeat the
request with a suitable Authorization header field (section 14.8). If
the request already included Authorization credentials, then the 401
response indicates that authorization has been refused for those
credentials. If the 401 response contains the same challenge as the
prior response, and the user agent has already attempted
authentication at least once, then the user SHOULD be presented the
entity that was given in the response, since that entity MAY include
relevant diagnostic information. HTTP access authentication is
explained in section 11.</p>
<p>10.4.3 402 Payment Required</p>
<p>This code is reserved for future use.</p>
<p>10.4.4 403 Forbidden</p>
<p>The server understood the request, but is refusing to fulfill it.
Authorization will not help and the request SHOULD NOT be repeated.
If the request method was not HEAD and the server wishes to make
public why the request has not been fulfilled, it SHOULD describe the
reason for the refusal in the entity. This status code is commonly
used when the server does not wish to reveal exactly why the request
has been refused, or when no other response is applicable.</p>
<p>10.4.5 404 Not Found</p>
<p>The server has not found anything matching the Request-URI. No
indication is given of whether the condition is temporary or
permanent.</p>
<p>Fielding, et. al.           Standards Track                    [Page 60]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>If the server does not wish to make this information available to the
client, the status code 403 (Forbidden) can be used instead. The 410
(Gone) status code SHOULD be used if the server knows, through some
internally configurable mechanism, that an old resource is
permanently unavailable and has no forwarding address.</p>
<p>10.4.6 405 Method Not Allowed</p>
<p>The method specified in the Request-Line is not allowed for the
resource identified by the Request-URI. The response MUST include an
Allow header containing a list of valid methods for the requested
resource.</p>
<p>10.4.7 406 Not Acceptable</p>
<p>The resource identified by the request is only capable of generating
response entities which have content characteristics not acceptable
according to the accept headers sent in the request.</p>
<p>Unless it was a HEAD request, the response SHOULD include an entity
containing a list of available entity characteristics and location(s)
from which the user or user agent can choose the one most
appropriate.  The entity format is specified by the media type given
in the Content-Type header field. Depending upon the format and the
capabilities of the user agent, selection of the most appropriate
choice may be performed automatically. However, this specification
does not define any standard for such automatic selection.</p>
<pre><code> Note: HTTP/1.1 servers are allowed to return responses which are
 not acceptable according to the accept headers sent in the request.
 In some cases, this may even be preferable to sending a 406
 response. User agents are encouraged to inspect the headers of an
 incoming response to determine if it is acceptable. If the response
 could be unacceptable, a user agent SHOULD temporarily stop receipt
 of more data and query the user for a decision on further actions.
</code></pre>
<p>10.4.8 407 Proxy Authentication Required</p>
<p>This code is similar to 401 (Unauthorized), but indicates that the
client MUST first authenticate itself with the proxy. The proxy MUST
return a Proxy-Authenticate header field (section 14.33) containing a
challenge applicable to the proxy for the requested resource. The
client MAY repeat the request with a suitable Proxy-Authorization
header field (section 14.34). HTTP access authentication is explained
in section 11.</p>
<p>Fielding, et. al.           Standards Track                    [Page 61]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>10.4.9 408 Request Timeout</p>
<p>The client did not produce a request within the time that the server
was prepared to wait. The client MAY repeat the request without
modifications at any later time.</p>
<p>10.4.10 409 Conflict</p>
<p>The request could not be completed due to a conflict with the current
state of the resource. This code is only allowed in situations where
it is expected that the user might be able to resolve the conflict
and resubmit the request. The response body SHOULD include enough
information for the user to recognize the source of the conflict.
Ideally, the response entity would include enough information for the
user or user agent to fix the problem; however, that may not be
possible and is not required.</p>
<p>Conflicts are most likely to occur in response to a PUT request. If
versioning is being used and the entity being PUT includes changes to
a resource which conflict with those made by an earlier (third-party)
request, the server MAY use the 409 response to indicate that it
can&rsquo;t complete the request. In this case, the response entity SHOULD
contain a list of the differences between the two versions in a
format defined by the response Content-Type.</p>
<p>10.4.11 410 Gone</p>
<p>The requested resource is no longer available at the server and no
forwarding address is known. This condition SHOULD be considered
permanent. Clients with link editing capabilities SHOULD delete
references to the Request-URI after user approval. If the server does
not know, or has no facility to determine, whether or not the
condition is permanent, the status code 404 (Not Found) SHOULD be
used instead.  This response is cachable unless indicated otherwise.</p>
<p>The 410 response is primarily intended to assist the task of web
maintenance by notifying the recipient that the resource is
intentionally unavailable and that the server owners desire that
remote links to that resource be removed. Such an event is common for
limited-time, promotional services and for resources belonging to
individuals no longer working at the server&rsquo;s site. It is not
necessary to mark all permanently unavailable resources as &ldquo;gone&rdquo; or
to keep the mark for any length of time &ndash; that is left to the
discretion of the server owner.</p>
<p>Fielding, et. al.           Standards Track                    [Page 62]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>10.4.12 411 Length Required</p>
<p>The server refuses to accept the request without a defined Content-
Length. The client MAY repeat the request if it adds a valid
Content-Length header field containing the length of the message-body
in the request message.</p>
<p>10.4.13 412 Precondition Failed</p>
<p>The precondition given in one or more of the request-header fields
evaluated to false when it was tested on the server. This response
code allows the client to place preconditions on the current resource
metainformation (header field data) and thus prevent the requested
method from being applied to a resource other than the one intended.</p>
<p>10.4.14 413 Request Entity Too Large</p>
<p>The server is refusing to process a request because the request
entity is larger than the server is willing or able to process. The
server may close the connection to prevent the client from continuing
the request.</p>
<p>If the condition is temporary, the server SHOULD include a Retry-
After header field to indicate that it is temporary and after what
time the client may try again.</p>
<p>10.4.15 414 Request-URI Too Long</p>
<p>The server is refusing to service the request because the Request-URI
is longer than the server is willing to interpret. This rare
condition is only likely to occur when a client has improperly
converted a POST request to a GET request with long query
information, when the client has descended into a URL &ldquo;black hole&rdquo; of
redirection (e.g., a redirected URL prefix that points to a suffix of
itself), or when the server is under attack by a client attempting to
exploit security holes present in some servers using fixed-length
buffers for reading or manipulating the Request-URI.</p>
<p>10.4.16 415 Unsupported Media Type</p>
<p>The server is refusing to service the request because the entity of
the request is in a format not supported by the requested resource
for the requested method.</p>
<p>Fielding, et. al.           Standards Track                    [Page 63]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>10.5 Server Error 5xx</p>
<p>Response status codes beginning with the digit &ldquo;5&rdquo; indicate cases in
which the server is aware that it has erred or is incapable of
performing the request. Except when responding to a HEAD request, the
server SHOULD include an entity containing an explanation of the
error situation, and whether it is a temporary or permanent
condition. User agents SHOULD display any included entity to the
user. These response codes are applicable to any request method.</p>
<p>10.5.1 500 Internal Server Error</p>
<p>The server encountered an unexpected condition which prevented it
from fulfilling the request.</p>
<p>10.5.2 501 Not Implemented</p>
<p>The server does not support the functionality required to fulfill the
request. This is the appropriate response when the server does not
recognize the request method and is not capable of supporting it for
any resource.</p>
<p>10.5.3 502 Bad Gateway</p>
<p>The server, while acting as a gateway or proxy, received an invalid
response from the upstream server it accessed in attempting to
fulfill the request.</p>
<p>10.5.4 503 Service Unavailable</p>
<p>The server is currently unable to handle the request due to a
temporary overloading or maintenance of the server. The implication
is that this is a temporary condition which will be alleviated after
some delay. If known, the length of the delay may be indicated in a
Retry-After header.  If no Retry-After is given, the client SHOULD
handle the response as it would for a 500 response.</p>
<pre><code> Note: The existence of the 503 status code does not imply that a
 server must use it when becoming overloaded. Some servers may wish
 to simply refuse the connection.
</code></pre>
<p>10.5.5 504 Gateway Timeout</p>
<p>The server, while acting as a gateway or proxy, did not receive a
timely response from the upstream server it accessed in attempting to
complete the request.</p>
<p>Fielding, et. al.           Standards Track                    [Page 64]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>10.5.6 505 HTTP Version Not Supported</p>
<p>The server does not support, or refuses to support, the HTTP protocol
version that was used in the request message. The server is
indicating that it is unable or unwilling to complete the request
using the same major version as the client, as described in section
3.1, other than with this error message. The response SHOULD contain
an entity describing why that version is not supported and what other
protocols are supported by that server.</p>
<p>11 Access Authentication</p>
<p>HTTP provides a simple challenge-response authentication mechanism
which MAY be used by a server to challenge a client request and by a
client to provide authentication information. It uses an extensible,
case-insensitive token to identify the authentication scheme,
followed by a comma-separated list of attribute-value pairs which
carry the parameters necessary for achieving authentication via that
scheme.</p>
<pre><code>      auth-scheme    = token

      auth-param     = token &quot;=&quot; quoted-string
</code></pre>
<p>The 401 (Unauthorized) response message is used by an origin server
to challenge the authorization of a user agent. This response MUST
include a WWW-Authenticate header field containing at least one
challenge applicable to the requested resource.</p>
<pre><code>      challenge      = auth-scheme 1*SP realm *( &quot;,&quot; auth-param )

      realm          = &quot;realm&quot; &quot;=&quot; realm-value
      realm-value    = quoted-string
</code></pre>
<p>The realm attribute (case-insensitive) is required for all
authentication schemes which issue a challenge. The realm value
(case-sensitive), in combination with the canonical root URL (see
section 5.1.2) of the server being accessed, defines the protection
space. These realms allow the protected resources on a server to be
partitioned into a set of protection spaces, each with its own
authentication scheme and/or authorization database. The realm value
is a string, generally assigned by the origin server, which may have
additional semantics specific to the authentication scheme.</p>
<p>A user agent that wishes to authenticate itself with a server&ndash;
usually, but not necessarily, after receiving a 401 or 411 response-
-MAY do so by including an Authorization header field with the
request. The Authorization field value consists of credentials</p>
<p>Fielding, et. al.           Standards Track                    [Page 65]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>containing the authentication information of the user agent for the
realm of the resource being requested.</p>
<pre><code>      credentials    = basic-credentials
                     | auth-scheme #auth-param
</code></pre>
<p>The domain over which credentials can be automatically applied by a
user agent is determined by the protection space. If a prior request
has been authorized, the same credentials MAY be reused for all other
requests within that protection space for a period of time determined
by the authentication scheme, parameters, and/or user preference.
Unless otherwise defined by the authentication scheme, a single
protection space cannot extend outside the scope of its server.</p>
<p>If the server does not wish to accept the credentials sent with a
request, it SHOULD return a 401 (Unauthorized) response. The response
MUST include a WWW-Authenticate header field containing the (possibly
new) challenge applicable to the requested resource and an entity
explaining the refusal.</p>
<p>The HTTP protocol does not restrict applications to this simple
challenge-response mechanism for access authentication. Additional
mechanisms MAY be used, such as encryption at the transport level or
via message encapsulation, and with additional header fields
specifying authentication information. However, these additional
mechanisms are not defined by this specification.</p>
<p>Proxies MUST be completely transparent regarding user agent
authentication. That is, they MUST forward the WWW-Authenticate and
Authorization headers untouched, and follow the rules found in
section 14.8.</p>
<p>HTTP/1.1 allows a client to pass authentication information to and
from a proxy via the Proxy-Authenticate and Proxy-Authorization
headers.</p>
<p>11.1 Basic Authentication Scheme</p>
<p>The &ldquo;basic&rdquo; authentication scheme is based on the model that the user
agent must authenticate itself with a user-ID and a password for each
realm. The realm value should be considered an opaque string which
can only be compared for equality with other realms on that server.
The server will service the request only if it can validate the
user-ID and password for the protection space of the Request-URI.
There are no optional authentication parameters.</p>
<p>Fielding, et. al.           Standards Track                    [Page 66]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Upon receipt of an unauthorized request for a URI within the
protection space, the server MAY respond with a challenge like the
following:</p>
<pre><code>      WWW-Authenticate: Basic realm=&quot;WallyWorld&quot;
</code></pre>
<p>where &ldquo;WallyWorld&rdquo; is the string assigned by the server to identify
the protection space of the Request-URI.</p>
<p>To receive authorization, the client sends the userid and password,
separated by a single colon (&quot;:&quot;) character, within a base64  encoded
string in the credentials.</p>
<pre><code>      basic-credentials = &quot;Basic&quot; SP basic-cookie

      basic-cookie   = &lt;base64 [7] encoding of user-pass,
                       except not limited to 76 char/line&gt;

      user-pass   = userid &quot;:&quot; password

      userid      = *&lt;TEXT excluding &quot;:&quot;&gt;

      password    = *TEXT
</code></pre>
<p>Userids might be case sensitive.</p>
<p>If the user agent wishes to send the userid &ldquo;Aladdin&rdquo; and password
&ldquo;open sesame&rdquo;, it would use the following header field:</p>
<pre><code>      Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
</code></pre>
<p>See section 15 for security considerations associated with Basic
authentication.</p>
<p>11.2 Digest Authentication Scheme</p>
<p>A digest authentication for HTTP is specified in RFC 2069 [32].</p>
<p>12 Content Negotiation</p>
<p>Most HTTP responses include an entity which contains information for
interpretation by a human user. Naturally, it is desirable to supply
the user with the &ldquo;best available&rdquo; entity corresponding to the
request.  Unfortunately for servers and caches, not all users have
the same preferences for what is &ldquo;best,&rdquo; and not all user agents are
equally capable of rendering all entity types. For that reason, HTTP
has provisions for several mechanisms for &ldquo;content negotiation&rdquo; &ndash;
the process of selecting the best representation for a given response</p>
<p>Fielding, et. al.           Standards Track                    [Page 67]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>when there are multiple representations available.</p>
<pre><code> Note: This is not called &quot;format negotiation&quot; because the alternate
 representations may be of the same media type, but use different
 capabilities of that type, be in different languages, etc.
</code></pre>
<p>Any response containing an entity-body MAY be subject to negotiation,
including error responses.</p>
<p>There are two kinds of content negotiation which are possible in
HTTP: server-driven and agent-driven negotiation. These two kinds of
negotiation are orthogonal and thus may be used separately or in
combination. One method of combination, referred to as transparent
negotiation, occurs when a cache uses the agent-driven negotiation
information provided by the origin server in order to provide
server-driven negotiation for subsequent requests.</p>
<p>12.1 Server-driven Negotiation</p>
<p>If the selection of the best representation for a response is made by
an algorithm located at the server, it is called server-driven
negotiation.  Selection is based on the available representations of
the response (the dimensions over which it can vary; e.g. language,
content-coding, etc.) and the contents of particular header fields in
the request message or on other information pertaining to the request
(such as the network address of the client).</p>
<p>Server-driven negotiation is advantageous when the algorithm for
selecting from among the available representations is difficult to
describe to the user agent, or when the server desires to send its
&ldquo;best guess&rdquo; to the client along with the first response (hoping to
avoid the round-trip delay of a subsequent request if the &ldquo;best
guess&rdquo; is good enough for the user). In order to improve the server&rsquo;s
guess, the user agent MAY include request header fields (Accept,
Accept-Language, Accept-Encoding, etc.) which describe its
preferences for such a response.</p>
<p>Server-driven negotiation has disadvantages:</p>
<ol>
<li>
<p>It is impossible for the server to accurately determine what might be
&ldquo;best&rdquo; for any given user, since that would require complete
knowledge of both the capabilities of the user agent and the intended
use for the response (e.g., does the user want to view it on screen
or print it on paper?).</p>
</li>
<li>
<p>Having the user agent describe its capabilities in every request can
be both very inefficient (given that only a small percentage of
responses have multiple representations) and a potential violation of</p>
</li>
</ol>
<p>Fielding, et. al.           Standards Track                    [Page 68]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>the user&rsquo;s privacy.</p>
<ol start="3">
<li>
<p>It complicates the implementation of an origin server and the
algorithms for generating responses to a request.</p>
</li>
<li>
<p>It may limit a public cache&rsquo;s ability to use the same response for
multiple user&rsquo;s requests.</p>
<p>HTTP/1.1 includes the following request-header fields for enabling
server-driven negotiation through description of user agent
capabilities and user preferences: Accept (section 14.1), Accept-
Charset (section 14.2), Accept-Encoding (section 14.3), Accept-
Language (section 14.4), and User-Agent (section 14.42). However, an
origin server is not limited to these dimensions and MAY vary the
response based on any aspect of the request, including information
outside the request-header fields or within extension header fields
not defined by this specification.</p>
<p>HTTP/1.1 origin servers MUST include an appropriate Vary header field
(section 14.43) in any cachable response based on server-driven
negotiation. The Vary header field describes the dimensions over
which the response might vary (i.e. the dimensions over which the
origin server picks its &ldquo;best guess&rdquo; response from multiple
representations).</p>
<p>HTTP/1.1 public caches MUST recognize the Vary header field when it
is included in a response and obey the requirements described in
section 13.6 that describes the interactions between caching and
content negotiation.</p>
</li>
</ol>
<p>12.2 Agent-driven Negotiation</p>
<p>With agent-driven negotiation, selection of the best representation
for a response is performed by the user agent after receiving an
initial response from the origin server. Selection is based on a list
of the available representations of the response included within the
header fields (this specification reserves the field-name Alternates,
as described in appendix 19.6.2.1) or entity-body of the initial
response, with each representation identified by its own URI.
Selection from among the representations may be performed
automatically (if the user agent is capable of doing so) or manually
by the user selecting from a generated (possibly hypertext) menu.</p>
<p>Agent-driven negotiation is advantageous when the response would vary
over commonly-used dimensions (such as type, language, or encoding),
when the origin server is unable to determine a user agent&rsquo;s
capabilities from examining the request, and generally when public
caches are used to distribute server load and reduce network usage.</p>
<p>Fielding, et. al.           Standards Track                    [Page 69]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Agent-driven negotiation suffers from the disadvantage of needing a
second request to obtain the best alternate representation. This
second request is only efficient when caching is used. In addition,
this specification does not define any mechanism for supporting
automatic selection, though it also does not prevent any such
mechanism from being developed as an extension and used within
HTTP/1.1.</p>
<p>HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)
status codes for enabling agent-driven negotiation when the server is
unwilling or unable to provide a varying response using server-driven
negotiation.</p>
<p>12.3 Transparent Negotiation</p>
<p>Transparent negotiation is a combination of both server-driven and
agent-driven negotiation. When a cache is supplied with a form of the
list of available representations of the response (as in agent-driven
negotiation) and the dimensions of variance are completely understood
by the cache, then the cache becomes capable of performing server-
driven negotiation on behalf of the origin server for subsequent
requests on that resource.</p>
<p>Transparent negotiation has the advantage of distributing the
negotiation work that would otherwise be required of the origin
server and also removing the second request delay of agent-driven
negotiation when the cache is able to correctly guess the right
response.</p>
<p>This specification does not define any mechanism for transparent
negotiation, though it also does not prevent any such mechanism from
being developed as an extension and used within HTTP/1.1. An HTTP/1.1
cache performing transparent negotiation MUST include a Vary header
field in the response (defining the dimensions of its variance) if it
is cachable to ensure correct interoperation with all HTTP/1.1
clients. The agent-driven negotiation information supplied by the
origin server SHOULD be included with the transparently negotiated
response.</p>
<p>13 Caching in HTTP</p>
<p>HTTP is typically used for distributed information systems, where
performance can be improved by the use of response caches. The
HTTP/1.1 protocol includes a number of elements intended to make
caching work as well as possible. Because these elements are
inextricable from other aspects of the protocol, and because they
interact with each other, it is useful to describe the basic caching
design of HTTP separately from the detailed descriptions of methods,</p>
<p>Fielding, et. al.           Standards Track                    [Page 70]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>headers, response codes, etc.</p>
<p>Caching would be useless if it did not significantly improve
performance. The goal of caching in HTTP/1.1 is to eliminate the need
to send requests in many cases, and to eliminate the need to send
full responses in many other cases. The former reduces the number of
network round-trips required for many operations; we use an
&ldquo;expiration&rdquo; mechanism for this purpose (see section 13.2). The
latter reduces network bandwidth requirements; we use a &ldquo;validation&rdquo;
mechanism for this purpose (see section 13.3).</p>
<p>Requirements for performance, availability, and disconnected
operation require us to be able to relax the goal of semantic
transparency. The HTTP/1.1 protocol allows origin servers, caches,
and clients to explicitly reduce transparency when necessary.
However, because non-transparent operation may confuse non-expert
users, and may be incompatible with certain server applications (such
as those for ordering merchandise), the protocol requires that
transparency be relaxed</p>
<p>o  only by an explicit protocol-level request when relaxed by client
or origin server</p>
<p>o  only with an explicit warning to the end user when relaxed by cache
or client</p>
<p>Fielding, et. al.           Standards Track                    [Page 71]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Therefore, the HTTP/1.1 protocol provides these important elements:</p>
<ol>
<li>
<p>Protocol features that provide full semantic transparency when this
is required by all parties.</p>
</li>
<li>
<p>Protocol features that allow an origin server or user agent to
explicitly request and control non-transparent operation.</p>
</li>
<li>
<p>Protocol features that allow a cache to attach warnings to
responses that do not preserve the requested approximation of
semantic transparency.</p>
</li>
</ol>
<p>A basic principle is that it must be possible for the clients to
detect any potential relaxation of semantic transparency.</p>
<pre><code> Note: The server, cache, or client implementer may be faced with
 design decisions not explicitly discussed in this specification. If
 a decision may affect semantic transparency, the implementer ought
 to err on the side of maintaining transparency unless a careful and
 complete analysis shows significant benefits in breaking
 transparency.
</code></pre>
<p>13.1.1 Cache Correctness</p>
<p>A correct cache MUST respond to a request with the most up-to-date
response held by the cache that is appropriate to the request (see
sections 13.2.5, 13.2.6, and 13.12) which meets one of the following
conditions:</p>
<ol>
<li>
<p>It has been checked for equivalence with what the origin server
would have returned by revalidating the response with the origin
server (section 13.3);</p>
</li>
<li>
<p>It is &ldquo;fresh enough&rdquo; (see section 13.2). In the default case, this
means it meets the least restrictive freshness requirement of the
client, server, and cache (see section 14.9); if the origin server
so specifies, it is the freshness requirement of the origin server
alone.</p>
</li>
<li>
<p>It includes a warning if the freshness demand of the client or the
origin server is violated (see section 13.1.5 and 14.45).</p>
</li>
<li>
<p>It is an appropriate 304 (Not Modified), 305 (Proxy Redirect), or
error (4xx or 5xx) response message.</p>
</li>
</ol>
<p>If the cache can not communicate with the origin server, then a
correct cache SHOULD respond as above if the response can be
correctly served from the cache; if not it MUST return an error or</p>
<p>Fielding, et. al.           Standards Track                    [Page 72]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>warning indicating that there was a communication failure.</p>
<p>If a cache receives a response (either an entire response, or a 304
(Not Modified) response) that it would normally forward to the
requesting client, and the received response is no longer fresh, the
cache SHOULD forward it to the requesting client without adding a new
Warning (but without removing any existing Warning headers). A cache
SHOULD NOT attempt to revalidate a response simply because that
response became stale in transit; this might lead to an infinite
loop. An user agent that receives a stale response without a Warning
MAY display a warning indication to the user.</p>
<p>13.1.2 Warnings</p>
<p>Whenever a cache returns a response that is neither first-hand nor
&ldquo;fresh enough&rdquo; (in the sense of condition 2 in section 13.1.1), it
must attach a warning to that effect, using a Warning response-
header. This warning allows clients to take appropriate action.</p>
<p>Warnings may be used for other purposes, both cache-related and
otherwise. The use of a warning, rather than an error status code,
distinguish these responses from true failures.</p>
<p>Warnings are always cachable, because they never weaken the
transparency of a response. This means that warnings can be passed to
HTTP/1.0 caches without danger; such caches will simply pass the
warning along as an entity-header in the response.</p>
<p>Warnings are assigned numbers between 0 and 99. This specification
defines the code numbers and meanings of each currently assigned
warnings, allowing a client or cache to take automated action in some
(but not all) cases.</p>
<p>Warnings also carry a warning text. The text may be in any
appropriate natural language (perhaps based on the client&rsquo;s Accept
headers), and include an optional indication of what character set is
used.</p>
<p>Multiple warnings may be attached to a response (either by the origin
server or by a cache), including multiple warnings with the same code
number. For example, a server may provide the same warning with texts
in both English and Basque.</p>
<p>When multiple warnings are attached to a response, it may not be
practical or reasonable to display all of them to the user. This
version of HTTP does not specify strict priority rules for deciding
which warnings to display and in what order, but does suggest some
heuristics.</p>
<p>Fielding, et. al.           Standards Track                    [Page 73]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The Warning header and the currently defined warnings are described
in section 14.45.</p>
<p>13.1.3 Cache-control Mechanisms</p>
<p>The basic cache mechanisms in HTTP/1.1 (server-specified expiration
times and validators) are implicit directives to caches. In some
cases, a server or client may need to provide explicit directives to
the HTTP caches. We use the Cache-Control header for this purpose.</p>
<p>The Cache-Control header allows a client or server to transmit a
variety of directives in either requests or responses. These
directives typically override the default caching algorithms. As a
general rule, if there is any apparent conflict between header
values, the most restrictive interpretation should be applied (that
is, the one that is most likely to preserve semantic transparency).
However, in some cases, Cache-Control directives are explicitly
specified as weakening the approximation of semantic transparency
(for example, &ldquo;max-stale&rdquo; or &ldquo;public&rdquo;).</p>
<p>The Cache-Control directives are described in detail in section 14.9.</p>
<p>13.1.4 Explicit User Agent Warnings</p>
<p>Many user agents make it possible for users to override the basic
caching mechanisms. For example, the user agent may allow the user to
specify that cached entities (even explicitly stale ones) are never
validated. Or the user agent might habitually add &ldquo;Cache-Control:
max-stale=3600&rdquo; to every request. The user should have to explicitly
request either non-transparent behavior, or behavior that results in
abnormally ineffective caching.</p>
<p>If the user has overridden the basic caching mechanisms, the user
agent should explicitly indicate to the user whenever this results in
the display of information that might not meet the server&rsquo;s
transparency requirements (in particular, if the displayed entity is
known to be stale). Since the protocol normally allows the user agent
to determine if responses are stale or not, this indication need only
be displayed when this actually happens. The indication need not be a
dialog box; it could be an icon (for example, a picture of a rotting
fish) or some other visual indicator.</p>
<p>If the user has overridden the caching mechanisms in a way that would
abnormally reduce the effectiveness of caches, the user agent should
continually display an indication (for example, a picture of currency
in flames) so that the user does not inadvertently consume excess
resources or suffer from excessive latency.</p>
<p>Fielding, et. al.           Standards Track                    [Page 74]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>13.1.5 Exceptions to the Rules and Warnings</p>
<p>In some cases, the operator of a cache may choose to configure it to
return stale responses even when not requested by clients. This
decision should not be made lightly, but may be necessary for reasons
of availability or performance, especially when the cache is poorly
connected to the origin server. Whenever a cache returns a stale
response, it MUST mark it as such (using a Warning header). This
allows the client software to alert the user that there may be a
potential problem.</p>
<p>It also allows the user agent to take steps to obtain a first-hand or
fresh response. For this reason, a cache SHOULD NOT return a stale
response if the client explicitly requests a first-hand or fresh one,
unless it is impossible to comply for technical or policy reasons.</p>
<p>13.1.6 Client-controlled Behavior</p>
<p>While the origin server (and to a lesser extent, intermediate caches,
by their contribution to the age of a response) are the primary
source of expiration information, in some cases the client may need
to control a cache&rsquo;s decision about whether to return a cached
response without validating it. Clients do this using several
directives of the Cache-Control header.</p>
<p>A client&rsquo;s request may specify the maximum age it is willing to
accept of an unvalidated response; specifying a value of zero forces
the cache(s) to revalidate all responses. A client may also specify
the minimum time remaining before a response expires. Both of these
options increase constraints on the behavior of caches, and so cannot
further relax the cache&rsquo;s approximation of semantic transparency.</p>
<p>A client may also specify that it will accept stale responses, up to
some maximum amount of staleness. This loosens the constraints on the
caches, and so may violate the origin server&rsquo;s specified constraints
on semantic transparency, but may be necessary to support
disconnected operation, or high availability in the face of poor
connectivity.</p>
<p>13.2 Expiration Model</p>
<p>13.2.1 Server-Specified Expiration</p>
<p>HTTP caching works best when caches can entirely avoid making
requests to the origin server. The primary mechanism for avoiding
requests is for an origin server to provide an explicit expiration
time in the future, indicating that a response may be used to satisfy
subsequent requests.  In other words, a cache can return a fresh</p>
<p>Fielding, et. al.           Standards Track                    [Page 75]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>response without first contacting the server.</p>
<p>Our expectation is that servers will assign future explicit
expiration times to responses in the belief that the entity is not
likely to change, in a semantically significant way, before the
expiration time is reached. This normally preserves semantic
transparency, as long as the server&rsquo;s expiration times are carefully
chosen.</p>
<p>The expiration mechanism applies only to responses taken from a cache
and not to first-hand responses forwarded immediately to the
requesting client.</p>
<p>If an origin server wishes to force a semantically transparent cache
to validate every request, it may assign an explicit expiration time
in the past. This means that the response is always stale, and so the
cache SHOULD validate it before using it for subsequent requests. See
section 14.9.4 for a more restrictive way to force revalidation.</p>
<p>If an origin server wishes to force any HTTP/1.1 cache, no matter how
it is configured, to validate every request, it should use the
&ldquo;must-revalidate&rdquo; Cache-Control directive (see section 14.9).</p>
<p>Servers specify explicit expiration times using either the Expires
header, or the max-age directive of the Cache-Control header.</p>
<p>An expiration time cannot be used to force a user agent to refresh
its display or reload a resource; its semantics apply only to caching
mechanisms, and such mechanisms need only check a resource&rsquo;s
expiration status when a new request for that resource is initiated.
See section 13.13 for explanation of the difference between caches
and history mechanisms.</p>
<p>13.2.2 Heuristic Expiration</p>
<p>Since origin servers do not always provide explicit expiration times,
HTTP caches typically assign heuristic expiration times, employing
algorithms that use other header values (such as the Last-Modified
time) to estimate a plausible expiration time. The HTTP/1.1
specification does not provide specific algorithms, but does impose
worst-case constraints on their results. Since heuristic expiration
times may compromise semantic transparency, they should be used
cautiously, and we encourage origin servers to provide explicit
expiration times as much as possible.</p>
<p>Fielding, et. al.           Standards Track                    [Page 76]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>13.2.3 Age Calculations</p>
<p>In order to know if a cached entry is fresh, a cache needs to know if
its age exceeds its freshness lifetime. We discuss how to calculate
the latter in section 13.2.4; this section describes how to calculate
the age of a response or cache entry.</p>
<p>In this discussion, we use the term &ldquo;now&rdquo; to mean &ldquo;the current value
of the clock at the host performing the calculation.&rdquo; Hosts that use
HTTP, but especially hosts running origin servers and caches, should
use NTP [28] or some similar protocol to synchronize their clocks to
a globally accurate time standard.</p>
<p>Also note that HTTP/1.1 requires origin servers to send a Date header
with every response, giving the time at which the response was
generated. We use the term &ldquo;date_value&rdquo; to denote the value of the
Date header, in a form appropriate for arithmetic operations.</p>
<p>HTTP/1.1 uses the Age response-header to help convey age information
between caches. The Age header value is the sender&rsquo;s estimate of the
amount of time since the response was generated at the origin server.
In the case of a cached response that has been revalidated with the
origin server, the Age value is based on the time of revalidation,
not of the original response.</p>
<p>In essence, the Age value is the sum of the time that the response
has been resident in each of the caches along the path from the
origin server, plus the amount of time it has been in transit along
network paths.</p>
<p>We use the term &ldquo;age_value&rdquo; to denote the value of the Age header, in
a form appropriate for arithmetic operations.</p>
<p>A response&rsquo;s age can be calculated in two entirely independent ways:</p>
<pre><code> 1. now minus date_value, if the local clock is reasonably well
    synchronized to the origin server's clock. If the result is
    negative, the result is replaced by zero.

 2. age_value, if all of the caches along the response path
    implement HTTP/1.1.
</code></pre>
<p>Given that we have two independent ways to compute the age of a
response when it is received, we can combine these as</p>
<pre><code>      corrected_received_age = max(now - date_value, age_value)
</code></pre>
<p>and as long as we have either nearly synchronized clocks or all-</p>
<p>Fielding, et. al.           Standards Track                    [Page 77]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>HTTP/1.1 paths, one gets a reliable (conservative) result.</p>
<p>Note that this correction is applied at each HTTP/1.1 cache along the
path, so that if there is an HTTP/1.0 cache in the path, the correct
received age is computed as long as the receiving cache&rsquo;s clock is
nearly in sync. We don&rsquo;t need end-to-end clock synchronization
(although it is good to have), and there is no explicit clock
synchronization step.</p>
<p>Because of network-imposed delays, some significant interval may pass
from the time that a server generates a response and the time it is
received at the next outbound cache or client. If uncorrected, this
delay could result in improperly low ages.</p>
<p>Because the request that resulted in the returned Age value must have
been initiated prior to that Age value&rsquo;s generation, we can correct
for delays imposed by the network by recording the time at which the
request was initiated. Then, when an Age value is received, it MUST
be interpreted relative to the time the request was initiated, not
the time that the response was received. This algorithm results in
conservative behavior no matter how much delay is experienced. So, we
compute:</p>
<pre><code>     corrected_initial_age = corrected_received_age
                           + (now - request_time)
</code></pre>
<p>where &ldquo;request_time&rdquo; is the time (according to the local clock) when
the request that elicited this response was sent.</p>
<p>Summary of age calculation algorithm, when a cache receives a
response:</p>
<pre><code>  /*
   * age_value
   *      is the value of Age: header received by the cache with
   *              this response.
   * date_value
   *      is the value of the origin server's Date: header
   * request_time
   *      is the (local) time when the cache made the request
   *              that resulted in this cached response
   * response_time
   *      is the (local) time when the cache received the
   *              response
   * now
   *      is the current (local) time
   */
  apparent_age = max(0, response_time - date_value);
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 78]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>  corrected_received_age = max(apparent_age, age_value);
  response_delay = response_time - request_time;
  corrected_initial_age = corrected_received_age + response_delay;
  resident_time = now - response_time;
  current_age   = corrected_initial_age + resident_time;
</code></pre>
<p>When a cache sends a response, it must add to the
corrected_initial_age the amount of time that the response was
resident locally. It must then transmit this total age, using the Age
header, to the next recipient cache.</p>
<pre><code> Note that a client cannot reliably tell that a response is first-
 hand, but the presence of an Age header indicates that a response
 is definitely not first-hand. Also, if the Date in a response is
 earlier than the client's local request time, the response is
 probably not first-hand (in the absence of serious clock skew).
</code></pre>
<p>13.2.4 Expiration Calculations</p>
<p>In order to decide whether a response is fresh or stale, we need to
compare its freshness lifetime to its age. The age is calculated as
described in section 13.2.3; this section describes how to calculate
the freshness lifetime, and to determine if a response has expired.
In the discussion below, the values can be represented in any form
appropriate for arithmetic operations.</p>
<p>We use the term &ldquo;expires_value&rdquo; to denote the value of the Expires
header. We use the term &ldquo;max_age_value&rdquo; to denote an appropriate
value of the number of seconds carried by the max-age directive of
the Cache-Control header in a response (see section 14.10.</p>
<p>The max-age directive takes priority over Expires, so if max-age is
present in a response, the calculation is simply:</p>
<pre><code>     freshness_lifetime = max_age_value
</code></pre>
<p>Otherwise, if Expires is present in the response, the calculation is:</p>
<pre><code>     freshness_lifetime = expires_value - date_value
</code></pre>
<p>Note that neither of these calculations is vulnerable to clock skew,
since all of the information comes from the origin server.</p>
<p>If neither Expires nor Cache-Control: max-age appears in the
response, and the response does not include other restrictions on
caching, the cache MAY compute a freshness lifetime using a
heuristic. If the value is greater than 24 hours, the cache must
attach Warning 13 to any response whose age is more than 24 hours if</p>
<p>Fielding, et. al.           Standards Track                    [Page 79]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>such warning has not already been added.</p>
<p>Also, if the response does have a Last-Modified time, the heuristic
expiration value SHOULD be no more than some fraction of the interval
since that time. A typical setting of this fraction might be 10%.</p>
<p>The calculation to determine if a response has expired is quite
simple:</p>
<pre><code>     response_is_fresh = (freshness_lifetime &gt; current_age)
</code></pre>
<p>13.2.5 Disambiguating Expiration Values</p>
<p>Because expiration values are assigned optimistically, it is possible
for two caches to contain fresh values for the same resource that are
different.</p>
<p>If a client performing a retrieval receives a non-first-hand response
for a request that was already fresh in its own cache, and the Date
header in its existing cache entry is newer than the Date on the new
response, then the client MAY ignore the response. If so, it MAY
retry the request with a &ldquo;Cache-Control: max-age=0&rdquo; directive (see
section 14.9), to force a check with the origin server.</p>
<p>If a cache has two fresh responses for the same representation with
different validators, it MUST use the one with the more recent Date
header. This situation may arise because the cache is pooling
responses from other caches, or because a client has asked for a
reload or a revalidation of an apparently fresh cache entry.</p>
<p>13.2.6 Disambiguating Multiple Responses</p>
<p>Because a client may be receiving responses via multiple paths, so
that some responses flow through one set of caches and other
responses flow through a different set of caches, a client may
receive responses in an order different from that in which the origin
server sent them. We would like the client to use the most recently
generated response, even if older responses are still apparently
fresh.</p>
<p>Neither the entity tag nor the expiration value can impose an
ordering on responses, since it is possible that a later response
intentionally carries an earlier expiration time. However, the
HTTP/1.1 specification requires the transmission of Date headers on
every response, and the Date values are ordered to a granularity of
one second.</p>
<p>Fielding, et. al.           Standards Track                    [Page 80]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>When a client tries to revalidate a cache entry, and the response it
receives contains a Date header that appears to be older than the one
for the existing entry, then the client SHOULD repeat the request
unconditionally, and include</p>
<pre><code>      Cache-Control: max-age=0
</code></pre>
<p>to force any intermediate caches to validate their copies directly
with the origin server, or</p>
<pre><code>      Cache-Control: no-cache
</code></pre>
<p>to force any intermediate caches to obtain a new copy from the origin
server.</p>
<p>If the Date values are equal, then the client may use either response
(or may, if it is being extremely prudent, request a new response).
Servers MUST NOT depend on clients being able to choose
deterministically between responses generated during the same second,
if their expiration times overlap.</p>
<p>13.3 Validation Model</p>
<p>When a cache has a stale entry that it would like to use as a
response to a client&rsquo;s request, it first has to check with the origin
server (or possibly an intermediate cache with a fresh response) to
see if its cached entry is still usable. We call this &ldquo;validating&rdquo;
the cache entry.  Since we do not want to have to pay the overhead of
retransmitting the full response if the cached entry is good, and we
do not want to pay the overhead of an extra round trip if the cached
entry is invalid, the HTTP/1.1 protocol supports the use of
conditional methods.</p>
<p>The key protocol features for supporting conditional methods are
those concerned with &ldquo;cache validators.&rdquo; When an origin server
generates a full response, it attaches some sort of validator to it,
which is kept with the cache entry. When a client (user agent or
proxy cache) makes a conditional request for a resource for which it
has a cache entry, it includes the associated validator in the
request.</p>
<p>The server then checks that validator against the current validator
for the entity, and, if they match, it responds with a special status
code (usually, 304 (Not Modified)) and no entity-body. Otherwise, it
returns a full response (including entity-body). Thus, we avoid
transmitting the full response if the validator matches, and we avoid
an extra round trip if it does not match.</p>
<p>Fielding, et. al.           Standards Track                    [Page 81]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> Note: the comparison functions used to decide if validators match
 are defined in section 13.3.3.
</code></pre>
<p>In HTTP/1.1, a conditional request looks exactly the same as a normal
request for the same resource, except that it carries a special
header (which includes the validator) that implicitly turns the
method (usually, GET) into a conditional.</p>
<p>The protocol includes both positive and negative senses of cache-
validating conditions. That is, it is possible to request either that
a method be performed if and only if a validator matches or if and
only if no validators match.</p>
<pre><code> Note: a response that lacks a validator may still be cached, and
 served from cache until it expires, unless this is explicitly
 prohibited by a Cache-Control directive. However, a cache cannot do
 a conditional retrieval if it does not have a validator for the
 entity, which means it will not be refreshable after it expires.
</code></pre>
<p>13.3.1 Last-modified Dates</p>
<p>The Last-Modified entity-header field value is often used as a cache
validator. In simple terms, a cache entry is considered to be valid
if the entity has not been modified since the Last-Modified value.</p>
<p>13.3.2 Entity Tag Cache Validators</p>
<p>The ETag entity-header field value, an entity tag, provides for an
&ldquo;opaque&rdquo; cache validator. This may allow more reliable validation in
situations where it is inconvenient to store modification dates,
where the one-second resolution of HTTP date values is not
sufficient, or where the origin server wishes to avoid certain
paradoxes that may arise from the use of modification dates.</p>
<p>Entity Tags are described in section 3.11. The headers used with
entity tags are described in sections 14.20, 14.25, 14.26 and 14.43.</p>
<p>13.3.3 Weak and Strong Validators</p>
<p>Since both origin servers and caches will compare two validators to
decide if they represent the same or different entities, one normally
would expect that if the entity (the entity-body or any entity-
headers) changes in any way, then the associated validator would
change as well.  If this is true, then we call this validator a
&ldquo;strong validator.&rdquo;</p>
<p>However, there may be cases when a server prefers to change the
validator only on semantically significant changes, and not when</p>
<p>Fielding, et. al.           Standards Track                    [Page 82]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>insignificant aspects of the entity change. A validator that does not
always change when the resource changes is a &ldquo;weak validator.&rdquo;</p>
<p>Entity tags are normally &ldquo;strong validators,&rdquo; but the protocol
provides a mechanism to tag an entity tag as &ldquo;weak.&rdquo; One can think of
a strong validator as one that changes whenever the bits of an entity
changes, while a weak value changes whenever the meaning of an entity
changes.  Alternatively, one can think of a strong validator as part
of an identifier for a specific entity, while a weak validator is
part of an identifier for a set of semantically equivalent entities.</p>
<pre><code> Note: One example of a strong validator is an integer that is
 incremented in stable storage every time an entity is changed.

 An entity's modification time, if represented with one-second
 resolution, could be a weak validator, since it is possible that
 the resource may be modified twice during a single second.

 Support for weak validators is optional; however, weak validators
 allow for more efficient caching of equivalent objects; for
 example, a hit counter on a site is probably good enough if it is
 updated every few days or weeks, and any value during that period
 is likely &quot;good enough&quot; to be equivalent.

 A &quot;use&quot; of a validator is either when a client generates a request
 and includes the validator in a validating header field, or when a
 server compares two validators.
</code></pre>
<p>Strong validators are usable in any context. Weak validators are only
usable in contexts that do not depend on exact equality of an entity.
For example, either kind is usable for a conditional GET of a full
entity. However, only a strong validator is usable for a sub-range
retrieval, since otherwise the client may end up with an internally
inconsistent entity.</p>
<p>The only function that the HTTP/1.1 protocol defines on validators is
comparison. There are two validator comparison functions, depending
on whether the comparison context allows the use of weak validators
or not:</p>
<p>o  The strong comparison function: in order to be considered equal,
both validators must be identical in every way, and neither may be
weak.
o  The weak comparison function: in order to be considered equal, both
validators must be identical in every way, but either or both of
them may be tagged as &ldquo;weak&rdquo; without affecting the result.</p>
<p>The weak comparison function MAY be used for simple (non-subrange)</p>
<p>Fielding, et. al.           Standards Track                    [Page 83]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>GET requests. The strong comparison function MUST be used in all
other cases.</p>
<p>An entity tag is strong unless it is explicitly tagged as weak.
Section 3.11 gives the syntax for entity tags.</p>
<p>A Last-Modified time, when used as a validator in a request, is
implicitly weak unless it is possible to deduce that it is strong,
using the following rules:</p>
<p>o  The validator is being compared by an origin server to the actual
current validator for the entity and,
o  That origin server reliably knows that the associated entity did
not change twice during the second covered by the presented
validator.
or</p>
<p>o  The validator is about to be used by a client in an If-Modified-
Since or If-Unmodified-Since header, because the client has a cache
entry for the associated entity, and
o  That cache entry includes a Date value, which gives the time when
the origin server sent the original response, and
o  The presented Last-Modified time is at least 60 seconds before the
Date value.
or</p>
<p>o  The validator is being compared by an intermediate cache to the
validator stored in its cache entry for the entity, and
o  That cache entry includes a Date value, which gives the time when
the origin server sent the original response, and
o  The presented Last-Modified time is at least 60 seconds before the
Date value.</p>
<p>This method relies on the fact that if two different responses were
sent by the origin server during the same second, but both had the
same Last-Modified time, then at least one of those responses would
have a Date value equal to its Last-Modified time. The arbitrary 60-
second limit guards against the possibility that the Date and Last-
Modified values are generated from different clocks, or at somewhat
different times during the preparation of the response. An
implementation may use a value larger than 60 seconds, if it is
believed that 60 seconds is too short.</p>
<p>If a client wishes to perform a sub-range retrieval on a value for
which it has only a Last-Modified time and no opaque validator, it
may do this only if the Last-Modified time is strong in the sense
described here.</p>
<p>Fielding, et. al.           Standards Track                    [Page 84]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>A cache or origin server receiving a cache-conditional request, other
than a full-body GET request, MUST use the strong comparison function
to evaluate the condition.</p>
<p>These rules allow HTTP/1.1 caches and clients to safely perform sub-
range retrievals on values that have been obtained from HTTP/1.0
servers.</p>
<p>13.3.4 Rules for When to Use Entity Tags and Last-modified Dates</p>
<p>We adopt a set of rules and recommendations for origin servers,
clients, and caches regarding when various validator types should be
used, and for what purposes.</p>
<p>HTTP/1.1 origin servers:</p>
<p>o  SHOULD send an entity tag validator unless it is not feasible to
generate one.
o  MAY send a weak entity tag instead of a strong entity tag, if
performance considerations support the use of weak entity tags, or
if it is unfeasible to send a strong entity tag.
o  SHOULD send a Last-Modified value if it is feasible to send one,
unless the risk of a breakdown in semantic transparency that could
result from using this date in an If-Modified-Since header would
lead to serious problems.</p>
<p>In other words, the preferred behavior for an HTTP/1.1 origin server
is to send both a strong entity tag and a Last-Modified value.</p>
<p>In order to be legal, a strong entity tag MUST change whenever the
associated entity value changes in any way. A weak entity tag SHOULD
change whenever the associated entity changes in a semantically
significant way.</p>
<pre><code> Note: in order to provide semantically transparent caching, an
 origin server must avoid reusing a specific strong entity tag value
 for two different entities, or reusing a specific weak entity tag
 value for two semantically different entities. Cache entries may
 persist for arbitrarily long periods, regardless of expiration
 times, so it may be inappropriate to expect that a cache will never
 again attempt to validate an entry using a validator that it
 obtained at some point in the past.
</code></pre>
<p>HTTP/1.1 clients:</p>
<pre><code> o  If an entity tag has been provided by the origin server, MUST
    use that entity tag in any cache-conditional request (using
    If-Match or If-None-Match).
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 85]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> o  If only a Last-Modified value has been provided by the origin
    server, SHOULD use that value in non-subrange cache-conditional
    requests (using If-Modified-Since).
 o  If only a Last-Modified value has been provided by an HTTP/1.0
    origin server, MAY use that value in subrange cache-conditional
    requests (using If-Unmodified-Since:). The user agent should
    provide a way to disable this, in case of difficulty.
 o  If both an entity tag and a Last-Modified value have been
    provided by the origin server, SHOULD use both validators in
    cache-conditional requests. This allows both HTTP/1.0 and
    HTTP/1.1 caches to respond appropriately.
</code></pre>
<p>An HTTP/1.1 cache, upon receiving a request, MUST use the most
restrictive validator when deciding whether the client&rsquo;s cache entry
matches the cache&rsquo;s own cache entry. This is only an issue when the
request contains both an entity tag and a last-modified-date
validator (If-Modified-Since or If-Unmodified-Since).</p>
<pre><code> A note on rationale: The general principle behind these rules is
 that HTTP/1.1 servers and clients should transmit as much non-
 redundant information as is available in their responses and
 requests. HTTP/1.1 systems receiving this information will make the
 most conservative assumptions about the validators they receive.

 HTTP/1.0 clients and caches will ignore entity tags. Generally,
 last-modified values received or used by these systems will support
 transparent and efficient caching, and so HTTP/1.1 origin servers
 should provide Last-Modified values. In those rare cases where the
 use of a Last-Modified value as a validator by an HTTP/1.0 system
 could result in a serious problem, then HTTP/1.1 origin servers
 should not provide one.
</code></pre>
<p>13.3.5 Non-validating Conditionals</p>
<p>The principle behind entity tags is that only the service author
knows the semantics of a resource well enough to select an
appropriate cache validation mechanism, and the specification of any
validator comparison function more complex than byte-equality would
open up a can of worms.  Thus, comparisons of any other headers
(except Last-Modified, for compatibility with HTTP/1.0) are never
used for purposes of validating a cache entry.</p>
<p>13.4 Response Cachability</p>
<p>Unless specifically constrained by a Cache-Control (section 14.9)
directive, a caching system may always store a successful response
(see section 13.8) as a cache entry, may return it without validation
if it is fresh, and may return it after successful validation. If</p>
<p>Fielding, et. al.           Standards Track                    [Page 86]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>there is neither a cache validator nor an explicit expiration time
associated with a response, we do not expect it to be cached, but
certain caches may violate this expectation (for example, when little
or no network connectivity is available). A client can usually detect
that such a response was taken from a cache by comparing the Date
header to the current time.</p>
<pre><code> Note that some HTTP/1.0 caches are known to violate this
 expectation without providing any Warning.
</code></pre>
<p>However, in some cases it may be inappropriate for a cache to retain
an entity, or to return it in response to a subsequent request. This
may be because absolute semantic transparency is deemed necessary by
the service author, or because of security or privacy considerations.
Certain Cache-Control directives are therefore provided so that the
server can indicate that certain resource entities, or portions
thereof, may not be cached regardless of other considerations.</p>
<p>Note that section 14.8 normally prevents a shared cache from saving
and returning a response to a previous request if that request
included an Authorization header.</p>
<p>A response received with a status code of 200, 203, 206, 300, 301 or
410 may be stored by a cache and used in reply to a subsequent
request, subject to the expiration mechanism, unless a Cache-Control
directive prohibits caching. However, a cache that does not support
the Range and Content-Range headers MUST NOT cache 206 (Partial
Content) responses.</p>
<p>A response received with any other status code MUST NOT be returned
in a reply to a subsequent request unless there are Cache-Control
directives or another header(s) that explicitly allow it. For
example, these include the following: an Expires header (section
14.21); a &ldquo;max-age&rdquo;, &ldquo;must-revalidate&rdquo;, &ldquo;proxy-revalidate&rdquo;, &ldquo;public&rdquo;
or &ldquo;private&rdquo; Cache-Control directive (section 14.9).</p>
<p>13.5 Constructing Responses From Caches</p>
<p>The purpose of an HTTP cache is to store information received in
response to requests, for use in responding to future requests. In
many cases, a cache simply returns the appropriate parts of a
response to the requester. However, if the cache holds a cache entry
based on a previous response, it may have to combine parts of a new
response with what is held in the cache entry.</p>
<p>Fielding, et. al.           Standards Track                    [Page 87]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>13.5.1 End-to-end and Hop-by-hop Headers</p>
<p>For the purpose of defining the behavior of caches and non-caching
proxies, we divide HTTP headers into two categories:</p>
<p>o  End-to-end headers, which must be transmitted to the
ultimate recipient of a request or response. End-to-end
headers in responses must be stored as part of a cache entry
and transmitted in any response formed from a cache entry.
o  Hop-by-hop headers, which are meaningful only for a single
transport-level connection, and are not stored by caches or
forwarded by proxies.</p>
<p>The following HTTP/1.1 headers are hop-by-hop headers:</p>
<pre><code> o  Connection
 o  Keep-Alive
 o  Public
 o  Proxy-Authenticate
 o  Transfer-Encoding
 o  Upgrade
</code></pre>
<p>All other headers defined by HTTP/1.1 are end-to-end headers.</p>
<p>Hop-by-hop headers introduced in future versions of HTTP MUST be
listed in a Connection header, as described in section 14.10.</p>
<p>13.5.2 Non-modifiable Headers</p>
<p>Some features of the HTTP/1.1 protocol, such as Digest
Authentication, depend on the value of certain end-to-end headers. A
cache or non-caching proxy SHOULD NOT modify an end-to-end header
unless the definition of that header requires or specifically allows
that.</p>
<p>A cache or non-caching proxy MUST NOT modify any of the following
fields in a request or response, nor may it add any of these fields
if not already present:</p>
<pre><code> o  Content-Location
 o  ETag
 o  Expires
 o  Last-Modified
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 88]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>A cache or non-caching proxy MUST NOT modify or add any of the
following fields in a response that contains the no-transform Cache-
Control directive, or in any request:</p>
<pre><code> o  Content-Encoding
 o  Content-Length
 o  Content-Range
 o  Content-Type
</code></pre>
<p>A cache or non-caching proxy MAY modify or add these fields in a
response that does not include no-transform, but if it does so, it
MUST add a Warning 14 (Transformation applied) if one does not
already appear in the response.</p>
<pre><code> Warning: unnecessary modification of end-to-end headers may cause
 authentication failures if stronger authentication mechanisms are
 introduced in later versions of HTTP. Such authentication
 mechanisms may rely on the values of header fields not listed here.
</code></pre>
<p>13.5.3 Combining Headers</p>
<p>When a cache makes a validating request to a server, and the server
provides a 304 (Not Modified) response, the cache must construct a
response to send to the requesting client. The cache uses the
entity-body stored in the cache entry as the entity-body of this
outgoing response. The end-to-end headers stored in the cache entry
are used for the constructed response, except that any end-to-end
headers provided in the 304 response MUST replace the corresponding
headers from the cache entry. Unless the cache decides to remove the
cache entry, it MUST also replace the end-to-end headers stored with
the cache entry with corresponding headers received in the incoming
response.</p>
<p>In other words, the set of end-to-end headers received in the
incoming response overrides all corresponding end-to-end headers
stored with the cache entry. The cache may add Warning headers (see
section 14.45) to this set.</p>
<p>If a header field-name in the incoming response matches more than one
header in the cache entry, all such old headers are replaced.</p>
<pre><code> Note: this rule allows an origin server to use a 304 (Not Modified)
 response to update any header associated with a previous response
 for the same entity, although it might not always be meaningful or
 correct to do so. This rule does not allow an origin server to use
 a 304 (not Modified) response to entirely delete a header that it
 had provided with a previous response.
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 89]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>13.5.4 Combining Byte Ranges</p>
<p>A response may transfer only a subrange of the bytes of an entity-
body, either because the request included one or more Range
specifications, or because a connection was broken prematurely. After
several such transfers, a cache may have received several ranges of
the same entity-body.</p>
<p>If a cache has a stored non-empty set of subranges for an entity, and
an incoming response transfers another subrange, the cache MAY
combine the new subrange with the existing set if both the following
conditions are met:</p>
<pre><code> o  Both the incoming response and the cache entry must have a cache
    validator.
 o  The two cache validators must match using the strong comparison
    function (see section 13.3.3).
</code></pre>
<p>If either requirement is not meant, the cache must use only the most
recent partial response (based on the Date values transmitted with
every response, and using the incoming response if these values are
equal or missing), and must discard the other partial information.</p>
<p>13.6 Caching Negotiated Responses</p>
<p>Use of server-driven content negotiation (section 12), as indicated
by the presence of a Vary header field in a response, alters the
conditions and procedure by which a cache can use the response for
subsequent requests.</p>
<p>A server MUST use the Vary header field (section 14.43) to inform a
cache of what header field dimensions are used to select among
multiple representations of a cachable response. A cache may use the
selected representation (the entity included with that particular
response) for replying to subsequent requests on that resource only
when the subsequent requests have the same or equivalent values for
all header fields specified in the Vary response-header. Requests
with a different value for one or more of those header fields would
be forwarded toward the origin server.</p>
<p>If an entity tag was assigned to the representation, the forwarded
request SHOULD be conditional and include the entity tags in an If-
None-Match header field from all its cache entries for the Request-
URI. This conveys to the server the set of entities currently held by
the cache, so that if any one of these entities matches the requested
entity, the server can use the ETag header in its 304 (Not Modified)
response to tell the cache which entry is appropriate. If the
entity-tag of the new response matches that of an existing entry, the</p>
<p>Fielding, et. al.           Standards Track                    [Page 90]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>new response SHOULD be used to update the header fields of the
existing entry, and the result MUST be returned to the client.</p>
<p>The Vary header field may also inform the cache that the
representation was selected using criteria not limited to the
request-headers; in this case, a cache MUST NOT use the response in a
reply to a subsequent request unless the cache relays the new request
to the origin server in a conditional request and the server responds
with 304 (Not Modified), including an entity tag or Content-Location
that indicates which entity should be used.</p>
<p>If any of the existing cache entries contains only partial content
for the associated entity, its entity-tag SHOULD NOT be included in
the If-None-Match header unless the request is for a range that would
be fully satisfied by that entry.</p>
<p>If a cache receives a successful response whose Content-Location
field matches that of an existing cache entry for the same Request-
URI, whose entity-tag differs from that of the existing entry, and
whose Date is more recent than that of the existing entry, the
existing entry SHOULD NOT be returned in response to future requests,
and should be deleted from the cache.</p>
<p>13.7 Shared and Non-Shared Caches</p>
<p>For reasons of security and privacy, it is necessary to make a
distinction between &ldquo;shared&rdquo; and &ldquo;non-shared&rdquo; caches. A non-shared
cache is one that is accessible only to a single user. Accessibility
in this case SHOULD be enforced by appropriate security mechanisms.
All other caches are considered to be &ldquo;shared.&rdquo; Other sections of
this specification place certain constraints on the operation of
shared caches in order to prevent loss of privacy or failure of
access controls.</p>
<p>13.8 Errors or Incomplete Response Cache Behavior</p>
<p>A cache that receives an incomplete response (for example, with fewer
bytes of data than specified in a Content-Length header) may store
the response. However, the cache MUST treat this as a partial
response.  Partial responses may be combined as described in section
13.5.4; the result might be a full response or might still be
partial. A cache MUST NOT return a partial response to a client
without explicitly marking it as such, using the 206 (Partial
Content) status code. A cache MUST NOT return a partial response
using a status code of 200 (OK).</p>
<p>If a cache receives a 5xx response while attempting to revalidate an
entry, it may either forward this response to the requesting client,</p>
<p>Fielding, et. al.           Standards Track                    [Page 91]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>or act as if the server failed to respond. In the latter case, it MAY
return a previously received response unless the cached entry
includes the &ldquo;must-revalidate&rdquo; Cache-Control directive (see section
14.9).</p>
<p>13.9 Side Effects of GET and HEAD</p>
<p>Unless the origin server explicitly prohibits the caching of their
responses, the application of GET and HEAD methods to any resources
SHOULD NOT have side effects that would lead to erroneous behavior if
these responses are taken from a cache. They may still have side
effects, but a cache is not required to consider such side effects in
its caching decisions. Caches are always expected to observe an
origin server&rsquo;s explicit restrictions on caching.</p>
<p>We note one exception to this rule: since some applications have
traditionally used GETs and HEADs with query URLs (those containing a
&ldquo;?&rdquo; in the rel_path part) to perform operations with significant side
effects, caches MUST NOT treat responses to such URLs as fresh unless
the server provides an explicit expiration time. This specifically
means that responses from HTTP/1.0 servers for such URIs should not
be taken from a cache. See section 9.1.1 for related information.</p>
<p>13.10 Invalidation After Updates or Deletions</p>
<p>The effect of certain methods at the origin server may cause one or
more existing cache entries to become non-transparently invalid. That
is, although they may continue to be &ldquo;fresh,&rdquo; they do not accurately
reflect what the origin server would return for a new request.</p>
<p>There is no way for the HTTP protocol to guarantee that all such
cache entries are marked invalid. For example, the request that
caused the change at the origin server may not have gone through the
proxy where a cache entry is stored. However, several rules help
reduce the likelihood of erroneous behavior.</p>
<p>In this section, the phrase &ldquo;invalidate an entity&rdquo; means that the
cache should either remove all instances of that entity from its
storage, or should mark these as &ldquo;invalid&rdquo; and in need of a mandatory
revalidation before they can be returned in response to a subsequent
request.</p>
<p>Fielding, et. al.           Standards Track                    [Page 92]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Some HTTP methods may invalidate an entity. This is either the entity
referred to by the Request-URI, or by the Location or Content-
Location response-headers (if present). These methods are:</p>
<pre><code> o  PUT
 o  DELETE
 o  POST
</code></pre>
<p>In order to prevent denial of service attacks, an invalidation based
on the URI in a Location or Content-Location header MUST only be
performed if the host part is the same as in the Request-URI.</p>
<p>13.11 Write-Through Mandatory</p>
<p>All methods that may be expected to cause modifications to the origin
server&rsquo;s resources MUST be written through to the origin server. This
currently includes all methods except for GET and HEAD. A cache MUST
NOT reply to such a request from a client before having transmitted
the request to the inbound server, and having received a
corresponding response from the inbound server. This does not prevent
a cache from sending a 100 (Continue) response before the inbound
server has replied.</p>
<p>The alternative (known as &ldquo;write-back&rdquo; or &ldquo;copy-back&rdquo; caching) is not
allowed in HTTP/1.1, due to the difficulty of providing consistent
updates and the problems arising from server, cache, or network
failure prior to write-back.</p>
<p>13.12 Cache Replacement</p>
<p>If a new cachable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8)
response is received from a resource while any existing responses for
the same resource are cached, the cache SHOULD use the new response
to reply to the current request. It may insert it into cache storage
and may, if it meets all other requirements, use it to respond to any
future requests that would previously have caused the old response to
be returned. If it inserts the new response into cache storage it
should follow the rules in section 13.5.3.</p>
<pre><code> Note: a new response that has an older Date header value than
 existing cached responses is not cachable.
</code></pre>
<p>13.13 History Lists</p>
<p>User agents often have history mechanisms, such as &ldquo;Back&rdquo; buttons and
history lists, which can be used to redisplay an entity retrieved
earlier in a session.</p>
<p>Fielding, et. al.           Standards Track                    [Page 93]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>History mechanisms and caches are different. In particular history
mechanisms SHOULD NOT try to show a semantically transparent view of
the current state of a resource. Rather, a history mechanism is meant
to show exactly what the user saw at the time when the resource was
retrieved.</p>
<p>By default, an expiration time does not apply to history mechanisms.
If the entity is still in storage, a history mechanism should display
it even if the entity has expired, unless the user has specifically
configured the agent to refresh expired history documents.</p>
<p>This should not be construed to prohibit the history mechanism from
telling the user that a view may be stale.</p>
<pre><code> Note: if history list mechanisms unnecessarily prevent users from
 viewing stale resources, this will tend to force service authors to
 avoid using HTTP expiration controls and cache controls when they
 would otherwise like to. Service authors may consider it important
 that users not be presented with error messages or warning messages
 when they use navigation controls (such as BACK) to view previously
 fetched resources. Even though sometimes such resources ought not
 to cached, or ought to expire quickly, user interface
 considerations may force service authors to resort to other means
 of preventing caching (e.g. &quot;once-only&quot; URLs) in order not to
 suffer the effects of improperly functioning history mechanisms.
</code></pre>
<p>14 Header Field Definitions</p>
<p>This section defines the syntax and semantics of all standard
HTTP/1.1 header fields. For entity-header fields, both sender and
recipient refer to either the client or the server, depending on who
sends and who receives the entity.</p>
<p>Fielding, et. al.           Standards Track                    [Page 94]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14.1 Accept</p>
<p>The Accept request-header field can be used to specify certain media
types which are acceptable for the response. Accept headers can be
used to indicate that the request is specifically limited to a small
set of desired types, as in the case of a request for an in-line
image.</p>
<pre><code>      Accept         = &quot;Accept&quot; &quot;:&quot;
                       #( media-range [ accept-params ] )

      media-range    = ( &quot;*/*&quot;
                       | ( type &quot;/&quot; &quot;*&quot; )
                       | ( type &quot;/&quot; subtype )
                       ) *( &quot;;&quot; parameter )

      accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )

      accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]
</code></pre>
<p>The asterisk &ldquo;<em>&rdquo; character is used to group media types into ranges,
with &ldquo;</em>/<em>&rdquo; indicating all media types and &ldquo;type/</em>&rdquo; indicating all
subtypes of that type. The media-range MAY include media type
parameters that are applicable to that range.</p>
<p>Each media-range MAY be followed by one or more accept-params,
beginning with the &ldquo;q&rdquo; parameter for indicating a relative quality
factor. The first &ldquo;q&rdquo; parameter (if any) separates the media-range
parameter(s) from the accept-params. Quality factors allow the user
or user agent to indicate the relative degree of preference for that
media-range, using the qvalue scale from 0 to 1 (section 3.9). The
default value is q=1.</p>
<pre><code> Note: Use of the &quot;q&quot; parameter name to separate media type
 parameters from Accept extension parameters is due to historical
 practice.  Although this prevents any media type parameter named
 &quot;q&quot; from being used with a media range, such an event is believed
 to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
 media type registry and the rare usage of any media type parameters
 in Accept. Future media types should be discouraged from
 registering any parameter named &quot;q&quot;.
</code></pre>
<p>The example</p>
<pre><code>      Accept: audio/*; q=0.2, audio/basic
</code></pre>
<p>SHOULD be interpreted as &ldquo;I prefer audio/basic, but send me any audio
type if it is the best available after an 80% mark-down in quality.&rdquo;</p>
<p>Fielding, et. al.           Standards Track                    [Page 95]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>If no Accept header field is present, then it is assumed that the
client accepts all media types. If an Accept header field is present,
and if the server cannot send a response which is acceptable
according to the combined Accept field value, then the server SHOULD
send a 406 (not acceptable) response.</p>
<p>A more elaborate example is</p>
<pre><code>      Accept: text/plain; q=0.5, text/html,
              text/x-dvi; q=0.8, text/x-c
</code></pre>
<p>Verbally, this would be interpreted as &ldquo;text/html and text/x-c are
the preferred media types, but if they do not exist, then send the
text/x-dvi entity, and if that does not exist, send the text/plain
entity.&rdquo;</p>
<p>Media ranges can be overridden by more specific media ranges or
specific media types. If more than one media range applies to a given
type, the most specific reference has precedence. For example,</p>
<pre><code>      Accept: text/*, text/html, text/html;level=1, */*
</code></pre>
<p>have the following precedence:</p>
<pre><code>      1) text/html;level=1
      2) text/html
      3) text/*
      4) */*
</code></pre>
<p>The media type quality factor associated with a given type is
determined by finding the media range with the highest precedence
which matches that type. For example,</p>
<pre><code>      Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
              text/html;level=2;q=0.4, */*;q=0.5
</code></pre>
<p>would cause the following values to be associated:</p>
<pre><code>      text/html;level=1         = 1
      text/html                 = 0.7
      text/plain                = 0.3
      image/jpeg                = 0.5
      text/html;level=2         = 0.4
      text/html;level=3         = 0.7

 Note: A user agent may be provided with a default set of quality
 values for certain media ranges. However, unless the user agent is
 a closed system which cannot interact with other rendering agents,
</code></pre>
<p>Fielding, et. al.           Standards Track                    [Page 96]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> this default set should be configurable by the user.
</code></pre>
<p>14.2 Accept-Charset</p>
<p>The Accept-Charset request-header field can be used to indicate what
character sets are acceptable for the response. This field allows
clients capable of understanding more comprehensive or special-
purpose character sets to signal that capability to a server which is
capable of representing documents in those character sets. The ISO-
8859-1 character set can be assumed to be acceptable to all user
agents.</p>
<pre><code>      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
                1#( charset [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
</code></pre>
<p>Character set values are described in section 3.4. Each charset may
be given an associated quality value which represents the user&rsquo;s
preference for that charset. The default value is q=1. An example is</p>
<pre><code>      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</code></pre>
<p>If no Accept-Charset header is present, the default is that any
character set is acceptable. If an Accept-Charset header is present,
and if the server cannot send a response which is acceptable
according to the Accept-Charset header, then the server SHOULD send
an error response with the 406 (not acceptable) status code, though
the sending of an unacceptable response is also allowed.</p>
<p>14.3 Accept-Encoding</p>
<p>The Accept-Encoding request-header field is similar to Accept, but
restricts the content-coding values (section 14.12) which are
acceptable in the response.</p>
<pre><code>      Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot;
                                #( content-coding )
</code></pre>
<p>An example of its use is</p>
<pre><code>      Accept-Encoding: compress, gzip
</code></pre>
<p>If no Accept-Encoding header is present in a request, the server MAY
assume that the client will accept any content coding. If an Accept-
Encoding header is present, and if the server cannot send a response
which is acceptable according to the Accept-Encoding header, then the
server SHOULD send an error response with the 406 (Not Acceptable)
status code.</p>
<p>Fielding, et. al.           Standards Track                    [Page 97]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>An empty Accept-Encoding value indicates none are acceptable.</p>
<p>14.4 Accept-Language</p>
<p>The Accept-Language request-header field is similar to Accept, but
restricts the set of natural languages that are preferred as a
response to the request.</p>
<pre><code>      Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                        1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )

      language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )
</code></pre>
<p>Each language-range MAY be given an associated quality value which
represents an estimate of the user&rsquo;s preference for the languages
specified by that range. The quality value defaults to &ldquo;q=1&rdquo;. For
example,</p>
<pre><code>      Accept-Language: da, en-gb;q=0.8, en;q=0.7
</code></pre>
<p>would mean: &ldquo;I prefer Danish, but will accept British English and
other types of English.&rdquo; A language-range matches a language-tag if
it exactly equals the tag, or if it exactly equals a prefix of the
tag such that the first tag character following the prefix is &ldquo;-&quot;.
The special range &ldquo;*&quot;, if present in the Accept-Language field,
matches every tag not matched by any other range present in the
Accept-Language field.</p>
<pre><code> Note: This use of a prefix matching rule does not imply that
 language tags are assigned to languages in such a way that it is
 always true that if a user understands a language with a certain
 tag, then this user will also understand all languages with tags
 for which this tag is a prefix. The prefix rule simply allows the
 use of prefix tags if this is the case.
</code></pre>
<p>The language quality factor assigned to a language-tag by the
Accept-Language field is the quality value of the longest language-
range in the field that matches the language-tag. If no language-
range in the field matches the tag, the language quality factor
assigned is 0. If no Accept-Language header is present in the
request, the server SHOULD assume that all languages are equally
acceptable. If an Accept-Language header is present, then all
languages which are assigned a quality factor greater than 0 are
acceptable.</p>
<p>It may be contrary to the privacy expectations of the user to send an
Accept-Language header with the complete linguistic preferences of
the user in every request. For a discussion of this issue, see</p>
<p>Fielding, et. al.           Standards Track                    [Page 98]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>section 15.7.</p>
<pre><code> Note: As intelligibility is highly dependent on the individual
 user, it is recommended that client applications make the choice of
 linguistic preference available to the user. If the choice is not
 made available, then the Accept-Language header field must not be
 given in the request.
</code></pre>
<p>14.5 Accept-Ranges</p>
<p>The Accept-Ranges response-header field allows the server to indicate
its acceptance of range requests for a resource:</p>
<pre><code>      Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges

      acceptable-ranges = 1#range-unit | &quot;none&quot;
</code></pre>
<p>Origin servers that accept byte-range requests MAY send</p>
<pre><code>      Accept-Ranges: bytes
</code></pre>
<p>but are not required to do so. Clients MAY generate byte-range
requests without having received this header for the resource
involved.</p>
<p>Servers that do not accept any kind of range request for a  resource
MAY send</p>
<pre><code>      Accept-Ranges: none
</code></pre>
<p>to advise the client not to attempt a range request.</p>
<p>14.6 Age</p>
<p>The Age response-header field conveys the sender&rsquo;s estimate of the
amount of time since the response (or its revalidation) was generated
at the origin server. A cached response is &ldquo;fresh&rdquo; if its age does
not exceed its freshness lifetime. Age values are calculated as
specified in section 13.2.3.</p>
<pre><code>       Age = &quot;Age&quot; &quot;:&quot; age-value

       age-value = delta-seconds
</code></pre>
<p>Age values are non-negative decimal integers, representing time in
seconds.</p>
<p>Fielding, et. al.           Standards Track                    [Page 99]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>If a cache receives a value larger than the largest positive integer
it can represent, or if any of its age calculations overflows, it
MUST transmit an Age header with a value of 2147483648 (2^31).
HTTP/1.1 caches MUST send an Age header in every response. Caches
SHOULD use an arithmetic type of at least 31 bits of range.</p>
<p>14.7 Allow</p>
<p>The Allow entity-header field lists the set of methods supported by
the resource identified by the Request-URI. The purpose of this field
is strictly to inform the recipient of valid methods associated with
the resource. An Allow header field MUST be present in a 405 (Method
Not Allowed) response.</p>
<pre><code>      Allow          = &quot;Allow&quot; &quot;:&quot; 1#method
</code></pre>
<p>Example of use:</p>
<pre><code>      Allow: GET, HEAD, PUT
</code></pre>
<p>This field cannot prevent a client from trying other methods.
However, the indications given by the Allow header field value SHOULD
be followed. The actual set of allowed methods is defined by the
origin server at the time of each request.</p>
<p>The Allow header field MAY be provided with a PUT request to
recommend the methods to be supported by the new or modified
resource. The server is not required to support these methods and
SHOULD include an Allow header in the response giving the actual
supported methods.</p>
<p>A proxy MUST NOT modify the Allow header field even if it does not
understand all the methods specified, since the user agent MAY have
other means of communicating with the origin server.</p>
<p>The Allow header field does not indicate what methods are implemented
at the server level. Servers MAY use the Public response-header field
(section 14.35) to describe what methods are implemented on the
server as a whole.</p>
<p>14.8 Authorization</p>
<p>A user agent that wishes to authenticate itself with a server&ndash;
usually, but not necessarily, after receiving a 401 response&ndash;MAY do
so by including an Authorization request-header field with the
request. The Authorization field value consists of credentials
containing the authentication information of the user agent for the
realm of the resource being requested.</p>
<p>Fielding, et. al.           Standards Track                   [Page 100]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>      Authorization  = &quot;Authorization&quot; &quot;:&quot; credentials
</code></pre>
<p>HTTP access authentication is described in section 11. If a request
is authenticated and a realm specified, the same credentials SHOULD
be valid for all other requests within this realm.</p>
<p>When a shared cache (see section 13.7) receives a request containing
an Authorization field, it MUST NOT return the corresponding response
as a reply to any other request, unless one of the following specific
exceptions holds:</p>
<pre><code> 1. If the response includes the &quot;proxy-revalidate&quot; Cache-Control
    directive, the cache MAY use that response in replying to a
    subsequent request, but a proxy cache MUST first revalidate it with
    the origin server, using the request-headers from the new request
    to allow the origin server to authenticate the new request.
 2. If the response includes the &quot;must-revalidate&quot; Cache-Control
    directive, the cache MAY use that response in replying to a
    subsequent request, but all caches MUST first revalidate it with
    the origin server, using the request-headers from the new request
    to allow the origin server to authenticate the new request.
 3. If the response includes the &quot;public&quot; Cache-Control directive, it
    may be returned in reply to any subsequent request.
</code></pre>
<p>14.9 Cache-Control</p>
<p>The Cache-Control general-header field is used to specify directives
that MUST be obeyed by all caching mechanisms along the
request/response chain. The directives specify behavior intended to
prevent caches from adversely interfering with the request or
response. These directives typically override the default caching
algorithms. Cache directives are unidirectional in that the presence
of a directive in a request does not imply that the same directive
should be given in the response.</p>
<pre><code> Note that HTTP/1.0 caches may not implement Cache-Control and may
 only implement Pragma: no-cache (see section 14.32).
</code></pre>
<p>Cache directives must be passed through by a proxy or gateway
application, regardless of their significance to that application,
since the directives may be applicable to all recipients along the
request/response chain. It is not possible to specify a cache-
directive for a specific cache.</p>
<pre><code>      Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

      cache-directive = cache-request-directive
                      | cache-response-directive
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 101]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>      cache-request-directive =
                        &quot;no-cache&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ]
                      | &quot;no-store&quot;
                      | &quot;max-age&quot; &quot;=&quot; delta-seconds
                      | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]
                      | &quot;min-fresh&quot; &quot;=&quot; delta-seconds
                      | &quot;only-if-cached&quot;
                      | cache-extension

      cache-response-directive =
                        &quot;public&quot;
                      | &quot;private&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ]
                      | &quot;no-cache&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ]
                      | &quot;no-store&quot;
                      | &quot;no-transform&quot;
                      | &quot;must-revalidate&quot;
                      | &quot;proxy-revalidate&quot;
                      | &quot;max-age&quot; &quot;=&quot; delta-seconds
                      | cache-extension

      cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ]
</code></pre>
<p>When a directive appears without any 1#field-name parameter, the
directive applies to the entire request or response. When such a
directive appears with a 1#field-name parameter, it applies only to
the named field or fields, and not to the rest of the request or
response.  This mechanism supports extensibility; implementations of
future versions of the HTTP protocol may apply these directives to
header fields not defined in HTTP/1.1.</p>
<p>The cache-control directives can be broken down into these general
categories:</p>
<pre><code> o  Restrictions on what is cachable; these may only be imposed by the
    origin server.
 o  Restrictions on what may be stored by a cache; these may be imposed
    by either the origin server or the user agent.
 o  Modifications of the basic expiration mechanism; these may be
    imposed by either the origin server or the user agent.
 o  Controls over cache revalidation and reload; these may only be
    imposed by a user agent.
 o  Control over transformation of entities.
 o  Extensions to the caching system.
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 102]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14.9.1 What is Cachable</p>
<p>By default, a response is cachable if the requirements of the request
method, request header fields, and the response status indicate that
it is cachable. Section 13.4 summarizes these defaults for
cachability. The following Cache-Control response directives allow an
origin server to override the default cachability of a response:</p>
<p>public
Indicates that the response is cachable by any cache, even if it
would normally be non-cachable or cachable only within a non-shared
cache. (See also Authorization, section 14.8, for additional
details.)</p>
<p>private
Indicates that all or part of the response message is intended for a
single user and MUST NOT be cached by a shared cache. This allows an
origin server to state that the specified parts of the response are
intended for only one user and are not a valid response for requests
by other users. A private (non-shared) cache may cache the response.</p>
<p>Note: This usage of the word private only controls where the
response may be cached, and cannot ensure the privacy of the
message content.</p>
<p>no-cache
Indicates that all or part of the response message MUST NOT be cached
anywhere. This allows an origin server to prevent caching even by
caches that have been configured to return stale responses to client
requests.</p>
<p>Note: Most HTTP/1.0 caches will not recognize or obey this
directive.</p>
<p>14.9.2 What May be Stored by Caches</p>
<p>The purpose of the no-store directive is to prevent the inadvertent
release or retention of sensitive information (for example, on backup
tapes). The no-store directive applies to the entire message, and may
be sent either in a response or in a request. If sent in a request, a
cache MUST NOT store any part of either this request or any response
to it. If sent in a response, a cache MUST NOT store any part of
either this response or the request that elicited it. This directive
applies to both non-shared and shared caches. &ldquo;MUST NOT store&rdquo; in
this context means that the cache MUST NOT intentionally store the
information in non-volatile storage, and MUST make a best-effort
attempt to remove the information from volatile storage as promptly
as possible after forwarding it.</p>
<p>Fielding, et. al.           Standards Track                   [Page 103]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Even when this directive is associated with a response, users may
explicitly store such a response outside of the caching system (e.g.,
with a &ldquo;Save As&rdquo; dialog). History buffers may store such responses as
part of their normal operation.</p>
<p>The purpose of this directive is to meet the stated requirements of
certain users and service authors who are concerned about accidental
releases of information via unanticipated accesses to cache data
structures. While the use of this directive may improve privacy in
some cases, we caution that it is NOT in any way a reliable or
sufficient mechanism for ensuring privacy. In particular, malicious
or compromised caches may not recognize or obey this directive; and
communications networks may be vulnerable to eavesdropping.</p>
<p>14.9.3 Modifications of the Basic Expiration Mechanism</p>
<p>The expiration time of an entity may be specified by the origin
server using the Expires header (see section 14.21). Alternatively,
it may be specified using the max-age directive in a response.</p>
<p>If a response includes both an Expires header and a max-age
directive, the max-age directive overrides the Expires header, even
if the Expires header is more restrictive. This rule allows an origin
server to provide, for a given response, a longer expiration time to
an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This may be
useful if certain HTTP/1.0 caches improperly calculate ages or
expiration times, perhaps due to desynchronized clocks.</p>
<pre><code> Note: most older caches, not compliant with this specification, do
 not implement any Cache-Control directives.  An origin server
 wishing to use a Cache-Control directive that restricts, but does
 not prevent, caching by an HTTP/1.1-compliant cache may exploit the
 requirement that the max-age directive overrides the Expires
 header, and the fact that non-HTTP/1.1-compliant caches do not
 observe the max-age directive.
</code></pre>
<p>Other directives allow an user agent to modify the basic expiration
mechanism. These directives may be specified on a request:</p>
<p>max-age
Indicates that the client is willing to accept a response whose age
is no greater than the specified time in seconds. Unless max-stale
directive is also included, the client is not willing to accept a
stale response.</p>
<p>min-fresh
Indicates that the client is willing to accept a response whose
freshness lifetime is no less than its current age plus the</p>
<p>Fielding, et. al.           Standards Track                   [Page 104]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> specified time in seconds. That is, the client wants a response
 that will still be fresh for at least the specified number of
 seconds.
</code></pre>
<p>max-stale
Indicates that the client is willing to accept a response that has
exceeded its expiration time. If max-stale is assigned a value,
then the client is willing to accept a response that has exceeded
its expiration time by no more than the specified number of
seconds. If no value is assigned to max-stale, then the client is
willing to accept a stale response of any age.</p>
<p>If a cache returns a stale response, either because of a max-stale
directive on a request, or because the cache is configured to
override the expiration time of a response, the cache MUST attach a
Warning header to the stale response, using Warning 10 (Response is
stale).</p>
<p>14.9.4 Cache Revalidation and Reload Controls</p>
<p>Sometimes an user agent may want or need to insist that a cache
revalidate its cache entry with the origin server (and not just with
the next cache along the path to the origin server), or to reload its
cache entry from the origin server. End-to-end revalidation may be
necessary if either the cache or the origin server has overestimated
the expiration time of the cached response. End-to-end reload may be
necessary if the cache entry has become corrupted for some reason.</p>
<p>End-to-end revalidation may be requested either when the client does
not have its own local cached copy, in which case we call it
&ldquo;unspecified end-to-end revalidation&rdquo;, or when the client does have a
local cached copy, in which case we call it &ldquo;specific end-to-end
revalidation.&rdquo;</p>
<p>The client can specify these three kinds of action using Cache-
Control request directives:</p>
<p>End-to-end reload
The request includes a &ldquo;no-cache&rdquo; Cache-Control directive or, for
compatibility with HTTP/1.0 clients, &ldquo;Pragma: no-cache&rdquo;. No field
names may be included with the no-cache directive in a request. The
server MUST NOT use a cached copy when responding to such a
request.</p>
<p>Specific end-to-end revalidation
The request includes a &ldquo;max-age=0&rdquo; Cache-Control directive, which
forces each cache along the path to the origin server to revalidate
its own entry, if any, with the next cache or server. The initial</p>
<p>Fielding, et. al.           Standards Track                   [Page 105]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> request includes a cache-validating conditional with the client's
 current validator.
</code></pre>
<p>Unspecified end-to-end revalidation
The request includes &ldquo;max-age=0&rdquo; Cache-Control directive, which
forces each cache along the path to the origin server to revalidate
its own entry, if any, with the next cache or server. The initial
request does not include a cache-validating conditional; the first
cache along the path (if any) that holds a cache entry for this
resource includes a cache-validating conditional with its current
validator.</p>
<p>When an intermediate cache is forced, by means of a max-age=0
directive, to revalidate its own cache entry, and the client has
supplied its own validator in the request, the supplied validator may
differ from the validator currently stored with the cache entry. In
this case, the cache may use either validator in making its own
request without affecting semantic transparency.</p>
<p>However, the choice of validator may affect performance. The best
approach is for the intermediate cache to use its own validator when
making its request. If the server replies with 304 (Not Modified),
then the cache should return its now validated copy to the client
with a 200 (OK) response. If the server replies with a new entity and
cache validator, however, the intermediate cache should compare the
returned validator with the one provided in the client&rsquo;s request,
using the strong comparison function. If the client&rsquo;s validator is
equal to the origin server&rsquo;s, then the intermediate cache simply
returns 304 (Not Modified). Otherwise, it returns the new entity with
a 200 (OK) response.</p>
<p>If a request includes the no-cache directive, it should not include
min-fresh, max-stale, or max-age.</p>
<p>In some cases, such as times of extremely poor network connectivity,
a client may want a cache to return only those responses that it
currently has stored, and not to reload or revalidate with the origin
server. To do this, the client may include the only-if-cached
directive in a request. If it receives this directive, a cache SHOULD
either respond using a cached entry that is consistent with the other
constraints of the request, or respond with a 504 (Gateway Timeout)
status. However, if a group of caches is being operated as a unified
system with good internal connectivity, such a request MAY be
forwarded within that group of caches.</p>
<p>Because a cache may be configured to ignore a server&rsquo;s specified
expiration time, and because a client request may include a max-stale
directive (which has a similar effect), the protocol also includes a</p>
<p>Fielding, et. al.           Standards Track                   [Page 106]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>mechanism for the origin server to require revalidation of a cache
entry on any subsequent use. When the must-revalidate directive is
present in a response received by a cache, that cache MUST NOT use
the entry after it becomes stale to respond to a subsequent request
without first revalidating it with the origin server. (I.e., the
cache must do an end-to-end revalidation every time, if, based solely
on the origin server&rsquo;s Expires or max-age value, the cached response
is stale.)</p>
<p>The must-revalidate directive is necessary to support reliable
operation for certain protocol features. In all circumstances an
HTTP/1.1 cache MUST obey the must-revalidate directive; in
particular, if the cache cannot reach the origin server for any
reason, it MUST generate a 504 (Gateway Timeout) response.</p>
<p>Servers should send the must-revalidate directive if and only if
failure to revalidate a request on the entity could result in
incorrect operation, such as a silently unexecuted financial
transaction.  Recipients MUST NOT take any automated action that
violates this directive, and MUST NOT automatically provide an
unvalidated copy of the entity if revalidation fails.</p>
<p>Although this is not recommended, user agents operating under severe
connectivity constraints may violate this directive but, if so, MUST
explicitly warn the user that an unvalidated response has been
provided.  The warning MUST be provided on each unvalidated access,
and SHOULD require explicit user confirmation.</p>
<p>The proxy-revalidate directive has the same meaning as the must-
revalidate directive, except that it does not apply to non-shared
user agent caches. It can be used on a response to an authenticated
request to permit the user&rsquo;s cache to store and later return the
response without needing to revalidate it (since it has already been
authenticated once by that user), while still requiring proxies that
service many users to revalidate each time (in order to make sure
that each user has been authenticated). Note that such authenticated
responses also need the public cache control directive in order to
allow them to be cached at all.</p>
<p>14.9.5 No-Transform Directive</p>
<p>Implementers of intermediate caches (proxies) have found it useful to
convert the media type of certain entity bodies. A proxy might, for
example, convert between image formats in order to save cache space
or to reduce the amount of traffic on a slow link. HTTP has to date
been silent on these transformations.</p>
<p>Fielding, et. al.           Standards Track                   [Page 107]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Serious operational problems have already occurred, however, when
these transformations have been applied to entity bodies intended for
certain kinds of applications. For example, applications for medical
imaging, scientific data analysis and those using end-to-end
authentication, all depend on receiving an entity body that is bit
for bit identical to the original entity-body.</p>
<p>Therefore, if a response includes the no-transform directive, an
intermediate cache or proxy MUST NOT change those headers that are
listed in section 13.5.2 as being subject to the no-transform
directive.  This implies that the cache or proxy must not change any
aspect of the entity-body that is specified by these headers.</p>
<p>14.9.6 Cache Control Extensions</p>
<p>The Cache-Control header field can be extended through the use of one
or more cache-extension tokens, each with an optional assigned value.
Informational extensions (those which do not require a change in
cache behavior) may be added without changing the semantics of other
directives. Behavioral extensions are designed to work by acting as
modifiers to the existing base of cache directives. Both the new
directive and the standard directive are supplied, such that
applications which do not understand the new directive will default
to the behavior specified by the standard directive, and those that
understand the new directive will recognize it as modifying the
requirements associated with the standard directive.  In this way,
extensions to the Cache-Control directives can be made without
requiring changes to the base protocol.</p>
<p>This extension mechanism depends on a HTTP cache obeying all of the
cache-control directives defined for its native HTTP-version, obeying
certain extensions, and ignoring all directives that it does not
understand.</p>
<p>For example, consider a hypothetical new response directive called
&ldquo;community&rdquo; which acts as a modifier to the &ldquo;private&rdquo; directive. We
define this new directive to mean that, in addition to any non-shared
cache, any cache which is shared only by members of the community
named within its value may cache the response. An origin server
wishing to allow the &ldquo;UCI&rdquo; community to use an otherwise private
response in their shared cache(s) may do so by including</p>
<pre><code>      Cache-Control: private, community=&quot;UCI&quot;
</code></pre>
<p>A cache seeing this header field will act correctly even if the cache
does not understand the &ldquo;community&rdquo; cache-extension, since it will
also see and understand the &ldquo;private&rdquo; directive and thus default to
the safe behavior.</p>
<p>Fielding, et. al.           Standards Track                   [Page 108]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Unrecognized cache-directives MUST be ignored; it is assumed that any
cache-directive likely to be unrecognized by an HTTP/1.1 cache will
be combined with standard directives (or the response&rsquo;s default
cachability) such that the cache behavior will remain minimally
correct even if the cache does not understand the extension(s).</p>
<p>14.10 Connection</p>
<p>The Connection general-header field allows the sender to specify
options that are desired for that particular connection and MUST NOT
be communicated by proxies over further connections.</p>
<p>The Connection header has the following grammar:</p>
<pre><code>      Connection-header = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
      connection-token  = token
</code></pre>
<p>HTTP/1.1 proxies MUST parse the Connection header field before a
message is forwarded and, for each connection-token in this field,
remove any header field(s) from the message with the same name as the
connection-token. Connection options are signaled by the presence of
a connection-token in the Connection header field, not by any
corresponding additional header field(s), since the additional header
field may not be sent if there are no parameters associated with that
connection option.  HTTP/1.1 defines the &ldquo;close&rdquo; connection option
for the sender to signal that the connection will be closed after
completion of the response. For example,</p>
<pre><code>      Connection: close
</code></pre>
<p>in either the request or the response header fields indicates that
the connection should not be considered `persistent&rsquo; (section 8.1)
after the current request/response is complete.</p>
<p>HTTP/1.1 applications that do not support persistent connections MUST
include the &ldquo;close&rdquo; connection option in every message.</p>
<p>14.11 Content-Base</p>
<p>The Content-Base entity-header field may be used to specify the base
URI for resolving relative URLs within the entity. This header field
is described as Base in RFC 1808, which is expected to be revised.</p>
<pre><code>      Content-Base      = &quot;Content-Base&quot; &quot;:&quot; absoluteURI
</code></pre>
<p>If no Content-Base field is present, the base URI of an entity is
defined either by its Content-Location (if that Content-Location URI
is an absolute URI) or the URI used to initiate the request, in that</p>
<p>Fielding, et. al.           Standards Track                   [Page 109]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>order of precedence. Note, however, that the base URI of the contents
within the entity-body may be redefined within that entity-body.</p>
<p>14.12 Content-Encoding</p>
<p>The Content-Encoding entity-header field is used as a modifier to the
media-type. When present, its value indicates what additional content
codings have been applied to the entity-body, and thus what decoding
mechanisms MUST be applied in order to obtain the media-type
referenced by the Content-Type header field. Content-Encoding is
primarily used to allow a document to be compressed without losing
the identity of its underlying media type.</p>
<pre><code>      Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding
</code></pre>
<p>Content codings are defined in section 3.5. An example of its use is</p>
<pre><code>      Content-Encoding: gzip
</code></pre>
<p>The Content-Encoding is a characteristic of the entity identified by
the Request-URI. Typically, the entity-body is stored with this
encoding and is only decoded before rendering or analogous usage.</p>
<p>If multiple encodings have been applied to an entity, the content
codings MUST be listed in the order in which they were applied.</p>
<p>Additional information about the encoding parameters MAY be provided
by other entity-header fields not defined by this specification.</p>
<p>14.13 Content-Language</p>
<p>The Content-Language entity-header field describes the natural
language(s) of the intended audience for the enclosed entity. Note
that this may not be equivalent to all the languages used within the
entity-body.</p>
<pre><code>      Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag
</code></pre>
<p>Language tags are defined in section 3.10. The primary purpose of
Content-Language is to allow a user to identify and differentiate
entities according to the user&rsquo;s own preferred language. Thus, if the
body content is intended only for a Danish-literate audience, the
appropriate field is</p>
<pre><code>      Content-Language: da
</code></pre>
<p>If no Content-Language is specified, the default is that the content
is intended for all language audiences. This may mean that the sender</p>
<p>Fielding, et. al.           Standards Track                   [Page 110]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>does not consider it to be specific to any natural language, or that
the sender does not know for which language it is intended.</p>
<p>Multiple languages MAY be listed for content that is intended for
multiple audiences. For example, a rendition of the &ldquo;Treaty of
Waitangi,&rdquo; presented simultaneously in the original Maori and English
versions, would call for</p>
<pre><code>      Content-Language: mi, en
</code></pre>
<p>However, just because multiple languages are present within an entity
does not mean that it is intended for multiple linguistic audiences.
An example would be a beginner&rsquo;s language primer, such as &ldquo;A First
Lesson in Latin,&rdquo; which is clearly intended to be used by an
English-literate audience. In this case, the Content-Language should
only include &ldquo;en&rdquo;.</p>
<p>Content-Language may be applied to any media type &ndash; it is not
limited to textual documents.</p>
<p>14.14 Content-Length</p>
<p>The Content-Length entity-header field indicates the size of the
message-body, in decimal number of octets, sent to the recipient or,
in the case of the HEAD method, the size of the entity-body that
would have been sent had the request been a GET.</p>
<pre><code>      Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT
</code></pre>
<p>An example is</p>
<pre><code>      Content-Length: 3495
</code></pre>
<p>Applications SHOULD use this field to indicate the size of the
message-body to be transferred, regardless of the media type of the
entity. It must be possible for the recipient to reliably determine
the end of HTTP/1.1 requests containing an entity-body, e.g., because
the request has a valid Content-Length field, uses Transfer-Encoding:
chunked or a multipart body.</p>
<p>Any Content-Length greater than or equal to zero is a valid value.
Section 4.4 describes how to determine the length of a message-body
if a Content-Length is not given.</p>
<p>Fielding, et. al.           Standards Track                   [Page 111]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> Note: The meaning of this field is significantly different from the
 corresponding definition in MIME, where it is an optional field
 used within the &quot;message/external-body&quot; content-type. In HTTP, it
 SHOULD be sent whenever the message's length can be determined
 prior to being transferred.
</code></pre>
<p>14.15 Content-Location</p>
<p>The Content-Location entity-header field may be used to supply the
resource location for the entity enclosed in the message. In the case
where a resource has multiple entities associated with it, and those
entities actually have separate locations by which they might be
individually accessed, the server should provide a Content-Location
for the particular variant which is returned. In addition, a server
SHOULD provide a Content-Location for the resource corresponding to
the response entity.</p>
<pre><code>      Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                        ( absoluteURI | relativeURI )
</code></pre>
<p>If no Content-Base header field is present, the value of Content-
Location also defines the base URL for the entity (see section
14.11).</p>
<p>The Content-Location value is not a replacement for the original
requested URI; it is only a statement of the location of the resource
corresponding to this particular entity at the time of the request.
Future requests MAY use the Content-Location URI if the desire is to
identify the source of that particular entity.</p>
<p>A cache cannot assume that an entity with a Content-Location
different from the URI used to retrieve it can be used to respond to
later requests on that Content-Location URI. However, the Content-
Location can be used to differentiate between multiple entities
retrieved from a single requested resource, as described in section
13.6.</p>
<p>If the Content-Location is a relative URI, the URI is interpreted
relative to any Content-Base URI provided in the response. If no
Content-Base is provided, the relative URI is interpreted relative to
the Request-URI.</p>
<p>Fielding, et. al.           Standards Track                   [Page 112]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14.16 Content-MD5</p>
<p>The Content-MD5 entity-header field, as defined in RFC 1864 [23], is
an MD5 digest of the entity-body for the purpose of providing an
end-to-end message integrity check (MIC) of the entity-body. (Note: a
MIC is good for detecting accidental modification of the entity-body
in transit, but is not proof against malicious attacks.)</p>
<pre><code>       Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest

       md5-digest   = &lt;base64 of 128 bit MD5 digest as per RFC 1864&gt;
</code></pre>
<p>The Content-MD5 header field may be generated by an origin server to
function as an integrity check of the entity-body. Only origin
servers may generate the Content-MD5 header field; proxies and
gateways MUST NOT generate it, as this would defeat its value as an
end-to-end integrity check. Any recipient of the entity-body,
including gateways and proxies, MAY check that the digest value in
this header field matches that of the entity-body as received.</p>
<p>The MD5 digest is computed based on the content of the entity-body,
including any Content-Encoding that has been applied, but not
including any Transfer-Encoding that may have been applied to the
message-body. If the message is received with a Transfer-Encoding,
that encoding must be removed prior to checking the Content-MD5 value
against the received entity.</p>
<p>This has the result that the digest is computed on the octets of the
entity-body exactly as, and in the order that, they would be sent if
no Transfer-Encoding were being applied.</p>
<p>HTTP extends RFC 1864 to permit the digest to be computed for MIME
composite media-types (e.g., multipart/* and message/rfc822), but
this does not change how the digest is computed as defined in the
preceding paragraph.</p>
<pre><code> Note: There are several consequences of this. The entity-body for
 composite types may contain many body-parts, each with its own MIME
 and HTTP headers (including Content-MD5, Content-Transfer-Encoding,
 and Content-Encoding headers). If a body-part has a Content-
 Transfer-Encoding or Content-Encoding header, it is assumed that
 the content of the body-part has had the encoding applied, and the
 body-part is included in the Content-MD5 digest as is -- i.e.,
 after the application. The Transfer-Encoding header field is not
 allowed within body-parts.

 Note: while the definition of Content-MD5 is exactly the same for
 HTTP as in RFC 1864 for MIME entity-bodies, there are several ways
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 113]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> in which the application of Content-MD5 to HTTP entity-bodies
 differs from its application to MIME entity-bodies. One is that
 HTTP, unlike MIME, does not use Content-Transfer-Encoding, and does
 use Transfer-Encoding and Content-Encoding. Another is that HTTP
 more frequently uses binary content types than MIME, so it is worth
 noting that, in such cases, the byte order used to compute the
 digest is the transmission byte order defined for the type. Lastly,
 HTTP allows transmission of text types with any of several line
 break conventions and not just the canonical form using CRLF.
 Conversion of all line breaks to CRLF should not be done before
 computing or checking the digest: the line break convention used in
 the text actually transmitted should be left unaltered when
 computing the digest.
</code></pre>
<p>14.17 Content-Range</p>
<p>The Content-Range entity-header is sent with a partial entity-body to
specify where in the full entity-body the partial body should be
inserted. It also indicates the total size of the full entity-body.
When a server returns a partial response to a client, it must
describe both the extent of the range covered by the response, and
the length of the entire entity-body.</p>
<pre><code>      Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

      content-range-spec      = byte-content-range-spec

      byte-content-range-spec = bytes-unit SP first-byte-pos &quot;-&quot;
                                last-byte-pos &quot;/&quot; entity-length

      entity-length           = 1*DIGIT
</code></pre>
<p>Unlike byte-ranges-specifier values, a byte-content-range-spec may
only specify one range, and must contain absolute byte positions for
both the first and last byte of the range.</p>
<p>A byte-content-range-spec whose last-byte-pos value is less than its
first-byte-pos value, or whose entity-length value is less than or
equal to its last-byte-pos value, is invalid. The recipient of an
invalid byte-content-range-spec MUST ignore it and any content
transferred along with it.</p>
<p>Fielding, et. al.           Standards Track                   [Page 114]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Examples of byte-content-range-spec values, assuming that the entity
contains a total of 1234 bytes:</p>
<pre><code> o  The first 500 bytes:

      bytes 0-499/1234

 o  The second 500 bytes:

      bytes 500-999/1234

 o  All except for the first 500 bytes:

      bytes 500-1233/1234

 o  The last 500 bytes:

      bytes 734-1233/1234
</code></pre>
<p>When an HTTP message includes the content of a single range (for
example, a response to a request for a single range, or to a request
for a set of ranges that overlap without any holes), this content is
transmitted with a Content-Range header, and a Content-Length header
showing the number of bytes actually transferred. For example,</p>
<pre><code>      HTTP/1.1 206 Partial content
      Date: Wed, 15 Nov 1995 06:25:24 GMT
      Last-modified: Wed, 15 Nov 1995 04:58:08 GMT
      Content-Range: bytes 21010-47021/47022
      Content-Length: 26012
      Content-Type: image/gif
</code></pre>
<p>When an HTTP message includes the content of multiple ranges (for
example, a response to a request for multiple non-overlapping
ranges), these are transmitted as a multipart MIME message. The
multipart MIME content-type used for this purpose is defined in this
specification to be &ldquo;multipart/byteranges&rdquo;. See appendix 19.2 for its
definition.</p>
<p>A client that cannot decode a MIME multipart/byteranges message
should not ask for multiple byte-ranges in a single request.</p>
<p>When a client requests multiple byte-ranges in one request, the
server SHOULD return them in the order that they appeared in the
request.</p>
<p>If the server ignores a byte-range-spec because it is invalid, the
server should treat the request as if the invalid Range header field</p>
<p>Fielding, et. al.           Standards Track                   [Page 115]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>did not exist. (Normally, this means return a 200 response containing
the full entity). The reason is that the only time a client will make
such an invalid request is when the entity is smaller than the entity
retrieved by a prior request.</p>
<p>14.18 Content-Type</p>
<p>The Content-Type entity-header field indicates the media type of the
entity-body sent to the recipient or, in the case of the HEAD method,
the media type that would have been sent had the request been a GET.</p>
<pre><code>      Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type
</code></pre>
<p>Media types are defined in section 3.7. An example of the field is</p>
<pre><code>      Content-Type: text/html; charset=ISO-8859-4
</code></pre>
<p>Further discussion of methods for identifying the media type of an
entity is provided in section 7.2.1.</p>
<p>14.19 Date</p>
<p>The Date general-header field represents the date and time at which
the message was originated, having the same semantics as orig-date in
RFC 822. The field value is an HTTP-date, as described in section
3.3.1.</p>
<pre><code>      Date  = &quot;Date&quot; &quot;:&quot; HTTP-date
</code></pre>
<p>An example is</p>
<pre><code>      Date: Tue, 15 Nov 1994 08:12:31 GMT
</code></pre>
<p>If a message is received via direct connection with the user agent
(in the case of requests) or the origin server (in the case of
responses), then the date can be assumed to be the current date at
the receiving end. However, since the date&ndash;as it is believed by the
origin&ndash;is important for evaluating cached responses, origin servers
MUST include a Date header field in all responses. Clients SHOULD
only send a Date header field in messages that include an entity-
body, as in the case of the PUT and POST requests, and even then it
is optional. A received message which does not have a Date header
field SHOULD be assigned one by the recipient if the message will be
cached by that recipient or gatewayed via a protocol which requires a
Date.</p>
<p>Fielding, et. al.           Standards Track                   [Page 116]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>In theory, the date SHOULD represent the moment just before the
entity is generated. In practice, the date can be generated at any
time during the message origination without affecting its semantic
value.</p>
<p>The format of the Date is an absolute date and time as defined by
HTTP-date in section 3.3; it MUST be sent in RFC1123 [8]-date format.</p>
<p>14.20 ETag</p>
<p>The ETag entity-header field defines the entity tag for the
associated entity. The headers used with entity tags are described in
sections 14.20, 14.25, 14.26 and 14.43. The entity tag may be used
for comparison with other entities from the same resource (see
section 13.3.2).</p>
<pre><code>     ETag = &quot;ETag&quot; &quot;:&quot; entity-tag
</code></pre>
<p>Examples:</p>
<pre><code>     ETag: &quot;xyzzy&quot;
     ETag: W/&quot;xyzzy&quot;
     ETag: &quot;&quot;
</code></pre>
<p>14.21 Expires</p>
<p>The Expires entity-header field gives the date/time after which the
response should be considered stale. A stale cache entry may not
normally be returned by a cache (either a proxy cache or an user
agent cache) unless it is first validated with the origin server (or
with an intermediate cache that has a fresh copy of the entity). See
section 13.2 for further discussion of the expiration model.</p>
<p>The presence of an Expires field does not imply that the original
resource will change or cease to exist at, before, or after that
time.</p>
<p>The format is an absolute date and time as defined by HTTP-date in
section 3.3; it MUST be in RFC1123-date format:</p>
<pre><code>     Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 117]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>An example of its use is</p>
<pre><code>     Expires: Thu, 01 Dec 1994 16:00:00 GMT

 Note: if a response includes a Cache-Control field with the max-age
 directive, that directive overrides the Expires field.
</code></pre>
<p>HTTP/1.1 clients and caches MUST treat other invalid date formats,
especially including the value &ldquo;0&rdquo;, as in the past (i.e., &ldquo;already
expired&rdquo;).</p>
<p>To mark a response as &ldquo;already expired,&rdquo; an origin server should use
an Expires date that is equal to the Date header value. (See the
rules for expiration calculations in section 13.2.4.)</p>
<p>To mark a response as &ldquo;never expires,&rdquo; an origin server should use an
Expires date approximately one year from the time the response is
sent.  HTTP/1.1 servers should not send Expires dates more than one
year in the future.</p>
<p>The presence of an Expires header field with a date value of some
time in the future on an response that otherwise would by default be
non-cacheable indicates that the response is cachable, unless
indicated otherwise by a Cache-Control header field (section 14.9).</p>
<p>14.22 From</p>
<p>The From request-header field, if given, SHOULD contain an Internet
e-mail address for the human user who controls the requesting user
agent.  The address SHOULD be machine-usable, as defined by mailbox
in RFC 822 (as updated by RFC 1123 ):</p>
<pre><code>      From   = &quot;From&quot; &quot;:&quot; mailbox
</code></pre>
<p>An example is:</p>
<pre><code>      From: webmaster@w3.org
</code></pre>
<p>This header field MAY be used for logging purposes and as a means for
identifying the source of invalid or unwanted requests. It SHOULD NOT
be used as an insecure form of access protection. The interpretation
of this field is that the request is being performed on behalf of the
person given, who accepts responsibility for the method performed. In
particular, robot agents SHOULD include this header so that the
person responsible for running the robot can be contacted if problems
occur on the receiving end.</p>
<p>Fielding, et. al.           Standards Track                   [Page 118]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The Internet e-mail address in this field MAY be separate from the
Internet host which issued the request. For example, when a request
is passed through a proxy the original issuer&rsquo;s address SHOULD be
used.</p>
<pre><code> Note: The client SHOULD not send the From header field without the
 user's approval, as it may conflict with the user's privacy
 interests or their site's security policy. It is strongly
 recommended that the user be able to disable, enable, and modify
 the value of this field at any time prior to a request.
</code></pre>
<p>14.23 Host</p>
<p>The Host request-header field specifies the Internet host and port
number of the resource being requested, as obtained from the original
URL given by the user or referring resource (generally an HTTP URL,
as described in section 3.2.2). The Host field value MUST represent
the network location of the origin server or gateway given by the
original URL. This allows the origin server or gateway to
differentiate between internally-ambiguous URLs, such as the root &ldquo;/&rdquo;
URL of a server for multiple host names on a single IP address.</p>
<pre><code>      Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ]    ; Section 3.2.2
</code></pre>
<p>A &ldquo;host&rdquo; without any trailing port information implies the default
port for the service requested (e.g., &ldquo;80&rdquo; for an HTTP URL). For
example, a request on the origin server for
<a href="http://www.w3.org/pub/WWW/">http://www.w3.org/pub/WWW/</a> MUST include:</p>
<pre><code>      GET /pub/WWW/ HTTP/1.1
      Host: www.w3.org
</code></pre>
<p>A client MUST include a Host header field in all HTTP/1.1 request
messages on the Internet (i.e., on any message corresponding to a
request for a URL which includes an Internet host address for the
service being requested). If the Host field is not already present,
an HTTP/1.1 proxy MUST add a Host field to the request message prior
to forwarding it on the Internet. All Internet-based HTTP/1.1 servers
MUST respond with a 400 status code to any HTTP/1.1 request message
which lacks a Host header field.</p>
<p>See sections 5.2 and 19.5.1 for other requirements relating to Host.</p>
<p>14.24 If-Modified-Since</p>
<p>The If-Modified-Since request-header field is used with the GET
method to make it conditional: if the requested variant has not been
modified since the time specified in this field, an entity will not</p>
<p>Fielding, et. al.           Standards Track                   [Page 119]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>be returned from the server; instead, a 304 (not modified) response
will be returned without any message-body.</p>
<pre><code>      If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date
</code></pre>
<p>An example of the field is:</p>
<pre><code>      If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</code></pre>
<p>A GET method with an If-Modified-Since header and no Range header
requests that the identified entity be transferred only if it has
been modified since the date given by the If-Modified-Since header.
The algorithm for determining this includes the following cases:</p>
<p>a)If the request would normally result in anything other than a 200
(OK) status, or if the passed If-Modified-Since date is invalid, the
response is exactly the same as for a normal GET. A date which is
later than the server&rsquo;s current time is invalid.</p>
<p>b)If the variant has been modified since the If-Modified-Since date,
the response is exactly the same as for a normal GET.</p>
<p>c)If the variant has not been modified since a valid If-Modified-Since
date, the server MUST return a 304 (Not Modified) response.</p>
<p>The purpose of this feature is to allow efficient updates of cached
information with a minimum amount of transaction overhead.</p>
<pre><code> Note that the Range request-header field modifies the meaning of
 If-Modified-Since; see section 14.36 for full details.

 Note that If-Modified-Since times are interpreted by the server,
 whose clock may not be synchronized with the client.
</code></pre>
<p>Note that if a client uses an arbitrary date in the If-Modified-Since
header instead of a date taken from the Last-Modified header for the
same request, the client should be aware of the fact that this date
is interpreted in the server&rsquo;s understanding of time. The client
should consider unsynchronized clocks and rounding problems due to
the different encodings of time between the client and server. This
includes the possibility of race conditions if the document has
changed between the time it was first requested and the If-Modified-
Since date of a subsequent request, and the possibility of clock-
skew-related problems if the If-Modified-Since date is derived from
the client&rsquo;s clock without correction to the server&rsquo;s clock.
Corrections for different time bases between client and server are at
best approximate due to network latency.</p>
<p>Fielding, et. al.           Standards Track                   [Page 120]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14.25 If-Match</p>
<p>The If-Match request-header field is used with a method to make it
conditional. A client that has one or more entities previously
obtained from the resource can verify that one of those entities is
current by including a list of their associated entity tags in the
If-Match header field. The purpose of this feature is to allow
efficient updates of cached information with a minimum amount of
transaction overhead. It is also used, on updating requests, to
prevent inadvertent modification of the wrong version of a resource.
As a special case, the value &ldquo;*&rdquo; matches any current entity of the
resource.</p>
<pre><code>      If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )
</code></pre>
<p>If any of the entity tags match the entity tag of the entity that
would have been returned in the response to a similar GET request
(without the If-Match header) on that resource, or if &ldquo;*&rdquo; is given
and any current entity exists for that resource, then the server MAY
perform the requested method as if the If-Match header field did not
exist.</p>
<p>A server MUST use the strong comparison function (see section 3.11)
to compare the entity tags in If-Match.</p>
<p>If none of the entity tags match, or if &ldquo;*&rdquo; is given and no current
entity exists, the server MUST NOT perform the requested method, and
MUST return a 412 (Precondition Failed) response. This behavior is
most useful when the client wants to prevent an updating method, such
as PUT, from modifying a resource that has changed since the client
last retrieved it.</p>
<p>If the request would, without the If-Match header field, result in
anything other than a 2xx status, then the If-Match header MUST be
ignored.</p>
<p>The meaning of &ldquo;If-Match: *&rdquo; is that the method SHOULD be performed
if the representation selected by the origin server (or by a cache,
possibly using the Vary mechanism, see section 14.43) exists, and
MUST NOT be performed if the representation does not exist.</p>
<p>Fielding, et. al.           Standards Track                   [Page 121]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>A request intended to update a resource (e.g., a PUT) MAY include an
If-Match header field to signal that the request method MUST NOT be
applied if the entity corresponding to the If-Match value (a single
entity tag) is no longer a representation of that resource.  This
allows the user to indicate that they do not wish the request to be
successful if the resource has been changed without their knowledge.
Examples:</p>
<pre><code>      If-Match: &quot;xyzzy&quot;
      If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
      If-Match: *
</code></pre>
<p>14.26 If-None-Match</p>
<p>The If-None-Match request-header field is used with a method to make
it conditional. A client that has one or more entities previously
obtained from the resource can verify that none of those entities is
current by including a list of their associated entity tags in the
If-None-Match header field. The purpose of this feature is to allow
efficient updates of cached information with a minimum amount of
transaction overhead. It is also used, on updating requests, to
prevent inadvertent modification of a resource which was not known to
exist.</p>
<p>As a special case, the value &ldquo;*&rdquo; matches any current entity of the
resource.</p>
<pre><code>      If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )
</code></pre>
<p>If any of the entity tags match the entity tag of the entity that
would have been returned in the response to a similar GET request
(without the If-None-Match header) on that resource, or if &ldquo;*&rdquo; is
given and any current entity exists for that resource, then the
server MUST NOT perform the requested method. Instead, if the request
method was GET or HEAD, the server SHOULD respond with a 304 (Not
Modified) response, including the cache-related entity-header fields
(particularly ETag) of one of the entities that matched. For all
other request methods, the server MUST respond with a status of 412
(Precondition Failed).</p>
<p>See section 13.3.3 for rules on how to determine if two entity tags
match. The weak comparison function can only be used with GET or HEAD
requests.</p>
<p>If none of the entity tags match, or if &ldquo;*&rdquo; is given and no current
entity exists, then the server MAY perform the requested method as if
the If-None-Match header field did not exist.</p>
<p>Fielding, et. al.           Standards Track                   [Page 122]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>If the request would, without the If-None-Match header field, result
in anything other than a 2xx status, then the If-None-Match header
MUST be ignored.</p>
<p>The meaning of &ldquo;If-None-Match: *&rdquo; is that the method MUST NOT be
performed if the representation selected by the origin server (or by
a cache, possibly using the Vary mechanism, see section 14.43)
exists, and SHOULD be performed if the representation does not exist.
This feature may be useful in preventing races between PUT
operations.</p>
<p>Examples:</p>
<pre><code>      If-None-Match: &quot;xyzzy&quot;
      If-None-Match: W/&quot;xyzzy&quot;
      If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
      If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
      If-None-Match: *
</code></pre>
<p>14.27 If-Range</p>
<p>If a client has a partial copy of an entity in its cache, and wishes
to have an up-to-date copy of the entire entity in its cache, it
could use the Range request-header with a conditional GET (using
either or both of If-Unmodified-Since and If-Match.) However, if the
condition fails because the entity has been modified, the client
would then have to make a second request to obtain the entire current
entity-body.</p>
<p>The If-Range header allows a client to &ldquo;short-circuit&rdquo; the second
request. Informally, its meaning is `if the entity is unchanged, send
me the part(s) that I am missing; otherwise, send me the entire new
entity.&rsquo;</p>
<pre><code>       If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date )
</code></pre>
<p>If the client has no entity tag for an entity, but does have a Last-
Modified date, it may use that date in a If-Range header. (The server
can distinguish between a valid HTTP-date and any form of entity-tag
by examining no more than two characters.) The If-Range header should
only be used together with a Range header, and must be ignored if the
request does not include a Range header, or if the server does not
support the sub-range operation.</p>
<p>Fielding, et. al.           Standards Track                   [Page 123]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>If the entity tag given in the If-Range header matches the current
entity tag for the entity, then the server should provide the
specified sub-range of the entity using a 206 (Partial content)
response. If the entity tag does not match, then the server should
return the entire entity using a 200 (OK) response.</p>
<p>14.28 If-Unmodified-Since</p>
<p>The If-Unmodified-Since request-header field is used with a method to
make it conditional. If the requested resource has not been modified
since the time specified in this field, the server should perform the
requested operation as if the If-Unmodified-Since header were not
present.</p>
<p>If the requested variant has been modified since the specified time,
the server MUST NOT perform the requested operation, and MUST return
a 412 (Precondition Failed).</p>
<pre><code>     If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date
</code></pre>
<p>An example of the field is:</p>
<pre><code>      If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</code></pre>
<p>If the request normally (i.e., without the If-Unmodified-Since
header) would result in anything other than a 2xx status, the If-
Unmodified-Since header should be ignored.</p>
<p>If the specified date is invalid, the header is ignored.</p>
<p>14.29 Last-Modified</p>
<p>The Last-Modified entity-header field indicates the date and time at
which the origin server believes the variant was last modified.</p>
<pre><code>      Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date
</code></pre>
<p>An example of its use is</p>
<pre><code>      Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</code></pre>
<p>The exact meaning of this header field depends on the implementation
of the origin server and the nature of the original resource. For
files, it may be just the file system last-modified time. For
entities with dynamically included parts, it may be the most recent
of the set of last-modify times for its component parts. For database
gateways, it may be the last-update time stamp of the record. For
virtual objects, it may be the last time the internal state changed.</p>
<p>Fielding, et. al.           Standards Track                   [Page 124]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>An origin server MUST NOT send a Last-Modified date which is later
than the server&rsquo;s time of message origination. In such cases, where
the resource&rsquo;s last modification would indicate some time in the
future, the server MUST replace that date with the message
origination date.</p>
<p>An origin server should obtain the Last-Modified value of the entity
as close as possible to the time that it generates the Date value of
its response. This allows a recipient to make an accurate assessment
of the entity&rsquo;s modification time, especially if the entity changes
near the time that the response is generated.</p>
<p>HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</p>
<p>14.30 Location</p>
<p>The Location response-header field is used to redirect the recipient
to a location other than the Request-URI for completion of the
request or identification of a new resource. For 201 (Created)
responses, the Location is that of the new resource which was created
by the request.  For 3xx responses, the location SHOULD indicate the
server&rsquo;s preferred URL for automatic redirection to the resource. The
field value consists of a single absolute URL.</p>
<pre><code>      Location       = &quot;Location&quot; &quot;:&quot; absoluteURI
</code></pre>
<p>An example is</p>
<pre><code>      Location: http://www.w3.org/pub/WWW/People.html

 Note: The Content-Location header field (section 14.15) differs
 from Location in that the Content-Location identifies the original
 location of the entity enclosed in the request. It is therefore
 possible for a response to contain header fields for both Location
 and Content-Location. Also see section 13.10 for cache requirements
 of some methods.
</code></pre>
<p>14.31 Max-Forwards</p>
<p>The Max-Forwards request-header field may be used with the TRACE
method (section 14.31) to limit the number of proxies or gateways
that can forward the request to the next inbound server. This can be
useful when the client is attempting to trace a request chain which
appears to be failing or looping in mid-chain.</p>
<pre><code>      Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 125]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The Max-Forwards value is a decimal integer indicating the remaining
number of times this request message may be forwarded.</p>
<p>Each proxy or gateway recipient of a TRACE request containing a Max-
Forwards header field SHOULD check and update its value prior to
forwarding the request. If the received value is zero (0), the
recipient SHOULD NOT forward the request; instead, it SHOULD respond
as the final recipient with a 200 (OK) response containing the
received request message as the response entity-body (as described in
section 9.8). If the received Max-Forwards value is greater than
zero, then the forwarded message SHOULD contain an updated Max-
Forwards field with a value decremented by one (1).</p>
<p>The Max-Forwards header field SHOULD be ignored for all other methods
defined by this specification and for any extension methods for which
it is not explicitly referred to as part of that method definition.</p>
<p>14.32 Pragma</p>
<p>The Pragma general-header field is used to include implementation-
specific directives that may apply to any recipient along the
request/response chain. All pragma directives specify optional
behavior from the viewpoint of the protocol; however, some systems
MAY require that behavior be consistent with the directives.</p>
<pre><code>      Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive

      pragma-directive  = &quot;no-cache&quot; | extension-pragma
      extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]
</code></pre>
<p>When the no-cache directive is present in a request message, an
application SHOULD forward the request toward the origin server even
if it has a cached copy of what is being requested. This pragma
directive has the same semantics as the no-cache cache-directive (see
section 14.9) and is defined here for backwards compatibility with
HTTP/1.0.  Clients SHOULD include both header fields when a no-cache
request is sent to a server not known to be HTTP/1.1 compliant.</p>
<p>Pragma directives MUST be passed through by a proxy or gateway
application, regardless of their significance to that application,
since the directives may be applicable to all recipients along the
request/response chain. It is not possible to specify a pragma for a
specific recipient; however, any pragma directive not relevant to a
recipient SHOULD be ignored by that recipient.</p>
<p>Fielding, et. al.           Standards Track                   [Page 126]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>HTTP/1.1 clients SHOULD NOT send the Pragma request-header. HTTP/1.1
caches SHOULD treat &ldquo;Pragma: no-cache&rdquo; as if the client had sent
&ldquo;Cache-Control: no-cache&rdquo;. No new Pragma directives will be defined
in HTTP.</p>
<p>14.33 Proxy-Authenticate</p>
<p>The Proxy-Authenticate response-header field MUST be included as part
of a 407 (Proxy Authentication Required) response. The field value
consists of a challenge that indicates the authentication scheme and
parameters applicable to the proxy for this Request-URI.</p>
<pre><code>      Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; challenge
</code></pre>
<p>The HTTP access authentication process is described in section 11.
Unlike WWW-Authenticate, the Proxy-Authenticate header field applies
only to the current connection and SHOULD NOT be passed on to
downstream clients. However, an intermediate proxy may need to obtain
its own credentials by requesting them from the downstream client,
which in some circumstances will appear as if the proxy is forwarding
the Proxy-Authenticate header field.</p>
<p>14.34 Proxy-Authorization</p>
<p>The Proxy-Authorization request-header field allows the client to
identify itself (or its user) to a proxy which requires
authentication.  The Proxy-Authorization field value consists of
credentials containing the authentication information of the user
agent for the proxy and/or realm of the resource being requested.</p>
<pre><code>   Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials
</code></pre>
<p>The HTTP access authentication process is described in section 11.
Unlike Authorization, the Proxy-Authorization header field applies
only to the next outbound proxy that demanded authentication using
the Proxy-Authenticate field. When multiple proxies are used in a
chain, the Proxy-Authorization header field is consumed by the first
outbound proxy that was expecting to receive credentials. A proxy MAY
relay the credentials from the client request to the next proxy if
that is the mechanism by which the proxies cooperatively authenticate
a given request.</p>
<p>14.35 Public</p>
<p>The Public response-header field lists the set of methods supported
by the server. The purpose of this field is strictly to inform the
recipient of the capabilities of the server regarding unusual
methods.  The methods listed may or may not be applicable to the</p>
<p>Fielding, et. al.           Standards Track                   [Page 127]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Request-URI; the Allow header field (section 14.7) MAY be used to
indicate methods allowed for a particular URI.</p>
<pre><code>      Public         = &quot;Public&quot; &quot;:&quot; 1#method
</code></pre>
<p>Example of use:</p>
<pre><code>      Public: OPTIONS, MGET, MHEAD, GET, HEAD
</code></pre>
<p>This header field applies only to the server directly connected to
the client (i.e., the nearest neighbor in a chain of connections). If
the response passes through a proxy, the proxy MUST either remove the
Public header field or replace it with one applicable to its own
capabilities.</p>
<p>14.36 Range</p>
<p>14.36.1 Byte Ranges</p>
<p>Since all HTTP entities are represented in HTTP messages as sequences
of bytes, the concept of a byte range is meaningful for any HTTP
entity.  (However, not all clients and servers need to support byte-
range operations.)</p>
<p>Byte range specifications in HTTP apply to the sequence of bytes in
the entity-body (not necessarily the same as the message-body).</p>
<p>A byte range operation may specify a single range of bytes, or a set
of ranges within a single entity.</p>
<pre><code>   ranges-specifier = byte-ranges-specifier

   byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set

   byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )

   byte-range-spec = first-byte-pos &quot;-&quot; [last-byte-pos]

   first-byte-pos  = 1*DIGIT

   last-byte-pos   = 1*DIGIT
</code></pre>
<p>The first-byte-pos value in a byte-range-spec gives the byte-offset
of the first byte in a range. The last-byte-pos value gives the
byte-offset of the last byte in the range; that is, the byte
positions specified are inclusive. Byte offsets start at zero.</p>
<p>Fielding, et. al.           Standards Track                   [Page 128]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>If the last-byte-pos value is present, it must be greater than or
equal to the first-byte-pos in that byte-range-spec, or the byte-
range-spec is invalid. The recipient of an invalid byte-range-spec
must ignore it.</p>
<p>If the last-byte-pos value is absent, or if the value is greater than
or equal to the current length of the entity-body, last-byte-pos is
taken to be equal to one less than the current length of the entity-
body in bytes.</p>
<p>By its choice of last-byte-pos, a client can limit the number of
bytes retrieved without knowing the size of the entity.</p>
<pre><code>      suffix-byte-range-spec = &quot;-&quot; suffix-length

      suffix-length = 1*DIGIT
</code></pre>
<p>A suffix-byte-range-spec is used to specify the suffix of the
entity-body, of a length given by the suffix-length value. (That is,
this form specifies the last N bytes of an entity-body.) If the
entity is shorter than the specified suffix-length, the entire
entity-body is used.</p>
<p>Examples of byte-ranges-specifier values (assuming an entity-body of
length 10000):</p>
<pre><code> o  The first 500 bytes (byte offsets 0-499, inclusive):

      bytes=0-499

 o  The second 500 bytes (byte offsets 500-999, inclusive):

      bytes=500-999

 o  The final 500 bytes (byte offsets 9500-9999, inclusive):

      bytes=-500

 o  Or

      bytes=9500-

 o  The first and last bytes only (bytes 0 and 9999):

      bytes=0-0,-1
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 129]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> o  Several legal but not canonical specifications of the second
    500 bytes (byte offsets 500-999, inclusive):

      bytes=500-600,601-999

      bytes=500-700,601-999
</code></pre>
<p>14.36.2 Range Retrieval Requests</p>
<p>HTTP retrieval requests using conditional or unconditional GET
methods may request one or more sub-ranges of the entity, instead of
the entire entity, using the Range request header, which applies to
the entity returned as the result of the request:</p>
<pre><code>     Range = &quot;Range&quot; &quot;:&quot; ranges-specifier
</code></pre>
<p>A server MAY ignore the Range header. However, HTTP/1.1 origin
servers and intermediate caches SHOULD support byte ranges when
possible, since Range supports efficient recovery from partially
failed transfers, and supports efficient partial retrieval of large
entities.</p>
<p>If the server supports the Range header and the specified range or
ranges are appropriate for the entity:</p>
<pre><code> o  The presence of a Range header in an unconditional GET modifies
    what is returned if the GET is otherwise successful. In other
    words, the response carries a status code of 206 (Partial
    Content) instead of 200 (OK).

 o  The presence of a Range header in a conditional GET (a request
    using one or both of If-Modified-Since and If-None-Match, or
    one or both of If-Unmodified-Since and If-Match) modifies what
    is returned if the GET is otherwise successful and the condition
    is true. It does not affect the 304 (Not Modified) response
    returned if the conditional is false.
</code></pre>
<p>In some cases, it may be more appropriate to use the If-Range header
(see section 14.27) in addition to the Range header.</p>
<p>If a proxy that supports ranges receives a Range request, forwards
the request to an inbound server, and receives an entire entity in
reply, it SHOULD only return the requested range to its client. It
SHOULD store the entire received response in its cache, if that is
consistent with its cache allocation policies.</p>
<p>Fielding, et. al.           Standards Track                   [Page 130]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14.37 Referer</p>
<p>The Referer[sic] request-header field allows the client to specify,
for the server&rsquo;s benefit, the address (URI) of the resource from
which the Request-URI was obtained (the &ldquo;referrer&rdquo;, although the
header field is misspelled.) The Referer request-header allows a
server to generate lists of back-links to resources for interest,
logging, optimized caching, etc. It also allows obsolete or mistyped
links to be traced for maintenance. The Referer field MUST NOT be
sent if the Request-URI was obtained from a source that does not have
its own URI, such as input from the user keyboard.</p>
<pre><code>    Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )
</code></pre>
<p>Example:</p>
<pre><code>    Referer: http://www.w3.org/hypertext/DataSources/Overview.html
</code></pre>
<p>If the field value is a partial URI, it SHOULD be interpreted
relative to the Request-URI. The URI MUST NOT include a fragment.</p>
<pre><code> Note: Because the source of a link may be private information or
 may reveal an otherwise private information source, it is strongly
 recommended that the user be able to select whether or not the
 Referer field is sent. For example, a browser client could have a
 toggle switch for browsing openly/anonymously, which would
 respectively enable/disable the sending of Referer and From
 information.
</code></pre>
<p>14.38 Retry-After</p>
<p>The Retry-After response-header field can be used with a 503 (Service
Unavailable) response to indicate how long the service is expected to
be unavailable to the requesting client. The value of this field can
be either an HTTP-date or an integer number of seconds (in decimal)
after the time of the response.</p>
<pre><code>      Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )
</code></pre>
<p>Two examples of its use are</p>
<pre><code>      Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
      Retry-After: 120
</code></pre>
<p>In the latter example, the delay is 2 minutes.</p>
<p>Fielding, et. al.           Standards Track                   [Page 131]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14.39 Server</p>
<p>The Server response-header field contains information about the
software used by the origin server to handle the request. The field
can contain multiple product tokens (section 3.8) and comments
identifying the server and any significant subproducts. The product
tokens are listed in order of their significance for identifying the
application.</p>
<pre><code>      Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )
</code></pre>
<p>Example:</p>
<pre><code>      Server: CERN/3.0 libwww/2.17
</code></pre>
<p>If the response is being forwarded through a proxy, the proxy
application MUST NOT modify the Server response-header. Instead, it
SHOULD include a Via field (as described in section 14.44).</p>
<pre><code> Note: Revealing the specific software version of the server may
 allow the server machine to become more vulnerable to attacks
 against software that is known to contain security holes. Server
 implementers are encouraged to make this field a configurable
 option.
</code></pre>
<p>14.40 Transfer-Encoding</p>
<p>The Transfer-Encoding general-header field indicates what (if any)
type of transformation has been applied to the message body in order
to safely transfer it between the sender and the recipient. This
differs from the Content-Encoding in that the transfer coding is a
property of the message, not of the entity.</p>
<pre><code>      Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-
</code></pre>
<p>coding</p>
<p>Transfer codings are defined in section 3.6. An example is:</p>
<pre><code>      Transfer-Encoding: chunked
</code></pre>
<p>Many older HTTP/1.0 applications do not understand the Transfer-
Encoding header.</p>
<p>14.41 Upgrade</p>
<p>The Upgrade general-header allows the client to specify what
additional communication protocols it supports and would like to use
if the server finds it appropriate to switch protocols. The server</p>
<p>Fielding, et. al.           Standards Track                   [Page 132]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>MUST use the Upgrade header field within a 101 (Switching Protocols)
response to indicate which protocol(s) are being switched.</p>
<pre><code>      Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product
</code></pre>
<p>For example,</p>
<pre><code>      Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
</code></pre>
<p>The Upgrade header field is intended to provide a simple mechanism
for transition from HTTP/1.1 to some other, incompatible protocol. It
does so by allowing the client to advertise its desire to use another
protocol, such as a later version of HTTP with a higher major version
number, even though the current request has been made using HTTP/1.1.
This eases the difficult transition between incompatible protocols by
allowing the client to initiate a request in the more commonly
supported protocol while indicating to the server that it would like
to use a &ldquo;better&rdquo; protocol if available (where &ldquo;better&rdquo; is determined
by the server, possibly according to the nature of the method and/or
resource being requested).</p>
<p>The Upgrade header field only applies to switching application-layer
protocols upon the existing transport-layer connection. Upgrade
cannot be used to insist on a protocol change; its acceptance and use
by the server is optional. The capabilities and nature of the
application-layer communication after the protocol change is entirely
dependent upon the new protocol chosen, although the first action
after changing the protocol MUST be a response to the initial HTTP
request containing the Upgrade header field.</p>
<p>The Upgrade header field only applies to the immediate connection.
Therefore, the upgrade keyword MUST be supplied within a Connection
header field (section 14.10) whenever Upgrade is present in an
HTTP/1.1 message.</p>
<p>The Upgrade header field cannot be used to indicate a switch to a
protocol on a different connection. For that purpose, it is more
appropriate to use a 301, 302, 303, or 305 redirection response.</p>
<p>This specification only defines the protocol name &ldquo;HTTP&rdquo; for use by
the family of Hypertext Transfer Protocols, as defined by the HTTP
version rules of section 3.1 and future updates to this
specification. Any token can be used as a protocol name; however, it
will only be useful if both the client and server associate the name
with the same protocol.</p>
<p>Fielding, et. al.           Standards Track                   [Page 133]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14.42 User-Agent</p>
<p>The User-Agent request-header field contains information about the
user agent originating the request. This is for statistical purposes,
the tracing of protocol violations, and automated recognition of user
agents for the sake of tailoring responses to avoid particular user
agent limitations. User agents SHOULD include this field with
requests. The field can contain multiple product tokens (section 3.8)
and comments identifying the agent and any subproducts which form a
significant part of the user agent. By convention, the product tokens
are listed in order of their significance for identifying the
application.</p>
<pre><code>      User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )
</code></pre>
<p>Example:</p>
<pre><code>      User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</code></pre>
<p>14.43 Vary</p>
<p>The Vary response-header field is used by a server to signal that the
response entity was selected from the available representations of
the response using server-driven negotiation (section 12). Field-
names listed in Vary headers are those of request-headers. The Vary
field value indicates either that the given set of header fields
encompass the dimensions over which the representation might vary, or
that the dimensions of variance are unspecified (&quot;*&quot;) and thus may
vary over any aspect of future requests.</p>
<pre><code>      Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )
</code></pre>
<p>An HTTP/1.1 server MUST include an appropriate Vary header field with
any cachable response that is subject to server-driven negotiation.
Doing so allows a cache to properly interpret future requests on that
resource and informs the user agent about the presence of negotiation
on that resource. A server SHOULD include an appropriate Vary header
field with a non-cachable response that is subject to server-driven
negotiation, since this might provide the user agent with useful
information about the dimensions over which the response might vary.</p>
<p>The set of header fields named by the Vary field value is known as
the &ldquo;selecting&rdquo; request-headers.</p>
<p>When the cache receives a subsequent request whose Request-URI
specifies one or more cache entries including a Vary header, the
cache MUST NOT use such a cache entry to construct a response to the
new request unless all of the headers named in the cached Vary header</p>
<p>Fielding, et. al.           Standards Track                   [Page 134]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>are present in the new request, and all of the stored selecting
request-headers from the previous request match the corresponding
headers in the new request.</p>
<p>The selecting request-headers from two requests are defined to match
if and only if the selecting request-headers in the first request can
be transformed to the selecting request-headers in the second request
by adding or removing linear whitespace (LWS) at places where this is
allowed by the corresponding BNF, and/or combining multiple message-
header fields with the same field name following the rules about
message headers in section 4.2.</p>
<p>A Vary field value of &ldquo;*&rdquo; signals that unspecified parameters,
possibly other than the contents of request-header fields (e.g., the
network address of the client), play a role in the selection of the
response representation. Subsequent requests on that resource can
only be properly interpreted by the origin server, and thus a cache
MUST forward a (possibly conditional) request even when it has a
fresh response cached for the resource. See section 13.6 for use of
the Vary header by caches.</p>
<p>A Vary field value consisting of a list of field-names signals that
the representation selected for the response is based on a selection
algorithm which considers ONLY the listed request-header field values
in selecting the most appropriate representation. A cache MAY assume
that the same selection will be made for future requests with the
same values for the listed field names, for the duration of time in
which the response is fresh.</p>
<p>The field-names given are not limited to the set of standard
request-header fields defined by this specification. Field names are
case-insensitive.</p>
<p>14.44 Via</p>
<p>The Via general-header field MUST be used by gateways and proxies to
indicate the intermediate protocols and recipients between the user
agent and the server on requests, and between the origin server and
the client on responses. It is analogous to the &ldquo;Received&rdquo; field of
RFC 822 and is intended to be used for tracking message forwards,
avoiding request loops, and identifying the protocol capabilities of
all senders along the request/response chain.</p>
<p>Fielding, et. al.           Standards Track                   [Page 135]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code>  Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )

  received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
  protocol-name     = token
  protocol-version  = token
  received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
  pseudonym         = token
</code></pre>
<p>The received-protocol indicates the protocol version of the message
received by the server or client along each segment of the
request/response chain. The received-protocol version is appended to
the Via field value when the message is forwarded so that information
about the protocol capabilities of upstream applications remains
visible to all recipients.</p>
<p>The protocol-name is optional if and only if it would be &ldquo;HTTP&rdquo;. The
received-by field is normally the host and optional port number of a
recipient server or client that subsequently forwarded the message.
However, if the real host is considered to be sensitive information,
it MAY be replaced by a pseudonym. If the port is not given, it MAY
be assumed to be the default port of the received-protocol.</p>
<p>Multiple Via field values represent each proxy or gateway that has
forwarded the message. Each recipient MUST append its information
such that the end result is ordered according to the sequence of
forwarding applications.</p>
<p>Comments MAY be used in the Via header field to identify the software
of the recipient proxy or gateway, analogous to the User-Agent and
Server header fields. However, all comments in the Via field are
optional and MAY be removed by any recipient prior to forwarding the
message.</p>
<p>For example, a request message could be sent from an HTTP/1.0 user
agent to an internal proxy code-named &ldquo;fred&rdquo;, which uses HTTP/1.1 to
forward the request to a public proxy at nowhere.com, which completes
the request by forwarding it to the origin server at <a href="http://www.ics.uci.edu">www.ics.uci.edu</a>.
The request received by <a href="http://www.ics.uci.edu">www.ics.uci.edu</a> would then have the following
Via header field:</p>
<pre><code>      Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
</code></pre>
<p>Proxies and gateways used as a portal through a network firewall
SHOULD NOT, by default, forward the names and ports of hosts within
the firewall region. This information SHOULD only be propagated if
explicitly enabled. If not enabled, the received-by host of any host
behind the firewall SHOULD be replaced by an appropriate pseudonym
for that host.</p>
<p>Fielding, et. al.           Standards Track                   [Page 136]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>For organizations that have strong privacy requirements for hiding
internal structures, a proxy MAY combine an ordered subsequence of
Via header field entries with identical received-protocol values into
a single such entry. For example,</p>
<pre><code>      Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

       could be collapsed to

      Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</code></pre>
<p>Applications SHOULD NOT combine multiple entries unless they are all
under the same organizational control and the hosts have already been
replaced by pseudonyms. Applications MUST NOT combine entries which
have different received-protocol values.</p>
<p>14.45 Warning</p>
<p>The Warning response-header field is used to carry additional
information about the status of a response which may not be reflected
by the response status code. This information is typically, though
not exclusively, used to warn about a possible lack of semantic
transparency from caching operations.</p>
<p>Warning headers are sent with responses using:</p>
<pre><code>      Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

      warning-value = warn-code SP warn-agent SP warn-text
      warn-code  = 2DIGIT
      warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                      ; the name or pseudonym of the server adding
                      ; the Warning header, for use in debugging
      warn-text  = quoted-string
</code></pre>
<p>A response may carry more than one Warning header.</p>
<p>The warn-text should be in a natural language and character set that
is most likely to be intelligible to the human user receiving the
response.  This decision may be based on any available knowledge,
such as the location of the cache or user, the Accept-Language field
in a request, the Content-Language field in a response, etc. The
default language is English and the default character set is ISO-
8859-1.</p>
<p>If a character set other than ISO-8859-1 is used, it MUST be encoded
in the warn-text using the method described in RFC 1522 [14].</p>
<p>Fielding, et. al.           Standards Track                   [Page 137]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Any server or cache may add Warning headers to a response. New
Warning headers should be added after any existing Warning headers. A
cache MUST NOT delete any Warning header that it received with a
response. However, if a cache successfully validates a cache entry,
it SHOULD remove any Warning headers previously attached to that
entry except as specified for specific Warning codes. It MUST then
add any Warning headers received in the validating response. In other
words, Warning headers are those that would be attached to the most
recent relevant response.</p>
<p>When multiple Warning headers are attached to a response, the user
agent SHOULD display as many of them as possible, in the order that
they appear in the response. If it is not possible to display all of
the warnings, the user agent should follow these heuristics:</p>
<pre><code> o  Warnings that appear early in the response take priority over those
    appearing later in the response.
 o  Warnings in the user's preferred character set take priority over
    warnings in other character sets but with identical warn-codes and
    warn-agents.
</code></pre>
<p>Systems that generate multiple Warning headers should order them with
this user agent behavior in mind.</p>
<p>This is a list of the currently-defined warn-codes, each with a
recommended warn-text in English, and a description of its meaning.</p>
<p>10 Response is stale
MUST be included whenever the returned response is stale. A cache may
add this warning to any response, but may never remove it until the
response is known to be fresh.</p>
<p>11 Revalidation failed
MUST be included if a cache returns a stale response because an
attempt to revalidate the response failed, due to an inability to
reach the server. A cache may add this warning to any response, but
may never remove it until the response is successfully revalidated.</p>
<p>12 Disconnected operation
SHOULD be included if the cache is intentionally disconnected from
the rest of the network for a period of time.</p>
<p>13 Heuristic expiration
MUST be included if the cache heuristically chose a freshness
lifetime greater than 24 hours and the response&rsquo;s age is greater than
24 hours.</p>
<p>Fielding, et. al.           Standards Track                   [Page 138]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>14 Transformation applied
MUST be added by an intermediate cache or proxy if it applies any
transformation changing the content-coding (as specified in the
Content-Encoding header) or media-type (as specified in the
Content-Type header) of the response, unless this Warning code
already appears in the response. MUST NOT be deleted from a response
even after revalidation.</p>
<p>99 Miscellaneous warning
The warning text may include arbitrary information to be presented to
a human user, or logged. A system receiving this warning MUST NOT
take any automated action.</p>
<p>14.46 WWW-Authenticate</p>
<p>The WWW-Authenticate response-header field MUST be included in 401
(Unauthorized) response messages. The field value consists of at
least one challenge that indicates the authentication scheme(s) and
parameters applicable to the Request-URI.</p>
<pre><code>      WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge
</code></pre>
<p>The HTTP access authentication process is described in section 11.
User agents MUST take special care in parsing the WWW-Authenticate
field value if it contains more than one challenge, or if more than
one WWW-Authenticate header field is provided, since the contents of
a challenge may itself contain a comma-separated list of
authentication parameters.</p>
<p>15 Security Considerations</p>
<p>This section is meant to inform application developers, information
providers, and users of the security limitations in HTTP/1.1 as
described by this document. The discussion does not include
definitive solutions to the problems revealed, though it does make
some suggestions for reducing security risks.</p>
<p>15.1 Authentication of Clients</p>
<p>The Basic authentication scheme is not a secure method of user
authentication, nor does it in any way protect the entity, which is
transmitted in clear text across the physical network used as the
carrier. HTTP does not prevent additional authentication schemes and
encryption mechanisms from being employed to increase security or the
addition of enhancements (such as schemes to use one-time passwords)
to Basic authentication.</p>
<p>Fielding, et. al.           Standards Track                   [Page 139]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The most serious flaw in Basic authentication is that it results in
the essentially clear text transmission of the user&rsquo;s password over
the physical network. It is this problem which Digest Authentication
attempts to address.</p>
<p>Because Basic authentication involves the clear text transmission of
passwords it SHOULD never be used (without enhancements) to protect
sensitive or valuable information.</p>
<p>A common use of Basic authentication is for identification purposes
&ndash; requiring the user to provide a user name and password as a means
of identification, for example, for purposes of gathering accurate
usage statistics on a server. When used in this way it is tempting to
think that there is no danger in its use if illicit access to the
protected documents is not a major concern. This is only correct if
the server issues both user name and password to the users and in
particular does not allow the user to choose his or her own password.
The danger arises because naive users frequently reuse a single
password to avoid the task of maintaining multiple passwords.</p>
<p>If a server permits users to select their own passwords, then the
threat is not only illicit access to documents on the server but also
illicit access to the accounts of all users who have chosen to use
their account password. If users are allowed to choose their own
password that also means the server must maintain files containing
the (presumably encrypted) passwords. Many of these may be the
account passwords of users perhaps at distant sites. The owner or
administrator of such a system could conceivably incur liability if
this information is not maintained in a secure fashion.</p>
<p>Basic Authentication is also vulnerable to spoofing by counterfeit
servers. If a user can be led to believe that he is connecting to a
host containing information protected by basic authentication when in
fact he is connecting to a hostile server or gateway then the
attacker can request a password, store it for later use, and feign an
error. This type of attack is not possible with Digest Authentication
[32]. Server implementers SHOULD guard against the possibility of
this sort of counterfeiting by gateways or CGI scripts. In particular
it is very dangerous for a server to simply turn over a connection to
a gateway since that gateway can then use the persistent connection
mechanism to engage in multiple transactions with the client while
impersonating the original server in a way that is not detectable by
the client.</p>
<p>15.2 Offering a Choice of Authentication Schemes</p>
<p>An HTTP/1.1 server may return multiple challenges with a 401
(Authenticate) response, and each challenge may use a different</p>
<p>Fielding, et. al.           Standards Track                   [Page 140]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>scheme.  The order of the challenges returned to the user agent is in
the order that the server would prefer they be chosen. The server
should order its challenges with the &ldquo;most secure&rdquo; authentication
scheme first. A user agent should choose as the challenge to be made
to the user the first one that the user agent understands.</p>
<p>When the server offers choices of authentication schemes using the
WWW-Authenticate header, the &ldquo;security&rdquo; of the authentication is only
as malicious user could capture the set of challenges and try to
authenticate him/herself using the weakest of the authentication
schemes. Thus, the ordering serves more to protect the user&rsquo;s
credentials than the server&rsquo;s information.</p>
<p>A possible man-in-the-middle (MITM) attack would be to add a weak
authentication scheme to the set of choices, hoping that the client
will use one that exposes the user&rsquo;s credentials (e.g. password). For
this reason, the client should always use the strongest scheme that
it understands from the choices accepted.</p>
<p>An even better MITM attack would be to remove all offered choices,
and to insert a challenge that requests Basic authentication. For
this reason, user agents that are concerned about this kind of attack
could remember the strongest authentication scheme ever requested by
a server and produce a warning message that requires user
confirmation before using a weaker one. A particularly insidious way
to mount such a MITM attack would be to offer a &ldquo;free&rdquo; proxy caching
service to gullible users.</p>
<p>15.3 Abuse of Server Log Information</p>
<p>A server is in the position to save personal data about a user&rsquo;s
requests which may identify their reading patterns or subjects of
interest. This information is clearly confidential in nature and its
handling may be constrained by law in certain countries. People using
the HTTP protocol to provide data are responsible for ensuring that
such material is not distributed without the permission of any
individuals that are identifiable by the published results.</p>
<p>15.4 Transfer of Sensitive Information</p>
<p>Like any generic data transfer protocol, HTTP cannot regulate the
content of the data that is transferred, nor is there any a priori
method of determining the sensitivity of any particular piece of
information within the context of any given request. Therefore,
applications SHOULD supply as much control over this information as
possible to the provider of that information. Four header fields are
worth special mention in this context: Server, Via, Referer and From.</p>
<p>Fielding, et. al.           Standards Track                   [Page 141]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Revealing the specific software version of the server may allow the
server machine to become more vulnerable to attacks against software
that is known to contain security holes. Implementers SHOULD make the
Server header field a configurable option.</p>
<p>Proxies which serve as a portal through a network firewall SHOULD
take special precautions regarding the transfer of header information
that identifies the hosts behind the firewall. In particular, they
SHOULD remove, or replace with sanitized versions, any Via fields
generated behind the firewall.</p>
<p>The Referer field allows reading patterns to be studied and reverse
links drawn. Although it can be very useful, its power can be abused
if user details are not separated from the information contained in
the Referer. Even when the personal information has been removed, the
Referer field may indicate a private document&rsquo;s URI whose publication
would be inappropriate.</p>
<p>The information sent in the From field might conflict with the user&rsquo;s
privacy interests or their site&rsquo;s security policy, and hence it
SHOULD NOT be transmitted without the user being able to disable,
enable, and modify the contents of the field. The user MUST be able
to set the contents of this field within a user preference or
application defaults configuration.</p>
<p>We suggest, though do not require, that a convenient toggle interface
be provided for the user to enable or disable the sending of From and
Referer information.</p>
<p>15.5 Attacks Based On File and Path Names</p>
<p>Implementations of HTTP origin servers SHOULD be careful to restrict
the documents returned by HTTP requests to be only those that were
intended by the server administrators. If an HTTP server translates
HTTP URIs directly into file system calls, the server MUST take
special care not to serve files that were not intended to be
delivered to HTTP clients.  For example, UNIX, Microsoft Windows, and
other operating systems use &ldquo;..&rdquo; as a path component to indicate a
directory level above the current one. On such a system, an HTTP
server MUST disallow any such construct in the Request-URI if it
would otherwise allow access to a resource outside those intended to
be accessible via the HTTP server. Similarly, files intended for
reference only internally to the server (such as access control
files, configuration files, and script code) MUST be protected from
inappropriate retrieval, since they might contain sensitive
information. Experience has shown that minor bugs in such HTTP server
implementations have turned into security risks.</p>
<p>Fielding, et. al.           Standards Track                   [Page 142]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>15.6 Personal Information</p>
<p>HTTP clients are often privy to large amounts of personal information
(e.g. the user&rsquo;s name, location, mail address, passwords, encryption
keys, etc.), and SHOULD be very careful to prevent unintentional
leakage of this information via the HTTP protocol to other sources.
We very strongly recommend that a convenient interface be provided
for the user to control dissemination of such information, and that
designers and implementers be particularly careful in this area.
History shows that errors in this area are often both serious
security and/or privacy problems, and often generate highly adverse
publicity for the implementer&rsquo;s company.</p>
<p>15.7 Privacy Issues Connected to Accept Headers</p>
<p>Accept request-headers can reveal information about the user to all
servers which are accessed. The Accept-Language header in particular
can reveal information the user would consider to be of a private
nature, because the understanding of particular languages is often
strongly correlated to the membership of a particular ethnic group.
User agents which offer the option to configure the contents of an
Accept-Language header to be sent in every request are strongly
encouraged to let the configuration process include a message which
makes the user aware of the loss of privacy involved.</p>
<p>An approach that limits the loss of privacy would be for a user agent
to omit the sending of Accept-Language headers by default, and to ask
the user whether it should start sending Accept-Language headers to a
server if it detects, by looking for any Vary response-header fields
generated by the server, that such sending could improve the quality
of service.</p>
<p>Elaborate user-customized accept header fields sent in every request,
in particular if these include quality values, can be used by servers
as relatively reliable and long-lived user identifiers. Such user
identifiers would allow content providers to do click-trail tracking,
and would allow collaborating content providers to match cross-server
click-trails or form submissions of individual users. Note that for
many users not behind a proxy, the network address of the host
running the user agent will also serve as a long-lived user
identifier. In environments where proxies are used to enhance
privacy, user agents should be conservative in offering accept header
configuration options to end users. As an extreme privacy measure,
proxies could filter the accept headers in relayed requests. General
purpose user agents which provide a high degree of header
configurability should warn users about the loss of privacy which can
be involved.</p>
<p>Fielding, et. al.           Standards Track                   [Page 143]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>15.8 DNS Spoofing</p>
<p>Clients using HTTP rely heavily on the Domain Name Service, and are
thus generally prone to security attacks based on the deliberate
mis-association of IP addresses and DNS names. Clients need to be
cautious in assuming the continuing validity of an IP number/DNS name
association.</p>
<p>In particular, HTTP clients SHOULD rely on their name resolver for
confirmation of an IP number/DNS name association, rather than
caching the result of previous host name lookups. Many platforms
already can cache host name lookups locally when appropriate, and
they SHOULD be configured to do so. These lookups should be cached,
however, only when the TTL (Time To Live) information reported by the
name server makes it likely that the cached information will remain
useful.</p>
<p>If HTTP clients cache the results of host name lookups in order to
achieve a performance improvement, they MUST observe the TTL
information reported by DNS.</p>
<p>If HTTP clients do not observe this rule, they could be spoofed when
a previously-accessed server&rsquo;s IP address changes. As network
renumbering is expected to become increasingly common, the
possibility of this form of attack will grow. Observing this
requirement thus reduces this potential security vulnerability.</p>
<p>This requirement also improves the load-balancing behavior of clients
for replicated servers using the same DNS name and reduces the
likelihood of a user&rsquo;s experiencing failure in accessing sites which
use that strategy.</p>
<p>15.9 Location Headers and Spoofing</p>
<p>If a single server supports multiple organizations that do not trust
one another, then it must check the values of Location and Content-
Location headers in responses that are generated under control of
said organizations to make sure that they do not attempt to
invalidate resources over which they have no authority.</p>
<p>16 Acknowledgments</p>
<p>This specification makes heavy use of the augmented BNF and generic
constructs defined by David H. Crocker for RFC 822. Similarly, it
reuses many of the definitions provided by Nathaniel Borenstein and
Ned Freed for MIME. We hope that their inclusion in this
specification will help reduce past confusion over the relationship
between HTTP and Internet mail message formats.</p>
<p>Fielding, et. al.           Standards Track                   [Page 144]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The HTTP protocol has evolved considerably over the past four years.
It has benefited from a large and active developer community&ndash;the
many people who have participated on the www-talk mailing list&ndash;and
it is that community which has been most responsible for the success
of HTTP and of the World-Wide Web in general. Marc Andreessen, Robert
Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois
Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc
VanHeyningen deserve special recognition for their efforts in
defining early aspects of the protocol.</p>
<p>This document has benefited greatly from the comments of all those
participating in the HTTP-WG. In addition to those already mentioned,
the following individuals have contributed to this specification:</p>
<pre><code>      Gary Adams                  Albert Lunde
      Harald Tveit Alvestrand     John C. Mallery
      Keith Ball                  Jean-Philippe Martin-Flatin
      Brian Behlendorf            Larry Masinter
      Paul Burchard               Mitra
      Maurizio Codogno            David Morris
      Mike Cowlishaw              Gavin Nicol
      Roman Czyborra              Bill Perry
      Michael A. Dolan            Jeffrey Perry
      David J. Fiander            Scott Powers
      Alan Freier                 Owen Rees
      Marc Hedlund                Luigi Rizzo
      Greg Herlihy                David Robinson
      Koen Holtman                Marc Salomon
      Alex Hopmann                Rich Salz
      Bob Jernigan                Allan M. Schiffman
      Shel Kaphan                 Jim Seidman
      Rohit Khare                 Chuck Shotton
      John Klensin                Eric W. Sink
      Martijn Koster              Simon E. Spero
      Alexei Kosut                Richard N. Taylor
      David M. Kristol            Robert S. Thau
      Daniel LaLiberte            Bill (BearHeart) Weinman
      Ben Laurie                  Francois Yergeau
      Paul J. Leach               Mary Ellen Zurko
      Daniel DuBois
</code></pre>
<p>Much of the content and presentation of the caching design is due to
suggestions and comments from individuals including: Shel Kaphan,
Paul Leach, Koen Holtman, David Morris, and Larry Masinter.</p>
<p>Fielding, et. al.           Standards Track                   [Page 145]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>Most of the specification of ranges is based on work originally done
by Ari Luotonen and John Franks, with additional input from Steve
Zilles.</p>
<p>Thanks to the &ldquo;cave men&rdquo; of Palo Alto. You know who you are.</p>
<p>Jim Gettys (the current editor of this document) wishes particularly
to thank Roy Fielding, the previous editor of this document, along
with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
Holtman, John Franks, Alex Hopmann, and Larry Masinter for their
help.</p>
<p>17 References</p>
<p>[1] Alvestrand, H., &ldquo;Tags for the identification of languages&rdquo;, RFC
1766, UNINETT, March 1995.</p>
<p>[2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,
D., and B. Alberti. &ldquo;The Internet Gopher Protocol: (a distributed
document search and retrieval protocol)&quot;, RFC 1436, University of
Minnesota, March 1993.</p>
<p>[3] Berners-Lee, T., &ldquo;Universal Resource Identifiers in WWW&rdquo;, A
Unifying Syntax for the Expression of Names and Addresses of Objects
on the Network as used in the World-Wide Web&rdquo;, RFC 1630, CERN, June
1994.</p>
<p>[4] Berners-Lee, T., Masinter, L., and M. McCahill, &ldquo;Uniform Resource
Locators (URL)&quot;, RFC 1738, CERN, Xerox PARC, University of Minnesota,
December 1994.</p>
<p>[5] Berners-Lee, T., and D. Connolly, &ldquo;HyperText Markup Language
Specification - 2.0&rdquo;, RFC 1866, MIT/LCS, November 1995.</p>
<p>[6] Berners-Lee, T., Fielding, R., and H. Frystyk, &ldquo;Hypertext
Transfer Protocol &ndash; HTTP/1.0.&quot;, RFC 1945 MIT/LCS, UC Irvine, May
1996.</p>
<p>[7] Freed, N., and N. Borenstein, &ldquo;Multipurpose Internet Mail
Extensions (MIME) Part One: Format of Internet Message Bodies&rdquo;, RFC
2045, Innosoft, First Virtual, November 1996.</p>
<p>[8] Braden, R., &ldquo;Requirements for Internet hosts - application and
support&rdquo;, STD 3,  RFC 1123, IETF, October 1989.</p>
<p>[9] Crocker, D., &ldquo;Standard for the Format of ARPA Internet Text
Messages&rdquo;, STD 11, RFC 822, UDEL, August 1982.</p>
<p>Fielding, et. al.           Standards Track                   [Page 146]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>[10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,
Sui, J., and M. Grinbaum. &ldquo;WAIS Interface Protocol Prototype
Functional Specification&rdquo;, (v1.5), Thinking Machines Corporation,
April 1990.</p>
<p>[11] Fielding, R., &ldquo;Relative Uniform Resource Locators&rdquo;, RFC 1808, UC
Irvine, June 1995.</p>
<p>[12] Horton, M., and R. Adams. &ldquo;Standard for interchange of USENET
messages&rdquo;, RFC 1036, AT&amp;T Bell Laboratories, Center for Seismic
Studies, December 1987.</p>
<p>[13] Kantor, B., and P. Lapsley. &ldquo;Network News Transfer Protocol.&rdquo; A
Proposed Standard for the Stream-Based Transmission of News&rdquo;, RFC
977, UC San Diego, UC Berkeley, February 1986.</p>
<p>[14] Moore, K., &ldquo;MIME (Multipurpose Internet Mail Extensions) Part
Three: Message Header Extensions for Non-ASCII Text&rdquo;, RFC 2047,
University of Tennessee, November 1996.</p>
<p>[15] Nebel, E., and L. Masinter. &ldquo;Form-based File Upload in HTML&rdquo;,
RFC 1867, Xerox Corporation, November 1995.</p>
<p>[16] Postel, J., &ldquo;Simple Mail Transfer Protocol&rdquo;, STD 10, RFC 821,
USC/ISI, August 1982.</p>
<p>[17] Postel, J., &ldquo;Media Type Registration Procedure&rdquo;, RFC 2048,
USC/ISI, November 1996.</p>
<p>[18] Postel, J., and J. Reynolds, &ldquo;File Transfer Protocol (FTP)&quot;, STD
9, RFC 959, USC/ISI, October 1985.</p>
<p>[19] Reynolds, J., and J. Postel, &ldquo;Assigned Numbers&rdquo;, STD 2, RFC
1700, USC/ISI, October 1994.</p>
<p>[20] Sollins, K., and L. Masinter, &ldquo;Functional Requirements for
Uniform Resource Names&rdquo;, RFC 1737, MIT/LCS, Xerox Corporation,
December 1994.</p>
<p>[21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for
Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.</p>
<p>[22] ISO-8859. International Standard &ndash; Information Processing &ndash;
8-bit Single-Byte Coded Graphic Character Sets &ndash;
Part 1: Latin alphabet No. 1, ISO 8859-1:1987.
Part 2: Latin alphabet No. 2, ISO 8859-2, 1987.
Part 3: Latin alphabet No. 3, ISO 8859-3, 1988.
Part 4: Latin alphabet No. 4, ISO 8859-4, 1988.</p>
<p>Fielding, et. al.           Standards Track                   [Page 147]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<pre><code> Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988.
 Part 6: Latin/Arabic alphabet, ISO 8859-6, 1987.
 Part 7: Latin/Greek alphabet, ISO 8859-7, 1987.
 Part 8: Latin/Hebrew alphabet, ISO 8859-8, 1988.
 Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.
</code></pre>
<p>[23] Meyers, J., and M. Rose &ldquo;The Content-MD5 Header Field&rdquo;, RFC
1864, Carnegie Mellon, Dover Beach Consulting, October, 1995.</p>
<p>[24] Carpenter, B., and Y. Rekhter, &ldquo;Renumbering Needs Work&rdquo;, RFC
1900, IAB, February 1996.</p>
<p>[25] Deutsch, P., &ldquo;GZIP file format specification version 4.3.&rdquo; RFC
1952, Aladdin Enterprises, May 1996.</p>
<p>[26] Venkata N. Padmanabhan and Jeffrey C. Mogul. Improving HTTP
Latency. Computer Networks and ISDN Systems, v. 28, pp. 25-35, Dec.
1995.  Slightly revised version of paper in Proc. 2nd International
WWW Conf. &lsquo;94: Mosaic and the Web, Oct. 1994, which is available at
<a href="http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/">http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/</a>
HTTPLatency.html.</p>
<p>[27] Joe Touch, John Heidemann, and Katia Obraczka, &ldquo;Analysis of HTTP
Performance&rdquo;, &lt;URL: <a href="http://www.isi.edu/lsam/ib/http-perf/%3E,">http://www.isi.edu/lsam/ib/http-perf/&gt;,</a>
USC/Information Sciences Institute, June 1996</p>
<p>[28] Mills, D., &ldquo;Network Time Protocol, Version 3, Specification,
Implementation and Analysis&rdquo;, RFC 1305, University of Delaware, March
1992.</p>
<p>[29] Deutsch, P., &ldquo;DEFLATE Compressed Data Format Specification
version 1.3.&rdquo; RFC 1951, Aladdin Enterprises, May 1996.</p>
<p>[30] Spero, S., &ldquo;Analysis of HTTP Performance Problems&rdquo;
<a href="URL:http://sunsite.unc.edu/mdma-release/http-prob.html">URL:http://sunsite.unc.edu/mdma-release/http-prob.html</a>.</p>
<p>[31] Deutsch, P., and J-L. Gailly, &ldquo;ZLIB Compressed Data Format
Specification version 3.3&rdquo;, RFC 1950, Aladdin Enterprises, Info-ZIP,
May 1996.</p>
<p>[32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,
Luotonen, A., Sink, E., and L. Stewart, &ldquo;An Extension to HTTP :
Digest Access Authentication&rdquo;, RFC 2069, January 1997.</p>
<p>Fielding, et. al.           Standards Track                   [Page 148]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>18 Authors&rsquo; Addresses</p>
<p>Roy T. Fielding
Department of Information and Computer Science
University of California
Irvine, CA 92717-3425, USA</p>
<p>Fax: +1 (714) 824-4056
EMail: <a href="mailto:fielding@ics.uci.edu">fielding@ics.uci.edu</a></p>
<p>Jim Gettys
MIT Laboratory for Computer Science
545 Technology Square
Cambridge, MA 02139, USA</p>
<p>Fax: +1 (617) 258 8682
EMail: <a href="mailto:jg@w3.org">jg@w3.org</a></p>
<p>Jeffrey C. Mogul
Western Research Laboratory
Digital Equipment Corporation
250 University Avenue
Palo Alto, California, 94305, USA</p>
<p>EMail: <a href="mailto:mogul@wrl.dec.com">mogul@wrl.dec.com</a></p>
<p>Henrik Frystyk Nielsen
W3 Consortium
MIT Laboratory for Computer Science
545 Technology Square
Cambridge, MA 02139, USA</p>
<p>Fax: +1 (617) 258 8682
EMail: <a href="mailto:frystyk@w3.org">frystyk@w3.org</a></p>
<p>Tim Berners-Lee
Director, W3 Consortium
MIT Laboratory for Computer Science
545 Technology Square
Cambridge, MA 02139, USA</p>
<p>Fax: +1 (617) 258 8682
EMail: <a href="mailto:timbl@w3.org">timbl@w3.org</a></p>
<p>Fielding, et. al.           Standards Track                   [Page 149]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>19 Appendices</p>
<p>19.1 Internet Media Type message/http</p>
<p>In addition to defining the HTTP/1.1 protocol, this document serves
as the specification for the Internet media type &ldquo;message/http&rdquo;. The
following is to be registered with IANA.</p>
<pre><code>   Media Type name:         message
   Media subtype name:      http
   Required parameters:     none
   Optional parameters:     version, msgtype

    version: The HTTP-Version number of the enclosed message
             (e.g., &quot;1.1&quot;). If not present, the version can be
             determined from the first line of the body.

    msgtype: The message type -- &quot;request&quot; or &quot;response&quot;. If not
             present, the type can be determined from the first
             line of the body.

   Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                            permitted

   Security considerations: none
</code></pre>
<p>19.2 Internet Media Type multipart/byteranges</p>
<p>When an HTTP message includes the content of multiple ranges (for
example, a response to a request for multiple non-overlapping
ranges), these are transmitted as a multipart MIME message. The
multipart media type for this purpose is called
&ldquo;multipart/byteranges&rdquo;.</p>
<p>The multipart/byteranges media type includes two or more parts, each
with its own Content-Type and Content-Range fields. The parts are
separated using a MIME boundary parameter.</p>
<pre><code>      Media Type name:         multipart
      Media subtype name:      byteranges
      Required parameters:     boundary
      Optional parameters:     none

      Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                               permitted

      Security considerations: none
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 150]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>For example:</p>
<p>HTTP/1.1 206 Partial content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES</p>
<p>&ndash;THIS_STRING_SEPARATES
Content-type: application/pdf
Content-range: bytes 500-999/8000</p>
<p>&hellip;the first range&hellip;
&ndash;THIS_STRING_SEPARATES
Content-type: application/pdf
Content-range: bytes 7000-7999/8000</p>
<p>&hellip;the second range
&ndash;THIS_STRING_SEPARATES&ndash;</p>
<p>19.3 Tolerant Applications</p>
<p>Although this document specifies the requirements for the generation
of HTTP/1.1 messages, not all applications will be correct in their
implementation. We therefore recommend that operational applications
be tolerant of deviations whenever those deviations can be
interpreted unambiguously.</p>
<p>Clients SHOULD be tolerant in parsing the Status-Line and servers
tolerant when parsing the Request-Line. In particular, they SHOULD
accept any amount of SP or HT characters between fields, even though
only a single SP is required.</p>
<p>The line terminator for message-header fields is the sequence CRLF.
However, we recommend that applications, when parsing such headers,
recognize a single LF as a line terminator and ignore the leading CR.</p>
<p>The character set of an entity-body should be labeled as the lowest
common denominator of the character codes used within that body, with
the exception that no label is preferred over the labels US-ASCII or
ISO-8859-1.</p>
<p>Additional rules for requirements on parsing and encoding of dates
and other potential problems with date encodings include:</p>
<p>o  HTTP/1.1 clients and caches should assume that an RFC-850 date
which appears to be more than 50 years in the future is in fact
in the past (this helps solve the &ldquo;year 2000&rdquo; problem).</p>
<p>Fielding, et. al.           Standards Track                   [Page 151]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>o  An HTTP/1.1 implementation may internally represent a parsed
Expires date as earlier than the proper value, but MUST NOT
internally represent a parsed Expires date as later than the
proper value.</p>
<p>o  All expiration-related calculations must be done in GMT. The
local time zone MUST NOT influence the calculation or comparison
of an age or expiration time.</p>
<p>o  If an HTTP header incorrectly carries a date value with a time
zone other than GMT, it must be converted into GMT using the most
conservative possible conversion.</p>
<p>19.4 Differences Between HTTP Entities and MIME Entities</p>
<p>HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC
822) and the Multipurpose Internet Mail Extensions (MIME ) to allow
entities to be transmitted in an open variety of representations and
with extensible mechanisms. However, MIME [7] discusses mail, and
HTTP has a few features that are different from those described in
MIME.  These differences were carefully chosen to optimize
performance over binary connections, to allow greater freedom in the
use of new media types, to make date comparisons easier, and to
acknowledge the practice of some early HTTP servers and clients.</p>
<p>This appendix describes specific areas where HTTP differs from MIME.
Proxies and gateways to strict MIME environments SHOULD be aware of
these differences and provide the appropriate conversions where
necessary. Proxies and gateways from MIME environments to HTTP also
need to be aware of the differences because some conversions may be
required.</p>
<p>19.4.1 Conversion to Canonical Form</p>
<p>MIME requires that an Internet mail entity be converted to canonical
form prior to being transferred.  Section 3.7.1 of this document
describes the forms allowed for subtypes of the &ldquo;text&rdquo; media type
when transmitted over HTTP. MIME requires that content with a type of
&ldquo;text&rdquo; represent line breaks as CRLF and forbids the use of CR or LF
outside of line break sequences.  HTTP allows CRLF, bare CR, and bare
LF to indicate a line break within text content when a message is
transmitted over HTTP.</p>
<p>Where it is possible, a proxy or gateway from HTTP to a strict MIME
environment SHOULD translate all line breaks within the text media
types described in section 3.7.1 of this document to the MIME
canonical form of CRLF. Note, however, that this may be complicated
by the presence of a Content-Encoding and by the fact that HTTP</p>
<p>Fielding, et. al.           Standards Track                   [Page 152]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>allows the use of some character sets which do not use octets 13 and
10 to represent CR and LF, as is the case for some multi-byte
character sets.</p>
<p>19.4.2 Conversion of Date Formats</p>
<p>HTTP/1.1 uses a restricted set of date formats (section 3.3.1) to
simplify the process of date comparison. Proxies and gateways from
other protocols SHOULD ensure that any Date header field present in a
message conforms to one of the HTTP/1.1 formats and rewrite the date
if necessary.</p>
<p>19.4.3 Introduction of Content-Encoding</p>
<p>MIME does not include any concept equivalent to HTTP/1.1&rsquo;s Content-
Encoding header field. Since this acts as a modifier on the media
type, proxies and gateways from HTTP to MIME-compliant protocols MUST
either change the value of the Content-Type header field or decode
the entity-body before forwarding the message. (Some experimental
applications of Content-Type for Internet mail have used a media-type
parameter of &ldquo;;conversions=<!-- raw HTML omitted -->&rdquo; to perform an equivalent
function as Content-Encoding. However, this parameter is not part of
MIME.)</p>
<p>19.4.4 No Content-Transfer-Encoding</p>
<p>HTTP does not use the Content-Transfer-Encoding (CTE) field of MIME.
Proxies and gateways from MIME-compliant protocols to HTTP MUST
remove any non-identity CTE (&ldquo;quoted-printable&rdquo; or &ldquo;base64&rdquo;) encoding
prior to delivering the response message to an HTTP client.</p>
<p>Proxies and gateways from HTTP to MIME-compliant protocols are
responsible for ensuring that the message is in the correct format
and encoding for safe transport on that protocol, where &ldquo;safe
transport&rdquo; is defined by the limitations of the protocol being used.
Such a proxy or gateway SHOULD label the data with an appropriate
Content-Transfer-Encoding if doing so will improve the likelihood of
safe transport over the destination protocol.</p>
<p>19.4.5 HTTP Header Fields in Multipart Body-Parts</p>
<p>In MIME, most header fields in multipart body-parts are generally
ignored unless the field name begins with &ldquo;Content-&quot;. In HTTP/1.1,
multipart body-parts may contain any HTTP header fields which are
significant to the meaning of that part.</p>
<p>Fielding, et. al.           Standards Track                   [Page 153]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>19.4.6 Introduction of Transfer-Encoding</p>
<p>HTTP/1.1 introduces the Transfer-Encoding header field (section
14.40).  Proxies/gateways MUST remove any transfer coding prior to
forwarding a message via a MIME-compliant protocol.</p>
<p>A process for decoding the &ldquo;chunked&rdquo; transfer coding (section 3.6)
can be represented in pseudo-code as:</p>
<pre><code>      length := 0
      read chunk-size, chunk-ext (if any) and CRLF
      while (chunk-size &gt; 0) {
         read chunk-data and CRLF
         append chunk-data to entity-body
         length := length + chunk-size
         read chunk-size and CRLF
      }
      read entity-header
      while (entity-header not empty) {
         append entity-header to existing header fields
         read entity-header
      }
      Content-Length := length
      Remove &quot;chunked&quot; from Transfer-Encoding
</code></pre>
<p>19.4.7 MIME-Version</p>
<p>HTTP is not a MIME-compliant protocol (see appendix 19.4). However,
HTTP/1.1 messages may include a single MIME-Version general-header
field to indicate what version of the MIME protocol was used to
construct the message. Use of the MIME-Version header field indicates
that the message is in full compliance with the MIME protocol.
Proxies/gateways are responsible for ensuring full compliance (where
possible) when exporting HTTP messages to strict MIME environments.</p>
<pre><code>      MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT
</code></pre>
<p>MIME version &ldquo;1.0&rdquo; is the default for use in HTTP/1.1. However,
HTTP/1.1 message parsing and semantics are defined by this document
and not the MIME specification.</p>
<p>19.5 Changes from HTTP/1.0</p>
<p>This section summarizes major differences between versions HTTP/1.0
and HTTP/1.1.</p>
<p>Fielding, et. al.           Standards Track                   [Page 154]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>19.5.1 Changes to Simplify Multi-homed Web Servers and Conserve IP
Addresses</p>
<p>The requirements that clients and servers support the Host request-
header, report an error if the Host request-header (section 14.23) is
missing from an HTTP/1.1 request, and accept absolute URIs (section
5.1.2) are among the most important changes defined by this
specification.</p>
<p>Older HTTP/1.0 clients assumed a one-to-one relationship of IP
addresses and servers; there was no other established mechanism for
distinguishing the intended server of a request than the IP address
to which that request was directed. The changes outlined above will
allow the Internet, once older HTTP clients are no longer common, to
support multiple Web sites from a single IP address, greatly
simplifying large operational Web servers, where allocation of many
IP addresses to a single host has created serious problems. The
Internet will also be able to recover the IP addresses that have been
allocated for the sole purpose of allowing special-purpose domain
names to be used in root-level HTTP URLs. Given the rate of growth of
the Web, and the number of servers already deployed, it is extremely
important that all implementations of HTTP (including updates to
existing HTTP/1.0 applications) correctly implement these
requirements:</p>
<pre><code> o  Both clients and servers MUST support the Host request-header.

 o  Host request-headers are required in HTTP/1.1 requests.

 o  Servers MUST report a 400 (Bad Request) error if an HTTP/1.1
    request does not include a Host request-header.

 o  Servers MUST accept absolute URIs.
</code></pre>
<p>Fielding, et. al.           Standards Track                   [Page 155]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>19.6 Additional Features</p>
<p>This appendix documents protocol elements used by some existing HTTP
implementations, but not consistently and correctly across most
HTTP/1.1 applications. Implementers should be aware of these
features, but cannot rely upon their presence in, or interoperability
with, other HTTP/1.1 applications. Some of these describe proposed
experimental features, and some describe features that experimental
deployment found lacking that are now addressed in the base HTTP/1.1
specification.</p>
<p>19.6.1 Additional Request Methods</p>
<p>19.6.1.1 PATCH</p>
<p>The PATCH method is similar to PUT except that the entity contains a
list of differences between the original version of the resource
identified by the Request-URI and the desired content of the resource
after the PATCH action has been applied. The list of differences is
in a format defined by the media type of the entity (e.g.,
&ldquo;application/diff&rdquo;) and MUST include sufficient information to allow
the server to recreate the changes necessary to convert the original
version of the resource to the desired version.</p>
<p>If the request passes through a cache and the Request-URI identifies
a currently cached entity, that entity MUST be removed from the
cache.  Responses to this method are not cachable.</p>
<p>The actual method for determining how the patched resource is placed,
and what happens to its predecessor, is defined entirely by the
origin server. If the original version of the resource being patched
included a Content-Version header field, the request entity MUST
include a Derived-From header field corresponding to the value of the
original Content-Version header field. Applications are encouraged to
use these fields for constructing versioning relationships and
resolving version conflicts.</p>
<p>PATCH requests must obey the message transmission requirements set
out in section 8.2.</p>
<p>Caches that implement PATCH should invalidate cached responses as
defined in section 13.10 for PUT.</p>
<p>19.6.1.2 LINK</p>
<p>The LINK method establishes one or more Link relationships between
the existing resource identified by the Request-URI and other
existing resources. The difference between LINK and other methods</p>
<p>Fielding, et. al.           Standards Track                   [Page 156]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>allowing links to be established between resources is that the LINK
method does not allow any message-body to be sent in the request and
does not directly result in the creation of new resources.</p>
<p>If the request passes through a cache and the Request-URI identifies
a currently cached entity, that entity MUST be removed from the
cache.  Responses to this method are not cachable.</p>
<p>Caches that implement LINK should invalidate cached responses as
defined in section 13.10 for PUT.</p>
<p>19.6.1.3 UNLINK</p>
<p>The UNLINK method removes one or more Link relationships from the
existing resource identified by the Request-URI. These relationships
may have been established using the LINK method or by any other
method supporting the Link header. The removal of a link to a
resource does not imply that the resource ceases to exist or becomes
inaccessible for future references.</p>
<p>If the request passes through a cache and the Request-URI identifies
a currently cached entity, that entity MUST be removed from the
cache.  Responses to this method are not cachable.</p>
<p>Caches that implement UNLINK should invalidate cached responses as
defined in section 13.10 for PUT.</p>
<p>19.6.2 Additional Header Field Definitions</p>
<p>19.6.2.1 Alternates</p>
<p>The Alternates response-header field has been proposed as a means for
the origin server to inform the client about other available
representations of the requested resource, along with their
distinguishing attributes, and thus providing a more reliable means
for a user agent to perform subsequent selection of another
representation which better fits the desires of its user (described
as agent-driven negotiation in section 12).</p>
<p>Fielding, et. al.           Standards Track                   [Page 157]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>The Alternates header field is orthogonal to the Vary header field in
that both may coexist in a message without affecting the
interpretation of the response or the available representations. It
is expected that Alternates will provide a significant improvement
over the server-driven negotiation provided by the Vary field for
those resources that vary over common dimensions like type and
language.</p>
<p>The Alternates header field will be defined in a future
specification.</p>
<p>19.6.2.2 Content-Version</p>
<p>The Content-Version entity-header field defines the version tag
associated with a rendition of an evolving entity. Together with the
Derived-From field described in section 19.6.2.3, it allows a group
of people to work simultaneously on the creation of a work as an
iterative process. The field should be used to allow evolution of a
particular work along a single path rather than derived works or
renditions in different representations.</p>
<pre><code>      Content-Version = &quot;Content-Version&quot; &quot;:&quot; quoted-string
</code></pre>
<p>Examples of the Content-Version field include:</p>
<pre><code>      Content-Version: &quot;2.1.2&quot;
      Content-Version: &quot;Fred 19950116-12:26:48&quot;
      Content-Version: &quot;2.5a4-omega7&quot;
</code></pre>
<p>19.6.2.3 Derived-From</p>
<p>The Derived-From entity-header field can be used to indicate the
version tag of the resource from which the enclosed entity was
derived before modifications were made by the sender. This field is
used to help manage the process of merging successive changes to a
resource, particularly when such changes are being made in parallel
and from multiple sources.</p>
<pre><code>      Derived-From   = &quot;Derived-From&quot; &quot;:&quot; quoted-string
</code></pre>
<p>An example use of the field is:</p>
<pre><code>      Derived-From: &quot;2.1.1&quot;
</code></pre>
<p>The Derived-From field is required for PUT and PATCH requests if the
entity being sent was previously retrieved from the same URI and a
Content-Version header was included with the entity when it was last
retrieved.</p>
<p>Fielding, et. al.           Standards Track                   [Page 158]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>19.6.2.4 Link</p>
<p>The Link entity-header field provides a means for describing a
relationship between two resources, generally between the requested
resource and some other resource. An entity MAY include multiple Link
values. Links at the metainformation level typically indicate
relationships like hierarchical structure and navigation paths. The
Link field is semantically equivalent to the <!-- raw HTML omitted --> element in
HTML.[5]</p>
<pre><code>      Link           = &quot;Link&quot; &quot;:&quot; #(&quot;&lt;&quot; URI &quot;&gt;&quot; *( &quot;;&quot; link-param )

      link-param     = ( ( &quot;rel&quot; &quot;=&quot; relationship )
                         | ( &quot;rev&quot; &quot;=&quot; relationship )
                         | ( &quot;title&quot; &quot;=&quot; quoted-string )
                         | ( &quot;anchor&quot; &quot;=&quot; &lt;&quot;&gt; URI &lt;&quot;&gt; )
                         | ( link-extension ) )

      link-extension = token [ &quot;=&quot; ( token | quoted-string ) ]

      relationship   = sgml-name
                     | ( &lt;&quot;&gt; sgml-name *( SP sgml-name) &lt;&quot;&gt; )

      sgml-name      = ALPHA *( ALPHA | DIGIT | &quot;.&quot; | &quot;-&quot; )
</code></pre>
<p>Relationship values are case-insensitive and MAY be extended within
the constraints of the sgml-name syntax. The title parameter MAY be
used to label the destination of a link such that it can be used as
identification within a human-readable menu. The anchor parameter MAY
be used to indicate a source anchor other than the entire current
resource, such as a fragment of this resource or a third resource.</p>
<p>Examples of usage include:</p>
<pre><code>   Link: &lt;http://www.cern.ch/TheBook/chapter2&gt;; rel=&quot;Previous&quot;

   Link: &lt;mailto:timbl@w3.org&gt;; rev=&quot;Made&quot;; title=&quot;Tim Berners-Lee&quot;
</code></pre>
<p>The first example indicates that chapter2 is previous to this
resource in a logical navigation path. The second indicates that the
person responsible for making the resource available is identified by
the given e-mail address.</p>
<p>19.6.2.5 URI</p>
<p>The URI header field has, in past versions of this specification,
been used as a combination of the existing Location, Content-
Location, and Vary header fields as well as the future Alternates</p>
<p>Fielding, et. al.           Standards Track                   [Page 159]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>field (above). Its primary purpose has been to include a list of
additional URIs for the resource, including names and mirror
locations. However, it has become clear that the combination of many
different functions within this single field has been a barrier to
consistently and correctly implementing any of those functions.
Furthermore, we believe that the identification of names and mirror
locations would be better performed via the Link header field. The
URI header field is therefore deprecated in favor of those other
fields.</p>
<pre><code>      URI-header    = &quot;URI&quot; &quot;:&quot; 1#( &quot;&lt;&quot; URI &quot;&gt;&quot; )
</code></pre>
<p>19.7 Compatibility with Previous Versions</p>
<p>It is beyond the scope of a protocol specification to mandate
compliance with previous versions. HTTP/1.1 was deliberately
designed, however, to make supporting previous versions easy. It is
worth noting that at the time of composing this specification, we
would expect commercial HTTP/1.1 servers to:</p>
<p>o  recognize the format of the Request-Line for HTTP/0.9, 1.0, and 1.1
requests;</p>
<p>o  understand any valid request in the format of HTTP/0.9, 1.0, or
1.1;</p>
<p>o  respond appropriately with a message in the same major version used
by the client.</p>
<p>And we would expect HTTP/1.1 clients to:</p>
<p>o  recognize the format of the Status-Line for HTTP/1.0 and 1.1
responses;</p>
<p>o  understand any valid response in the format of HTTP/0.9, 1.0, or
1.1.</p>
<p>For most implementations of HTTP/1.0, each connection is established
by the client prior to the request and closed by the server after
sending the response. A few implementations implement the Keep-Alive
version of persistent connections described in section 19.7.1.1.</p>
<p>Fielding, et. al.           Standards Track                   [Page 160]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>19.7.1 Compatibility with HTTP/1.0 Persistent Connections</p>
<p>Some clients and servers may wish to be compatible with some previous
implementations of persistent connections in HTTP/1.0 clients and
servers. Persistent connections in HTTP/1.0 must be explicitly
negotiated as they are not the default behavior. HTTP/1.0
experimental implementations of persistent connections are faulty,
and the new facilities in HTTP/1.1 are designed to rectify these
problems. The problem was that some existing 1.0 clients may be
sending Keep-Alive to a proxy server that doesn&rsquo;t understand
Connection, which would then erroneously forward it to the next
inbound server, which would establish the Keep-Alive connection and
result in a hung HTTP/1.0 proxy waiting for the close on the
response. The result is that HTTP/1.0 clients must be prevented from
using Keep-Alive when talking to proxies.</p>
<p>However, talking to proxies is the most important use of persistent
connections, so that prohibition is clearly unacceptable. Therefore,
we need some other mechanism for indicating a persistent connection
is desired, which is safe to use even when talking to an old proxy
that ignores Connection. Persistent connections are the default for
HTTP/1.1 messages; we introduce a new keyword (Connection: close) for
declaring non-persistence.</p>
<p>The following describes the original HTTP/1.0 form of persistent
connections.</p>
<p>When it connects to an origin server, an HTTP client MAY send the
Keep-Alive connection-token in addition to the Persist connection-
token:</p>
<pre><code>      Connection: Keep-Alive
</code></pre>
<p>An HTTP/1.0 server would then respond with the Keep-Alive connection
token and the client may proceed with an HTTP/1.0 (or Keep-Alive)
persistent connection.</p>
<p>An HTTP/1.1 server may also establish persistent connections with
HTTP/1.0 clients upon receipt of a Keep-Alive connection token.
However, a persistent connection with an HTTP/1.0 client cannot make
use of the chunked transfer-coding, and therefore MUST use a
Content-Length for marking the ending boundary of each message.</p>
<p>A client MUST NOT send the Keep-Alive connection token to a proxy
server as HTTP/1.0 proxy servers do not obey the rules of HTTP/1.1
for parsing the Connection header field.</p>
<p>Fielding, et. al.           Standards Track                   [Page 161]</p>
<p>RFC 2068                        HTTP/1.1                    January 1997</p>
<p>19.7.1.1 The Keep-Alive Header</p>
<p>When the Keep-Alive connection-token has been transmitted with a
request or a response, a Keep-Alive header field MAY also be
included. The Keep-Alive header field takes the following form:</p>
<pre><code>      Keep-Alive-header = &quot;Keep-Alive&quot; &quot;:&quot; 0# keepalive-param

      keepalive-param = param-name &quot;=&quot; value
</code></pre>
<p>The Keep-Alive header itself is optional, and is used only if a
parameter is being sent. HTTP/1.1 does not define any parameters.</p>
<p>If the Keep-Alive header is sent, the corresponding connection token
MUST be transmitted. The Keep-Alive header MUST be ignored if
received without the connection token.</p>
<p>Fielding, et. al.           Standards Track                   [Page 162]</p>

    </article>

    <nav class="site-nav">
  <a href="/">Home</a>
  <a href="/post/">All posts</a>

  

  
  <a href="https://github.com/Owicca">GitHub</a>

  
</nav>


    <footer class="site-footer">
  <span class="owner">Â©2020 OWicca</span>

  

  
</footer>


  </div>

  
<script src="https://www.dinudev.com/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


</body>

</html>
