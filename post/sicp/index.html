<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="OWicca"><meta name=generator content="Hugo 0.102.3"><title>SICP — Down the wabbit's hole</title><meta name=description content><link rel=canonical href=https://www.dinudev.com/post/sicp/><link href rel=alternate type=application/rss+xml title="Down the wabbit's hole"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=https://www.dinudev.com/css/highlight.css><link rel=stylesheet href=https://www.dinudev.com/css/paperback.css><link rel=stylesheet href=https://www.dinudev.com/css/main.css></head><body><div class=container><header><h1>SICP</h1><nav class=site-nav><a href=/>Home</a>
<a href=/post/>All posts</a>
<a href=/journey/>The journey</a>
<a href=/paper/>Papers</a></nav></header><article><h3 id=scheme-syntax>Scheme syntax:</h3><ul><li>reverse enginered from book code snipets and &ldquo;trial and error&rdquo;</li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>start_delimiter = <span style=color:#e6db74>&#34;(&#34;</span>;
</span></span><span style=display:flex><span>end_delimiter = <span style=color:#e6db74>&#34;)&#34;</span>;
</span></span><span style=display:flex><span>space = <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>definition_keyword = <span style=color:#e6db74>&#34;define&#34;</span>;
</span></span><span style=display:flex><span>keyword = definition_keyword;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>digit = <span style=color:#e6db74>&#34;1&#34;</span>|<span style=color:#e6db74>&#34;2&#34;</span>|<span style=color:#e6db74>&#34;3&#34;</span>|<span style=color:#e6db74>&#34;4&#34;</span>|<span style=color:#e6db74>&#34;5&#34;</span>|<span style=color:#e6db74>&#34;6&#34;</span>|<span style=color:#e6db74>&#34;7&#34;</span>|<span style=color:#e6db74>&#34;8&#34;</span>|<span style=color:#e6db74>&#34;9&#34;</span> [{, <span style=color:#e6db74>&#34;0&#34;</span>|<span style=color:#e6db74>&#34;1&#34;</span>|<span style=color:#e6db74>&#34;2&#34;</span>|<span style=color:#e6db74>&#34;3&#34;</span>|<span style=color:#e6db74>&#34;4&#34;</span>|<span style=color:#e6db74>&#34;5&#34;</span>|<span style=color:#e6db74>&#34;6&#34;</span>|<span style=color:#e6db74>&#34;7&#34;</span>|<span style=color:#e6db74>&#34;8&#34;</span>|<span style=color:#e6db74>&#34;9&#34;</span> }];
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> = digit , <span style=color:#e6db74>&#34;.&#34;</span> , digit [{, digit }];
</span></span><span style=display:flex><span>number = digit [{, digit }];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>alpha_character = {a...z}|{A...Z}
</span></span><span style=display:flex><span>character = alpha_character|<span style=color:#e6db74>&#34;_&#34;</span>|digit|<span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> = alpha_character [{, character }];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>primitive_operator = <span style=color:#e6db74>&#34;+&#34;</span>|<span style=color:#e6db74>&#34;-&#34;</span>|<span style=color:#e6db74>&#34;*&#34;</span>|<span style=color:#e6db74>&#34;/&#34;</span>|<span style=color:#e6db74>&#34;%&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>operator</span> = primitive_operator|expression_between_parentheses;
</span></span><span style=display:flex><span>expression_between_parentheses = start_delimiter , space , expression , space , end_delimiter;
</span></span><span style=display:flex><span>expression = start_delimiter , [<span style=color:#66d9ef>operator</span>] , space , digit|<span style=color:#66d9ef>float</span>|number|character|<span style=color:#66d9ef>string</span>|expression,function_call [{, space , digit|<span style=color:#66d9ef>float</span>|number|character|<span style=color:#66d9ef>string</span>|expression|function_call }] , space , end_delimiter;(* can a compound <span style=color:#66d9ef>operator</span> receive a single param? *)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>identifier_definition = start_delimiter , definition_keyword , space, start_delimiter , <span style=color:#66d9ef>string</span> [{, space , <span style=color:#66d9ef>string</span>}] , end_delimiter , space , expression_between_parentheses , end_delimiter;
</span></span><span style=display:flex><span>function_call = start_delimiter , <span style=color:#66d9ef>string</span> [, {(, space , identifier_0)...(, space , identifier_N)}] , end_delimiter;
</span></span><span style=display:flex><span>function_definition = stat_delimiter , definition_keyword , space , function_call , space , function_body , end_delimiter;</span></span></code></pre></div></li></ul><h3 id=building-abstractions-with-procedures>Building Abstractions with Procedures:</h3><ul><li>complex software is built modularly so that the parts can be constructed, replaced and debugged separatedly</li><li>three mechanisms to create complex expressions:<ul><li>primitive expressions</li><li>means of combinations: used to build compound elements from simpler ones</li><li>means of abstraction: how compound elements can be named and manipulated as units</li></ul></li><li>you can&rsquo;t express computation without defining the environment in which is to be expressed</li><li>primitives:<ul><li>data: stuff</li><li>procedures: descriptions of the rules for manipulating data</li></ul></li><li>tree accumulation:<ul><li>evaluate the values of every child of the node(recursively)</li><li>and THEN evaluate the value of the node</li></ul></li><li>lexical scoping: variables in a procedure are bound by the enclosing block scope(they are looked up in the environment)</li><li>block scoping: variables and definitions in a procedure are bound(private) to the scope of said procedure</li><li>recursivity alone, enables every mathematical computation if tail-call optimization is present</li><li>process types:<ul><li>iterative:<ul><li>the environment needs to only keep track of the counter and check if the limit was reached</li><li>the program variables provide a complete description of the state of the process at any point</li><li>a fixed number of state variables,
a fixed rule that states how the variables should be updated as the process moves from state to state and
optional end test that specifies the conditions under which the process should end</li></ul></li><li>recursive:<ul><li>procedure vs process:<ul><li>a recursive procedure refers to itself</li><li>a recursive process expresses the way a process evolves</li></ul></li><li>the environment needs to keep track of the deffered operations</li></ul></li></ul></li><li>tail-recursivenes refers to an iterative process(in constant space) described as an recursive procedure</li></ul></article><nav class=site-nav><a href=https://www.dinudev.com//>Home</a>
<a href=https://www.dinudev.com//post/>All posts</a>
<a href=https://www.dinudev.com//journey/>The journey</a>
<a href=https://www.dinudev.com//paper/>Papers</a>
<a href=https://github.com/Owicca>GitHub</a></nav><footer class=site-footer><span class=owner>©2022 OWicca</span></footer></div><script src=https://www.dinudev.com/js/highlight.pack.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>