<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="OWicca"><meta name=generator content="Hugo 0.102.3"><title>Assembly — Down the wabbit's hole</title><meta name=description content><link rel=canonical href=https://www.dinudev.com/post/asm/><link href rel=alternate type=application/rss+xml title="Down the wabbit's hole"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=https://www.dinudev.com/css/highlight.css><link rel=stylesheet href=https://www.dinudev.com/css/paperback.css><link rel=stylesheet href=https://www.dinudev.com/css/main.css></head><body><div class=container><header><h1>Assembly</h1><nav class=site-nav><a href=/>Home</a>
<a href=/post/>All posts</a>
<a href=/journey/>The journey</a>
<a href=/paper/>Papers</a></nav></header><article><h3 id=assembly>Assembly:</h3><ul><li>Single Instruction Multiple Data(SIMD):<ul><li>paralelize instructions using multiple data points</li><li>instead of adding 2 DWORDs, paralelize adding 8 DWORDS by adding 4 with another 4 at the same time</li></ul></li></ul><h3 id=endianness>Endianness:</h3><ul><li>little endian: least significant byte first(x86/x86_64/AMD64)</li><li>big endian: most significant byte first</li><li>bi-endian: contain an instruction that allows for switchable endianness(ARM v3 and beyond)</li></ul><h3 id=categories-of-operations>Categories of operations:</h3><ul><li>load data</li><li>store data</li><li>modify data</li><li>call a function</li></ul><h3 id=memory-segmentation>Memory segmentation:</h3><ul><li>x64 uses flat memory: there is only one memory segment</li></ul><h3 id=stack>Stack:</h3><ul><li>the stack must be N bytes aligned:<ul><li>SP must be a N bytes multiplier</li><li>this simplifies read of data; data is read in less memory access cycles</li><li>if the stack is N bytes aligned, the processor will read from one address the entire value</li><li>if not the processor will have to read from two addresses and merge the result</li><li>intel and AMD require 16-bytes alignment to execute SSE instructions corectly</li></ul></li><li>growing downwards from the highest memory to the lowest</li><li>bp is the start of the stack, sp is the top of the stack</li><li>shadow store(spill space, home space, shadow space):<ul><li>space allocated on the stack by the caller for the callee(to save registers used to pass arguments)</li><li>the size is determined by the maximmum size supported(in x86_64 is 8 bytes) * number of registers used to pass parameters</li><li>shadow store is not part of the stack frame</li></ul></li><li>stack frame:<ul><li>a frame of data that is placed on the stack</li><li>structure:<ul><li>return instruction pointer first</li><li>allocate space for base pointer and local variables</li></ul></li></ul></li><li>actions:<ul><li><code>pop</code>: remove an item from the stack</li><li><code>push</code>: add an item on the stack</li></ul></li><li><code>call</code>:<ul><li>types:<ul><li>near call:<ul><li>near relative(<code>E8</code>): add the address called to the address of the next instruction(directly) => <code>call some_function</code></li><li>near absolute(<code>FF</code>): specify the call address in an mem store or reg(indirectly) => <code>call [rbx]</code></li></ul></li><li>far call</li><li>inter-privilege-level far call</li><li>task switch</li></ul></li><li>call tasks:<ul><li>push IP on the stack</li><li>jump to call address + next instruction address</li></ul></li></ul></li><li><code>ret</code>:<ul><li>transfers program controll to an address located on the top of the stack</li><li>pop and jump to that address</li><li>opcodes:<ul><li><code>C3</code></li><li><code>C2</code></li></ul></li></ul></li></ul><h3 id=calling-conventions>Calling conventions:</h3><ul><li>fastcall:<ul><li>the stack must be alligned to a 16 byte boundary</li><li>use 4 reg to pass parameters(left to right): <code>rcx</code>, <code>rdx</code>, <code>r8</code>, <code>r9</code></li><li>any argument that doesn&rsquo;t fit into a supported size(1, 2, 4, 8 bytes) will be passed by reference</li><li>before the call, the caller allocates space on the stack</li></ul></li><li>cdecl:<ul><li>allocate space for any functions called in it</li><li>first two arguments are stored in <code>rsi</code> and <code>rdi</code></li></ul></li><li>stdcall</li><li>c++ thiscall</li></ul><h3 id=arm-isas>ARM ISAs:</h3><ul><li>ARM mode: 4-byte instruction set</li><li>Thumb mode: 2-byte instruction set</li><li>Thumb-2(ARM-v7): 4-byte instruction set; extension of Thumb that should compete with ARM mode</li><li>x64 mode: 4-byte instruction set; not compatible to any other</li></ul><h3 id=numeral-systems>Numeral systems:</h3><ul><li>radix = numeral base</li></ul><h3 id=pe>PE:</h3><ul><li>sections always start at addresses ending in 3 hex zeros: 0x41000, 0x10001000,
because sections are padded to a boundary of 0x1000(4096) bytes</li></ul><h3 id=misc>Misc:</h3><ul><li>why does the stack grow downwards?:<ul><li>the reason is mainly historic, it is easy to split the memory in two parts:<ul><li>0 to highest for heap</li><li>highest to 0 for stack</li></ul></li></ul></li><li>shadow space, registers can be read if they are not properly cleaned up(read-after-free?!)</li><li><code>JNE</code> and <code>JNZ</code> have the same OP code</li><li><code>CMP</code> almost as <code>SUB</code>, it switches EFLAGS but does not modify the first operand</li></ul></article><nav class=site-nav><a href=https://www.dinudev.com//>Home</a>
<a href=https://www.dinudev.com//post/>All posts</a>
<a href=https://www.dinudev.com//journey/>The journey</a>
<a href=https://www.dinudev.com//paper/>Papers</a>
<a href=https://github.com/Owicca>GitHub</a></nav><footer class=site-footer><span class=owner>©2023 OWicca</span></footer></div><script src=https://www.dinudev.com/js/highlight.pack.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>