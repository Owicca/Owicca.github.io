<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Science on Down the wabbit&#39;s hole</title>
    <link>https://www.dinudev.com/categories/computer-science/</link>
    <description>Recent content in Computer Science on Down the wabbit&#39;s hole</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Jun 2020 22:18:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.dinudev.com/categories/computer-science/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SICP</title>
      <link>https://www.dinudev.com/post/sicp/</link>
      <pubDate>Mon, 22 Jun 2020 22:18:00 +0000</pubDate>
      
      <guid>https://www.dinudev.com/post/sicp/</guid>
      <description>Building Abstractions with Procedures:  complex software is built modularly so that the parts can be constructed, replaced and debugged separatedly three mechanisms to create complex expressions:  primitive expressions means of combinations: used to build compound elements from simpler ones means of abstraction: how compound elements can be named and manipulated as units   primitives:  data: stuff procedures: descriptions of the rules for manipulating data   tree accumulation:  evaluate the values of every child of the node(recursively) and THEN evaluate the value of the node   lexical scoping: variables in a procedure are bound by the enclosing block scope(they are looked up in the environment) block scoping: variables and definitions in a procedure are bound(private) to the scope of said procedure recursivity alone, enables every mathematical computation if tail-call optimization is present process types:  iterative:  the environment needs to only keep track of the counter and check if the limit was reached the program variables provide a complete description of the state of the process at any point a fixed number of state variables, a fixed rule that states how the variables should be updated as the process moves from state to state and optional end test that specifies the conditions under which the process should end   recursive:  procedure vs process:  a recursive procedure refers to itself a recursive process expresses the way a process evolves   the environment needs to keep track of the deffered operations     tail-recursivenes refers to an iterative process(in constant space) described as an recursive procedure  </description>
    </item>
    
    <item>
      <title>Computer Science</title>
      <link>https://www.dinudev.com/post/cs/</link>
      <pubDate>Sun, 01 Mar 2020 17:22:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/cs/</guid>
      <description>General:  everything that is tedious is error-prone try to design your types so that values are guaranteed to be valid:  hide the representation provide a constructor that creates only valid objects design all member functions to expect valid values and leave only valid values behind when they return   a rule for what constitues an valid values is an invariant types for objects in main memory is the same as formats for files on disk  Interface construction rules:  keep interfaces complete keep interfaces minimal provide constructors support copying(or prohibit it) use types to provide good argument checking identify nonmodifying member functions free all resources in the destructor  Attributes of a program:  should produce the desired results for all legal inputs should give reasonable error messages for all ilegal imputs need not worry about misbehaving hardware need not worry about misbehaving system software is allowed to terminate after finding an error  Approaches to acceptable software:  organize software to minimize errors eliminate most of the errors we made through debugging and testing make sure the remaining errors are not serious  Sources of errors:  Poor specification: if we are not specific of the software functionality we can&amp;rsquo;t asses the &amp;ldquo;dark corners&amp;rdquo; and make sure all cases are handled Incomplete programs: know when you handled all the cases Unexpected arguments Unexpected input Unexpected state Logical Errors: code that simply does not do what is supposed to do  Types of errors:  compile-time:  syntax errors type errors(values assigned to variables of the wrong tipe) non-errors(area(10, -7), a rectangle can&amp;rsquo;t have a negative width, but the pc can&amp;rsquo;t know that)   link-time:  every function in the program must be declared with exactly the same type in every translation unit in which is used every function must be defined exactly once in the program   run-time logic errors  Debugging:  how would i know if the program actually worked correctly?</description>
    </item>
    
  </channel>
</rss>