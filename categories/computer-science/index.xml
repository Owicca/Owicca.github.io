<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Science on Down the wabbit's hole</title><link>https://www.dinudev.com/categories/computer-science/</link><description>Recent content in Computer Science on Down the wabbit's hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 26 Jan 2023 12:00:00 +0000</lastBuildDate><atom:link href="https://www.dinudev.com/categories/computer-science/index.xml" rel="self" type="application/rss+xml"/><item><title>Containers</title><link>https://www.dinudev.com/post/containers/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/containers/</guid><description>docker: image-spec [] runtime-spec runc containerd moby oci image: info: a description of one or more root fs changes and commands to be run in a container runtime a layer does not have metadata, only content metadata such as env variables or default arguments belong to the image as a whole image json description structure: date created author arch os os.version os.features variant runtime configuration: user exposed ports env entrypoint default arguments(cmd) volumes working dir labels stop signal networking layers: an array of hashes that will make up the runtime fs changing any data in the json description, it will change the ImageId, creating a derived image an image&amp;rsquo;s ImageID is a sha256 of its json description structure: image manifest: metadata of contents and dependencies for a single image for an architecture for an operating system main purpose: content-addresable images: hash the content and use the hash as an id to directly address that version of image multi-architecture images: contain references to manifests for specific platforms(image index) can be translated to a runtime configuration image index(optional): high-level manifest that points to other manifests that usually help in building for different platforms a list of image manifests for different configurations/platforms image configuration: app arguments environment variables one or more fs serializations: data that will be pointed by an image manifest deserialized by the runtime layers(changesets): info: a set of changes is tarred when applying the changeset: if there are no whiteouts, the tar is simply extracted on top of the root fs, esentially adding/modifying files if there are whiteouts, the tar is applied, rather than simply extracted every layer is contained in a directory named for its digest(CAS) stored as: tar tar gzipped tar zstd(compressed with zstd) change types: addition modification removal: an empty file, signifying it should be deleted a whiteout a file that has a name of .</description></item><item><title>Design Patterns</title><link>https://www.dinudev.com/post/design_patterns/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/design_patterns/</guid><description>factory: a method to create objects that follow an interface, this way the user does not care what object is created and how, it simply calls the interface&amp;rsquo;s methods const ( Cash := 1 DebitCard := 2 ) type Payment interface { func Pay(sum int) (string, error) } type CashPM struct {} func (*c CashPM) Pay(sum int) string { return &amp;#34;&amp;#34;, nil } type DebitCardPM struct {} func (*c DebitCardPM) Pay(sum int) string { return &amp;#34;&amp;#34;, nil } func getPayment(t int) (Payment, error) { switch t { case Cash: return new(CashPM), nil case DebitCard: return new(DebitCardPM), nil default: return nil, errors.</description></item><item><title>Thread Modeling</title><link>https://www.dinudev.com/post/threat_modeling/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/threat_modeling/</guid><description>1. getting started: STRIDE DREAD The OPSEC Process
OPSEC is a five step, iterative process designed to assist in identifying information (or persons, property, etc) requiring protection, determining the methods that may be employed to compromise that information (or person, property, etc), and establishing effective countermeasures to protect it.
When formally applied, OPSEC is generally conducted in a sequential manner. However, emergency and dynamic situations may require certain steps be conducted out of sequence.</description></item><item><title>SICP</title><link>https://www.dinudev.com/post/sicp/</link><pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/sicp/</guid><description>Scheme syntax: reverse enginered from book code snipets and &amp;ldquo;trial and error&amp;rdquo; start_delimiter = &amp;#34;(&amp;#34;; end_delimiter = &amp;#34;)&amp;#34;; space = &amp;#34; &amp;#34;; definition_keyword = &amp;#34;define&amp;#34;; keyword = definition_keyword; digit = &amp;#34;1&amp;#34;|&amp;#34;2&amp;#34;|&amp;#34;3&amp;#34;|&amp;#34;4&amp;#34;|&amp;#34;5&amp;#34;|&amp;#34;6&amp;#34;|&amp;#34;7&amp;#34;|&amp;#34;8&amp;#34;|&amp;#34;9&amp;#34; [{, &amp;#34;0&amp;#34;|&amp;#34;1&amp;#34;|&amp;#34;2&amp;#34;|&amp;#34;3&amp;#34;|&amp;#34;4&amp;#34;|&amp;#34;5&amp;#34;|&amp;#34;6&amp;#34;|&amp;#34;7&amp;#34;|&amp;#34;8&amp;#34;|&amp;#34;9&amp;#34; }]; float = digit , &amp;#34;.&amp;#34; , digit [{, digit }]; number = digit [{, digit }]; alpha_character = {a...z}|{A...Z} character = alpha_character|&amp;#34;_&amp;#34;|digit|float; string = alpha_character [{, character }]; primitive_operator = &amp;#34;+&amp;#34;|&amp;#34;-&amp;#34;|&amp;#34;*&amp;#34;|&amp;#34;/&amp;#34;|&amp;#34;%&amp;#34;; operator = primitive_operator|expression_between_parentheses; expression_between_parentheses = start_delimiter , space , expression , space , end_delimiter; expression = start_delimiter , [operator] , space , digit|float|number|character|string|expression,function_call [{, space , digit|float|number|character|string|expression|function_call }] , space , end_delimiter;(* can a compound operator receive a single param?</description></item><item><title>Computer Science</title><link>https://www.dinudev.com/post/cs/</link><pubDate>Sun, 01 Mar 2020 17:22:00 +0200</pubDate><guid>https://www.dinudev.com/post/cs/</guid><description>General: everything that is tedious is error-prone try to design your types so that values are guaranteed to be valid: hide the representation provide a constructor that creates only valid objects design all member functions to expect valid values and leave only valid values behind when they return a rule for what constitues an valid values is an invariant types for objects in main memory is the same as formats for files on disk Interface construction rules: keep interfaces complete keep interfaces minimal provide constructors support copying(or prohibit it) use types to provide good argument checking identify nonmodifying member functions free all resources in the destructor Attributes of a program: should produce the desired results for all legal inputs should give reasonable error messages for all ilegal imputs need not worry about misbehaving hardware need not worry about misbehaving system software is allowed to terminate after finding an error Approaches to acceptable software: organize software to minimize errors eliminate most of the errors we made through debugging and testing make sure the remaining errors are not serious Sources of errors: Poor specification: if we are not specific of the software functionality we can&amp;rsquo;t asses the &amp;ldquo;dark corners&amp;rdquo; and make sure all cases are handled Incomplete programs: know when you handled all the cases Unexpected arguments Unexpected input Unexpected state Logical Errors: code that simply does not do what is supposed to do Types of errors: compile-time: syntax errors type errors(values assigned to variables of the wrong tipe) non-errors(area(10, -7), a rectangle can&amp;rsquo;t have a negative width, but the pc can&amp;rsquo;t know that) link-time: every function in the program must be declared with exactly the same type in every translation unit in which is used every function must be defined exactly once in the program run-time logic errors Debugging: how would i know if the program actually worked correctly?</description></item></channel></rss>