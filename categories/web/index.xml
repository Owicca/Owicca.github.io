<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on Down the wabbit's hole</title><link>https://www.dinudev.com/categories/web/</link><description>Recent content in Web on Down the wabbit's hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 26 Jan 2023 12:00:00 +0000</lastBuildDate><atom:link href="https://www.dinudev.com/categories/web/index.xml" rel="self" type="application/rss+xml"/><item><title>Bash to Python</title><link>https://www.dinudev.com/post/bash_to_python/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/bash_to_python/</guid><description>Topics: reading and writing files: cli reads files line-by-line and does some action to that line when processing stdin data, cli expects a stream of text divided by newline(file-like object) open: file path mode: r: read only w/w+: write only a/a+: append with open(&amp;#39;/file/path.txt&amp;#39;) as f: for line in f: print(line.strip()) cli interfaces: handling piping(stdin, stdout, stderr) stdin import sys for line in sys.stdin: print(line) stdout: print / sys.stdout.write('Out\n') stderr: sys.</description></item><item><title>HTTPd</title><link>https://www.dinudev.com/post/httpd/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/httpd/</guid><description>mpm modules: prefork: misc: a master mantains a pool of children a bunch of children are forked from parent at the start of the parent the parent aims to have a few idle children, always ready to handle new requests children(workers) are forked as needed up to a MaxRequestWorkers number the children handle the requests worker: misc: same as prefork but each children handles a bunch of threads: 1 listener thread: listen for new connections and pass the request to a server thread multiple server threads: process the connection number of processes started is specified by StartServers, MinSpareThreads, MaxSpareThreads number of active child processes is MaxRequestWorkers / ThreadsPerChild: MaxRequestWorkers: total workers per httpd server ThreadsPerChild: threads per process(workers) event: misc: based on worker listener threads handle server threads scheduling a long-lived connection is passed to the listener that will only pass it back to a server thread if an event that allows further processing is send by the os for the connection blocking connections are passed from the workers to the listener until they unblock, when the unblocking event happens, the listener picks an idle worker and gives the connection for further processing thread workload concurrency with listener as a scheduler and workers modules: misc: me modules are staticly compiled with apache binary other modules are specified in the config with LoadModule and loaded at runtime after a restart as shared libraries types: static: core http shared: everything else default modules: mod_mpm_event: mpm event mod_authn_core: provides management of basic auth and http digest(?</description></item><item><title>PHPUnit</title><link>https://www.dinudev.com/post/phpunit/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/phpunit/</guid><description>phpunit cli-xml equivalents: Test Selection Options: &amp;ndash;filter Filter which tests to run &amp;ndash;testsuite Filter which testsuite to run &amp;ndash;group Only runs tests from the specified group(s) &amp;ndash;exclude-group Exclude tests from the specified group(s) &amp;ndash;list-groups List available test groups &amp;ndash;list-suites List available test suites &amp;ndash;list-tests List available tests &amp;ndash;list-tests-xml List available tests in XML format &amp;ndash;test-suffix Only search for test in files with specified suffix(es). Default: Test.php,.phpt Test Execution Options: &amp;ndash;dont-report-useless-tests phpunit-beStrictAboutTestsThatDoNotTestAnything</description></item><item><title>Rest API</title><link>https://www.dinudev.com/post/rest_api/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/rest_api/</guid><description>rest api: write a bit of client code before design and implementation(readable code from a api, means the api is well written), it will force you to keep the client&amp;rsquo;s perspective and will give you a starting point makes easy things easy and hard things possible !!!!! take into account the use-cases and the public of you api never start implementation before design watch out for leakage of implementation details into the api, interfaces outlive implementations ask for constant feedback, try dogfooding name consistently name should be a bit specific, it is hard to reclaim api real-estate hard to misuse, sane defaults(false by default and enabled by the user) property-based instead of providing all the params in the constructor fundamentals of api design what is api design?</description></item><item><title>Webpack</title><link>https://www.dinudev.com/post/webpack/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/webpack/</guid><description>webpack: info: highly flexible(and complex) asset bundler concepts: entry: module entrypoints dependency tree roots output: output paths of bundles for every module in entry loader: webpack can only handle js and json files, loaders help webpack interact with other types of files as if they where js modules, esentially extending the dependency graph to include other types of files structure: test: what files to match use: what loader to use on matched files plugins: custom js code that extends the functionality of webpack to that of a task runner, potentially ANY computable task, because js is turing complete mode: enable optimizations based on environment values: development: DefinePlugin: define constants at compile time, that can be used in the scripts at runtime &amp;ldquo;process.</description></item><item><title>Web application security</title><link>https://www.dinudev.com/post/websec/</link><pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/websec/</guid><description>Security formalism failure reasons: to many different parties act on the same system, and the changes are too many and too quick for a static structure to be described IF everybody stops and decides on a common structure, that does not mean the structure can be translated in a set of computable constrains as of yet, there is not an way to prove, through static analysis, that an application will behave the way it was meant to behave, in complex, real-world scenarios; Turing also proved that there can be no algorithm that can show the outcome of another algorithm Risk management: in interconnected systems, even the most benign endpoint can be used to enter a network, and escalate from there, or pivot horizontally; a IoT door lock can be the entrypoint for a ransomeware it is hard to account for potential lawsuits, users loss of confidence in the brand its a high chance that self-reported data is incomplete, or breaches are unreported the attack surface is large and any one part can be attacked succesfuly, althou some parts are targeted more(statistically speaking), no one part is more important than the rest Things that work: learn from(preferably other people&amp;rsquo;s) mistakes develop tools to detect and fix problems presume everything is compromised Pragmatic methods: what is the exposed surface of the modern browsers?</description></item></channel></rss>