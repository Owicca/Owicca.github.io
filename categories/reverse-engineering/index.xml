<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reverse Engineering on Down the wabbit's hole</title><link>https://www.dinudev.com/categories/reverse-engineering/</link><description>Recent content in Reverse Engineering on Down the wabbit's hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 26 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.dinudev.com/categories/reverse-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Info</title><link>https://www.dinudev.com/journey/1_info/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/journey/1_info/</guid><description>Introduction: The best way to learn something fast is to start doing it. This is the beginning of my journey in reverse engineering.</description></item><item><title>Jetbrains license server</title><link>https://www.dinudev.com/journey/2_jb_license_server/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/journey/2_jb_license_server/</guid><description>logic: a tls priv-public key pair exists clients have the public key, the servers have the private key the client sends a request with his unique set of identifying information encoded response = rsa detached signature = hash the content then sign with private key the server checks the info and sends a response back: the response is the content + encoded response signing: encode data to be signed as string, then hash with md5, then sign the resulted detached signature is the encoded response methods: endpoints: /rpc/ping.</description></item><item><title>WrapLogin</title><link>https://www.dinudev.com/journey/3_wraplogin/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/journey/3_wraplogin/</guid><description>flow: setup a signal handler h for signum n: n = 14d = SIGALRM h = connection connection: execv(&amp;quot;/bin/.login&amp;quot;, *app_list_of_arguments[]) exit(0) schedule a n seconds signal alarm: n = 1d alarm(1) emulate &amp;ldquo;/bin/login&amp;rdquo; by asking a password from the user if password == &amp;ldquo;door&amp;rdquo;: alarm(0) execl(&amp;quot;/bin/sh&amp;quot;, &amp;quot;/bin/sh&amp;quot;, &amp;quot;-i&amp;quot;) exit(0) else: execv(&amp;quot;/bin/.login&amp;quot;, *app_list_of_arguments[]) exit(0) imports: execl execv strcmp signal scanf alarm exports: execute connection passwd strings: /bin/login door /bin/sh /bin/.</description></item><item><title>Reverse Engineering Taxonomy</title><link>https://www.dinudev.com/paper/re_taxonomy/</link><pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/paper/re_taxonomy/</guid><description>Notes: The main scope of this paper is to clarify the terminology used in RE for: forward engineering(fe) reverse engineering(re) redocumentation design recovery restructuring reengineering life-cycle stages: requirements: objectives constrains business rules design: specification of the solution implementation: coding testing delivery forward engineering: to move from higher levels of abstraction to concrete results from design to implementation reverse engineering: term comes from hardware analysis, where dechypering the structure of build products is commonplace in hardware, the point of re is to clone the system in software, the point of re is to gain enough understanding so you can: mantain extend patch discover the internal entities and then relationships between them document the findings branches: redocumentation design recovery restructuring(refactoring): keep the interface and rewrite the internals reengineering: engineer a new system to replace an old one based on old system&amp;rsquo;s requirements coupled with new ones includes re, if no documentation is provided includes fe to take into account new technologies, methods and requirements Objectives of re: cope with complexity generate alternate views recover lost information: changes in large systems tend to not be documented detect side effects: re can provide information that fe does not have access to synthesize higher abstractions facilitate reuse Economics: costs of comprehending(and of repairing misunderstandings) exists, although not perceived as a direct one Observations: do these naming conventions still hold true today?</description></item></channel></rss>