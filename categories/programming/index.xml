<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on Down the wabbit's hole</title><link>https://www.dinudev.com/categories/programming/</link><description>Recent content in Programming on Down the wabbit's hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 26 Jan 2023 12:00:00 +0000</lastBuildDate><atom:link href="https://www.dinudev.com/categories/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Bash to Python</title><link>https://www.dinudev.com/post/bash_to_python/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/bash_to_python/</guid><description>Topics: reading and writing files: cli reads files line-by-line and does some action to that line when processing stdin data, cli expects a stream of text divided by newline(file-like object) open: file path mode: r: read only w/w+: write only a/a+: append with open(&amp;#39;/file/path.txt&amp;#39;) as f: for line in f: print(line.strip()) cli interfaces: handling piping(stdin, stdout, stderr) stdin import sys for line in sys.stdin: print(line) stdout: print / sys.stdout.write('Out\n') stderr: sys.</description></item><item><title>Code Review</title><link>https://www.dinudev.com/post/code_review/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/code_review/</guid><description>high level code review checklist: Does the actual implementation reflect the architecture? Is the code easy to understand? Is the code too long? Is cohesion in place? Is the code modular? Are components cohesive? Is the code loosely coupled? Is the code reusable? Is the code readable? Is the code easy to maintain and test? Are premature optimizations in place? Is composition preferred? Is inheritance properly used? Is the flow easy to understand?</description></item><item><title>Design Patterns</title><link>https://www.dinudev.com/post/design_patterns/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/design_patterns/</guid><description>factory: a method to create objects that follow an interface, this way the user does not care what object is created and how, it simply calls the interface&amp;rsquo;s methods const ( Cash := 1 DebitCard := 2 ) type Payment interface { func Pay(sum int) (string, error) } type CashPM struct {} func (*c CashPM) Pay(sum int) string { return &amp;#34;&amp;#34;, nil } type DebitCardPM struct {} func (*c DebitCardPM) Pay(sum int) string { return &amp;#34;&amp;#34;, nil } func getPayment(t int) (Payment, error) { switch t { case Cash: return new(CashPM), nil case DebitCard: return new(DebitCardPM), nil default: return nil, errors.</description></item><item><title>PHPUnit</title><link>https://www.dinudev.com/post/phpunit/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/phpunit/</guid><description>phpunit cli-xml equivalents: Test Selection Options: &amp;ndash;filter Filter which tests to run &amp;ndash;testsuite Filter which testsuite to run &amp;ndash;group Only runs tests from the specified group(s) &amp;ndash;exclude-group Exclude tests from the specified group(s) &amp;ndash;list-groups List available test groups &amp;ndash;list-suites List available test suites &amp;ndash;list-tests List available tests &amp;ndash;list-tests-xml List available tests in XML format &amp;ndash;test-suffix Only search for test in files with specified suffix(es). Default: Test.php,.phpt Test Execution Options: &amp;ndash;dont-report-useless-tests phpunit-beStrictAboutTestsThatDoNotTestAnything</description></item><item><title>Python</title><link>https://www.dinudev.com/post/python/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/python/</guid><description>generators: yield: the equivalent of return for a generator flow: when you call a function with yield the value returned is a type of iterator, a generator every time you iterate through a generator(in a for-loop or calling .next()) the generator executes until it reaches an yield, returns the yield-ed value and pauses if a iterator arrives at the end, it is exhausted builtin constants: False True None NotImplemented builtin functions: primitives: ascii(): get input as ascii bin() bool() bytearray() bytes() chr() dict() float() hex() int() list() object(): base object for every entity in python oct() ord() set() slice() str() tuple() iterable related: enumerate(): return an enumerate object from iterable filter(): filter iterable by provided function map(): return iterator that applies provided function to every item of iterable sum() max() min() next(): get next() item from iterator range() misc: @classmethod(): a decorator for a class method @staticmethod(): a decorator for a static method @abstractmethod(): a decorator for an abstract method dir(): get names from input globals(): get all variables from the current module scope locals(): get all variables from the current scope hash(): get a unique hash, to be used when searching for a key in a dictionary help(): will search for input in official docs id(): unique id of the item input(): read input from cli abs() isinstance() issubclass() len() open(): open file pow() print() property() repr(): get a string representation of input, it strives to generate a representation to be used by eval reversed(): get a reverse iterator from interable round() sorted() super() type() vars(): get dict of input sets: .</description></item><item><title>Refactoring</title><link>https://www.dinudev.com/post/refactoring/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/refactoring/</guid><description>reasons to change software: adding a feature fixing a bug improving a design optimizing resource usage when making changes, it is all about behaviour: new behaviour(features) changing or removing old behaviour(bugs) variants in a system when making a change: structure
functionality
resource usage
when making a change is important to know how much other behaviour is at risk
risk-mitigation: what changes do we have to make? how will we know that we&amp;rsquo;ve done them correctly?</description></item><item><title>Regexp</title><link>https://www.dinudev.com/post/regexp/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/regexp/</guid><description>types: BRE(Basic Regular Expressions): ^, ., [], [^ ], $, * \?, \|, \+, \(\), \{m,n\} \?: \{0,1}\ \*: \{0,}\ \+: \{1,}\ ERE(Extended Regular Expressions): some meta characters do not need escaping: ?, |, +, (), {m,n} posix character classes: [:alnum:]: [A-Za-z0-9] [:alpha:]: [A-Za-z] [:blank:]: [ \t] [:digit:]: [0-9] [:lower:]: [a-z] [:print:]([:graph:] + space): [\x20-\x7E] [:punct:](punctuation characters): [][!&amp;quot;#$%&amp;amp;'()*+,./:;&amp;lt;=&amp;gt;?@\^_\``{\}~-] [:space:]: [ \t\r\n\v\f] [:upper:]: [A-Z] [:xdigit:](hexadecimal digits): [A-Fa-f0-9] [:graph:](visible characters/graphical): [\x21-\x7E]: code char 21 !</description></item><item><title>Rest API</title><link>https://www.dinudev.com/post/rest_api/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/rest_api/</guid><description>rest api: write a bit of client code before design and implementation(readable code from a api, means the api is well written), it will force you to keep the client&amp;rsquo;s perspective and will give you a starting point makes easy things easy and hard things possible !!!!! take into account the use-cases and the public of you api never start implementation before design watch out for leakage of implementation details into the api, interfaces outlive implementations ask for constant feedback, try dogfooding name consistently name should be a bit specific, it is hard to reclaim api real-estate hard to misuse, sane defaults(false by default and enabled by the user) property-based instead of providing all the params in the constructor fundamentals of api design what is api design?</description></item><item><title>Tests</title><link>https://www.dinudev.com/post/tests/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/tests/</guid><description>unit test(london): automated verifies a small piece of code(a unit) does it quickly does it in an isolated manner unit test(classical): automated verifies a small piece of behaviour(a unit) does it quickly does it in isolation(from other tests) integration test: does not follow one(any) or more ut criteria it involves two or more units schools of tought: classical: if you test an unit, you are implicitly testing its dependencies london: all colaborators(shared or mutable dependency) are mocked, this way only SUT is tested caracteristics of unit tests(these can be run after every code line change): they run fast they help us localize errors NOT unit tests(these can be run at larger intervals): talks to the db communicates across the network uses the fs you need to edit the environment(ex: config files) to run them philo: london allows you to build outside-in: start from high-level tests that set expectations for the whole system continue to write tests for every SUT in the graph of dependencies(mocks allows this) classical forces you to start inside-out: starting from the domain model you test and build out until the user facing SUTs cons: london: if you mock every collaborator, the tests end up more coupled unit test structure: 3a(aaa): arrange: setup SUT and collaborators in a desired state act: execute the behaviour and capture the output assert: assert the output and state is the expected one 3a is usually written starting with arrange, but it is easier to start with assert, because you do not yet know the behaviour, just the desired outcome recommendations: make shared fixtures only when all or almost all tests will use them(ex: DB connection): you might duplicate the same arrange for multiple tests, but this will make the tests self-sustaining and more readable if you do not want duplication, create private factory methods to be used in arrange name the test as if you were describing to a domain expert or business analyst each test is a fact about the behaviour of the SUT code smell: multiple or intertwined aaa sections in the same test means its not an unit test(tests more than one unit) an if in a test means it verifies too many things at once(not an unit test) if act is larger than 2-3 lines or larger than assert, there might be a problem with the SUT API if assert is too big it might signify a missing abstraction in the SUT API misc: ideal unit test: because of the CAP theorem ideal tests are unatainable if you focus on maxing any two facets, the last one will be useless, thus making the whole test useless it is impossible to achieve a perfect score in all four attributes because the three &amp;ldquo;protection against regressions&amp;rdquo;, &amp;ldquo;resistance to refactoring&amp;rdquo; and &amp;ldquo;fast feedback&amp;rdquo; are mutually exclusive, meaning only two of the three can have perfect scores &amp;ldquo;resistance to refactoring&amp;rdquo; is non-negociable because is binary, you either have resistance to refactoring or you don&amp;rsquo;t a &amp;ldquo;slider&amp;rdquo; moves the importance between &amp;ldquo;fast feedback&amp;rdquo; and &amp;ldquo;protection against regressions&amp;rdquo; based on context, because the two are more malleable than &amp;ldquo;resistance to refactoring&amp;rdquo;: e2e: more towards &amp;ldquo;regressions&amp;rdquo; integration: middle point unit: faster than any other attributes: integrated into the development lifecycle targets only the most important parts of the codebase provides maximum value with minimum maintenance costs test pyramid: many unit tests, highly abstract medium amount of integration tests, more human low amount of end-to-end tests, closest to emulating a user if you have very few business rules or any other complexity, e2e are redundant or useless if you do not have algorithmic complexity or business complexity, many unit tests are useless because they quickly delve in trivial checks black-box vs white-box testing: black-box(what): used based on a specification use when writing tests white-box(how): derived from source code, not a specification more thorough, but more brittle(tight coupling) tend to produce more false positives use when analysing tests a test against a behaviour that is not meaningful to a business person lacks value and is fragile decoupling means testing the observable behaviour(the end results), not the steps to do that maximising test accuracy: by decreasing the false positives(the test is flexible to refactoring) and decreasing the false negatives(the test is good against regression), the accuracy of the test increases set a high value threshold for tests and only allow tests above that value in the codebase, test code is also code and less good code is better than more mediocre code: value = [0.</description></item><item><title>Webpack</title><link>https://www.dinudev.com/post/webpack/</link><pubDate>Thu, 26 Jan 2023 12:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/webpack/</guid><description>webpack: info: highly flexible(and complex) asset bundler concepts: entry: module entrypoints dependency tree roots output: output paths of bundles for every module in entry loader: webpack can only handle js and json files, loaders help webpack interact with other types of files as if they where js modules, esentially extending the dependency graph to include other types of files structure: test: what files to match use: what loader to use on matched files plugins: custom js code that extends the functionality of webpack to that of a task runner, potentially ANY computable task, because js is turing complete mode: enable optimizations based on environment values: development: DefinePlugin: define constants at compile time, that can be used in the scripts at runtime &amp;ldquo;process.</description></item><item><title>Modern code review</title><link>https://www.dinudev.com/paper/modern_code_review/</link><pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/paper/modern_code_review/</guid><description>steps: the author adds changes and submits for code review the reviewer starts threads on specific code lines where reviewers and authors disscuss the author follows up with changes that fix or enhance motivations behind code review: forcing the codebase to transition from research to production forcing knowledge sharing: this way, at least two developers have know-how about a particular functionality unintented consequences: checking the consistency of style and design more tests where written no single developer can commit arbitrary code without oversight(security implications) types of codebases: research: optimized towards quick prototyping production: concerned with the readability of code by future developers goals: high frequency and iterative development small review size is preferred misc: do not use questions in review comments REFERENCE Reference: Caitlin Sadowski, Emma Söderberg, Luke Church, Michal Sipko and Alberto Bacchelli.</description></item><item><title>Clean Code</title><link>https://www.dinudev.com/post/clean_code/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/clean_code/</guid><description>Info: Code is clean if it can be understood easily – by everyone on the team. Clean code can be read and enhanced by a developer other than its original author. With understandability comes readability, changeability, extensibility and maintainability.
General rules Follow standard conventions. Keep it simple stupid. Simpler is always better. Reduce complexity as much as possible. Boy scout rule. Leave the campground cleaner than you found it. Always find root cause.</description></item><item><title>.NET</title><link>https://www.dinudev.com/post/net/</link><pubDate>Fri, 17 Apr 2020 13:00:00 +0200</pubDate><guid>https://www.dinudev.com/post/net/</guid><description>.NET: structure: runtime component languages compilers platforms: .NET Core .NET Framework Xamarin it provides definitions for a set of Base Class Libraries(BCL) APIs to be implemented by all the platforms conforming to the standard .NET Core: components: CoreCLR(Common Language Runtime): open source refactoring of the original CLR manage usage and references to objects communication and interactions of objects written in the different languages supported garbage collection components: garbage collector Just In Time(JIT) compiler Native interop: allow managed(.</description></item><item><title>Assembly</title><link>https://www.dinudev.com/post/asm/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/asm/</guid><description>Assembly: Single Instruction Multiple Data(SIMD): paralelize instructions using multiple data points instead of adding 2 DWORDs, paralelize adding 8 DWORDS by adding 4 with another 4 at the same time Endianness: little endian: least significant byte first(x86/x86_64/AMD64) big endian: most significant byte first bi-endian: contain an instruction that allows for switchable endianness(ARM v3 and beyond) Categories of operations: load data store data modify data call a function Memory segmentation: x64 uses flat memory: there is only one memory segment Stack: the stack must be N bytes aligned: SP must be a N bytes multiplier this simplifies read of data; data is read in less memory access cycles if the stack is N bytes aligned, the processor will read from one address the entire value if not the processor will have to read from two addresses and merge the result intel and AMD require 16-bytes alignment to execute SSE instructions corectly growing downwards from the highest memory to the lowest bp is the start of the stack, sp is the top of the stack shadow store(spill space, home space, shadow space): space allocated on the stack by the caller for the callee(to save registers used to pass arguments) the size is determined by the maximmum size supported(in x86_64 is 8 bytes) * number of registers used to pass parameters shadow store is not part of the stack frame stack frame: a frame of data that is placed on the stack structure: return instruction pointer first allocate space for base pointer and local variables actions: pop: remove an item from the stack push: add an item on the stack call: types: near call: near relative(E8): add the address called to the address of the next instruction(directly) =&amp;gt; call some_function near absolute(FF): specify the call address in an mem store or reg(indirectly) =&amp;gt; call [rbx] far call inter-privilege-level far call task switch call tasks: push IP on the stack jump to call address + next instruction address ret: transfers program controll to an address located on the top of the stack pop and jump to that address opcodes: C3 C2 Calling conventions: fastcall: the stack must be alligned to a 16 byte boundary use 4 reg to pass parameters(left to right): rcx, rdx, r8, r9 any argument that doesn&amp;rsquo;t fit into a supported size(1, 2, 4, 8 bytes) will be passed by reference before the call, the caller allocates space on the stack cdecl: allocate space for any functions called in it first two arguments are stored in rsi and rdi stdcall c++ thiscall ARM ISAs: ARM mode: 4-byte instruction set Thumb mode: 2-byte instruction set Thumb-2(ARM-v7): 4-byte instruction set; extension of Thumb that should compete with ARM mode x64 mode: 4-byte instruction set; not compatible to any other Numeral systems: radix = numeral base PE: sections always start at addresses ending in 3 hex zeros: 0x41000, 0x10001000, because sections are padded to a boundary of 0x1000(4096) bytes Misc: why does the stack grow downwards?</description></item><item><title>Test Driven Development</title><link>https://www.dinudev.com/post/tdd/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.dinudev.com/post/tdd/</guid><description>Test Driven Development(TDD): types: unit tests: test functionality in isolation used to test functionality at the lowest level of computation(method, function) integration tests: test the interaction and data exchange of multiple units types: top-down: top-level components are integrated and tested first bottom-up: lower-level components are integrated and tested first big bang: everything is integrated and tested at once system tests: validate the entire integrated system performed imediatelly after integration tests testing is made from the users perspective made with real data principles: write the tests: the test are a form of documentation write the code: write just enough to pass the test run the tests: if they fail, rewrite the tests or the code refactor: the tests or code until full coverage is achieved remove duplicates attempt to fix any signs of code smell make changes gradually, one test at a time red-green-refactor: red: add a failing test green: make it work refactor</description></item><item><title>C#</title><link>https://www.dinudev.com/post/csharp/</link><pubDate>Fri, 03 Apr 2020 18:59:00 +0200</pubDate><guid>https://www.dinudev.com/post/csharp/</guid><description>General: expression-bodied members: public string Func(param) =&amp;gt; &amp;quot;result&amp;quot; + param string interpolation: var str = &amp;quot;string&amp;quot;; $&amp;quot;This is a {string}&amp;quot; using static: public class Cls { public static string staticString = &amp;#34;str&amp;#34;; } using static Cls; Console.WriteLine(staticString) deconstruction: public static (string, int) Func(string) { var rnd = new Random(); return (string, rnd.Next()); } var (someString, someInt) = Func(&amp;#34;test&amp;#34;); // with types (string someString, int someInts) = Func(&amp;#34;test&amp;#34;); // with discards (\_, someInt) = Func(&amp;#34;test&amp;#34;); blazor are razor pages running in the browser, a mono runtime compiled to web assembly Func&amp;lt;string, int, decimal&amp;gt;: a delegate type with string, int parameters and decimal return type delegate that does not return a value: Action Action&amp;lt;T&amp;gt;(T is the param to the delegate) Generics: type safety at compile time without knowing the type beforehand Representing nullable values: Iterators: lazy computation at run-time C# 3: object and collection initializer: new Agent() {Name = &amp;quot;James&amp;quot;, Surname = &amp;quot;Bond&amp;quot;} new Agency() { Agents = { new Agent() {Name = &amp;quot;James&amp;quot;, Surname = &amp;quot;Bond&amp;quot;}, new Agent() {Name = &amp;quot;Bond&amp;quot;, Surname = &amp;quot;James&amp;quot;} } } Expresion trees: code available for inspection at execution-time data structure that represents executable code it is much easier to translate a data structure to SQL instead of IL to SQL only expression-bodied lambda expressions can be converted to expression trees, this is less of a problem with the addition of object and collection initializers (which are initialized as single expressions) Expression&amp;lt;Func&amp;lt;int, int, int&amp;gt;&amp;gt; adder = (x, y) =&amp;gt; x + y; Console.</description></item><item><title>Javascript</title><link>https://www.dinudev.com/post/javascript/</link><pubDate>Mon, 02 Mar 2020 13:14:00 +0200</pubDate><guid>https://www.dinudev.com/post/javascript/</guid><description>Node: core packages: console(print to stdout/stderr): time(&amp;quot;label&amp;quot;) / timeLog(&amp;quot;label&amp;quot;) / timeEnd(&amp;quot;label&amp;quot;): time spent error(&amp;quot;string&amp;quot;) / warn(&amp;quot;string&amp;quot;): print to stderr trace(&amp;quot;string&amp;quot;): print string and debug trace to current position in the code readline(read from stdin line by line): events: &amp;ldquo;close&amp;rdquo; &amp;ldquo;line&amp;rdquo;: triggers on &amp;ldquo;\n&amp;rdquo;, &amp;ldquo;\r&amp;rdquo;, &amp;ldquo;\r\n&amp;rdquo; createInstance({input: &amp;lt;input.stream&amp;gt;, output: &amp;lt;output.stream&amp;gt;}) if you have 30 projects that all require package randomPackage, you get 30 copies of randomPackage, one for each node_modules of each project(WTF?</description></item><item><title>CRS File Format</title><link>https://www.dinudev.com/post/crs_file_format/</link><pubDate>Sun, 01 Mar 2020 18:32:00 +0200</pubDate><guid>https://www.dinudev.com/post/crs_file_format/</guid><description>Goals: learn about file formats obfuscate files File format: encrypt the raw data from the file and write to an image(RAW) compute header items dynamic addresses based on RAW size: header items addresses should not be linked in any way (if you know one address you should not be able to deduce/compute the others)</description></item><item><title>Data Structures and Algorithms</title><link>https://www.dinudev.com/post/dsa/</link><pubDate>Wed, 08 Jan 2020 11:35:00 +0200</pubDate><guid>https://www.dinudev.com/post/dsa/</guid><description>Foundation: what is an algorithm? why use an algorithm? categories Algorithms: searching:
Binary search: input: sorted list of elements guess the middle number and eliminate half the remaining numbers every time big o(list of n): best avg worst: O(log n) return position of element in list or null sorting:
selection sort: big o: worst: O(n^2) avg: O(n^2) best: O(n^2) merge sort: big o: worst: O(n log n) avg: O(n log n) best: O(n log n) Quicksort: base case recursive case big o: worst: O(n^2) avg: O(n log n) best: O(n log n) Data structures: primitives: int float char compound: Array: runtimes: reading: O(1) insertion: O(n) deletion: O(n) random access contigous spaces in memory to extend you have to find a bigger free space and copy the data there random access is easy, because they are contigous, to access item at index n, BASE + n(based on the fact that n is lower that BASE[MAX]) all elements must be of the same data type Linked list: runtimes: reading: O(n) insertion: O(1) deletion: O(1) deletion is O(1) only if you can access instantly the element sequential access each item holds a pointer to the next item in the list solves arrays problem of contigous memory allocation by randomly asigning one unit of space for every item in the list good if you want to access all the elements of the list at once if you want to access the last, you need to start from the first and go through every one, until you find the searched one hash map: model relations from one item to another an array that uses an hash function to store the values a hash function: for every string value a different number is created for the same string the same number is created, no matter the ammount of calls knows the array size and returns valid indexes (n=array lengt, hash &amp;gt;= 0, hash &amp;lt; n - 1) runtime: worst: insert: O(n) delete: O(n) read: O(n) avg: insert: O(1) delete: O(1) read: O(1) collision solutions: start a linked list at the index with multiple values implement: take into account the load factor: items in htable/total slots in htable at &amp;gt;1 load factor the access time is O(n), multiple values with the same hash resize storage when lf is greater than 0.</description></item></channel></rss>