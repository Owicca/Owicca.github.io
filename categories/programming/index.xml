<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Down the wabbit&#39;s hole</title>
    <link>https://www.dinudev.com/categories/programming/</link>
    <description>Recent content in Programming on Down the wabbit&#39;s hole</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Apr 2020 22:18:00 +0200</lastBuildDate>
    
	<atom:link href="https://www.dinudev.com/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Assembly</title>
      <link>https://www.dinudev.com/post/asm/</link>
      <pubDate>Fri, 17 Apr 2020 22:18:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/asm/</guid>
      <description>Assembly:  Single Instruction Multiple Data(SIMD):  paralelize instructions using multiple data points instead of adding 2 DWORDs, paralelize adding 8 DWORDS by adding 4 with another 4 at the same time    Endianness:  little endian: least significant byte first(x86/x86_64/AMD64) big endian: most significant byte first bi-endian: contain an instruction that allows for switchable endianness(ARM v3 and beyond)  Categories of operations:  load data store data modify data call a function  Memory segmentation:  x64 uses flat memory: there is only one memory segment  Stack:  the stack must be N bytes aligned:  SP must be a N bytes multiplier this simplifies read of data; data is read in less memory access cycles if the stack is N bytes aligned, the processor will read from one address the entire value if not the processor will have to read from two addresses and merge the result intel and AMD require 16-bytes alignment to execute SSE instructions corectly   growing downwards from the highest memory to the lowest bp is the start of the stack, sp is the top of the stack shadow store(spill space, home space, shadow space):  space allocated on the stack by the caller for the callee(to save registers used to pass arguments) the size is determined by the maximmum size supported(in x86_64 is 8 bytes) * number of registers used to pass parameters shadow store is not part of the stack frame   stack frame:  a frame of data that is placed on the stack structure:  return instruction pointer first allocate space for base pointer and local variables     actions:  pop: remove an item from the stack push: add an item on the stack   call:  types:  near call:  near relative(E8): add the address called to the address of the next instruction(directly) =&amp;gt; call some_function near absolute(FF): specify the call address in an mem store or reg(indirectly) =&amp;gt; call [rbx]   far call inter-privilege-level far call task switch   call tasks:  push IP on the stack jump to call address + next instruction address     ret:  transfers program controll to an address located on the top of the stack pop and jump to that address opcodes:  C3 C2      Calling conventions:  fastcall:  the stack must be alligned to a 16 byte boundary use 4 reg to pass parameters(left to right): rcx, rdx, r8, r9 any argument that doesn&amp;rsquo;t fit into a supported size(1, 2, 4, 8 bytes) will be passed by reference before the call, the caller allocates space on the stack   cdecl:  allocate space for any functions called in it first two arguments are stored in rsi and rdi   stdcall c++ thiscall  </description>
    </item>
    
    <item>
      <title>.NET</title>
      <link>https://www.dinudev.com/post/net/</link>
      <pubDate>Fri, 17 Apr 2020 13:00:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/net/</guid>
      <description>.NET:  structure:  runtime component languages compilers   platforms:  .NET Core .NET Framework Xamarin   it provides definitions for a set of Base Class Libraries(BCL) APIs to be implemented by all the platforms conforming to the standard  .NET Core:  components:  CoreCLR(Common Language Runtime):  open source refactoring of the original CLR manage usage and references to objects communication and interactions of objects written in the different languages supported garbage collection components:  garbage collector Just In Time(JIT) compiler Native interop:  allow managed(.</description>
    </item>
    
    <item>
      <title>Test Driven Development</title>
      <link>https://www.dinudev.com/post/tdd/</link>
      <pubDate>Fri, 17 Apr 2020 12:00:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/tdd/</guid>
      <description>Test Driven Development(TDD):  types:  unit tests:  test functionality in isolation used to test functionality at the lowest level of computation(method, function)   integration tests:  test the interaction and data exchange of multiple units types:  top-down: top-level components are integrated and tested first bottom-up: lower-level components are integrated and tested first big bang: everything is integrated and tested at once     system tests:  validate the entire integrated system performed imediatelly after integration tests testing is made from the users perspective made with real data     principles:   write the tests:  the test are a form of documentation    write the code:  write just enough to pass the test    run the tests:  if they fail, rewrite the tests or the code    refactor:  the tests or code until full coverage is achieved remove duplicates attempt to fix any signs of code smell make changes gradually, one test at a time      red-green-refactor:  red: add a failing test green: make it work refactor    </description>
    </item>
    
    <item>
      <title>C#</title>
      <link>https://www.dinudev.com/post/csharp/</link>
      <pubDate>Fri, 03 Apr 2020 18:59:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/csharp/</guid>
      <description>General:  expression-bodied members: public string Func(param) =&amp;gt; &amp;quot;result&amp;quot; + param string interpolation: var str = &amp;quot;string&amp;quot;; $&amp;quot;This is a {string}&amp;quot; using static: public class Cls{public static string staticString = &amp;#34;str&amp;#34;;}using static Cls;Console.WriteLine(staticString)  deconstruction: public static (string, int) Func(string){var rnd = new Random();return (string, rnd.Next());}var (someString, someInt) = Func(&amp;#34;test&amp;#34;);// with types(string someString, int someInts) = Func(&amp;#34;test&amp;#34;);// with discards(\_, someInt) = Func(&amp;#34;test&amp;#34;);  blazor are razor pages running in the browser, a mono runtime compiled to web assembly Func&amp;lt;string, int, decimal&amp;gt;: a delegate type with string, int parameters and decimal return type delegate that does not return a value:  Action Action&amp;lt;T&amp;gt;(T is the param to the delegate)    Generics:  type safety at compile time without knowing the type beforehand  Representing nullable values: *</description>
    </item>
    
    <item>
      <title>Javascript</title>
      <link>https://www.dinudev.com/post/javascript/</link>
      <pubDate>Mon, 02 Mar 2020 13:14:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/javascript/</guid>
      <description>react:  lifecycle phases + hooks:  mount:  creation: ReactDOM.render() getDefaultProps() / MyComponent.defaultProps getInitialState() / this.state = ... render() children initialization componentDidMount()   update:  shouldComponentUpdate() render() children lifecycle methods componentDidUpdate()   unmount:  componentWillUnmount() children lifecycle methods instance destroyed for gc      prototype:  when objects are created they do not come with the myrad of metadata as inheriting classes in classical oop do, they are buckets of data, key-value pairs how this is resolved:  directly: this will refer to the global object, window(browser)/global(nodejs) as a method: this will refer to the object that the func is a part of explicitly applied:  call: object to be this as first param, and the rest of the params as positional apply: object to be this as first param, and the rest of the params as an array in the second param bind: object to be this as first param   as a constructor    object-literal pattern:  organize code by the behaviour it comprises keeps your code from polluting the global namespace  To read:  https://github.</description>
    </item>
    
    <item>
      <title>CRS File Format</title>
      <link>https://www.dinudev.com/post/crs_file_format/</link>
      <pubDate>Sun, 01 Mar 2020 18:32:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/crs_file_format/</guid>
      <description>Goals:  learn about file formats obfuscate files  File format:  encrypt the raw data from the file and write to an image(RAW) compute header items dynamic addresses based on RAW size:  header items addresses should not be linked in any way (if you know one address you should not be able to deduce/compute the others)    </description>
    </item>
    
    <item>
      <title>Design Patterns</title>
      <link>https://www.dinudev.com/post/design_patterns/</link>
      <pubDate>Fri, 28 Feb 2020 11:35:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/design_patterns/</guid>
      <description>Creational: Factory:  a class that creates other classes when to use:  the object setup requires a high level of complexity generation of different objects is needed based on environment when working with many small objects that share the same properties    Abstract Factory:  to be used when a system needs to be decouple from the way objects are generated the system needs to work with multiple objects  Mixin:  a bucket of reusable functionality(think of traits in php) collect functionality through extension it is argued it creates object pollution it is argued it adds an level of uncertainty regarding the origin of the functions(in large systems)  Properties:  create objects based on a template of an existing object through cloning in js Object.</description>
    </item>
    
    <item>
      <title>Data Structures and Algorithms</title>
      <link>https://www.dinudev.com/post/dsa/</link>
      <pubDate>Wed, 08 Jan 2020 11:35:00 +0200</pubDate>
      
      <guid>https://www.dinudev.com/post/dsa/</guid>
      <description>Foundation:  what is an algorithm? why use an algorithm? categories  Algorithms:   searching:
 Binary search:  input: sorted list of elements guess the middle number and eliminate half the remaining numbers every time big o(list of n):  best avg worst: O(log n)   return position of element in list or null      sorting:
 selection sort:  big o:  worst: O(n^2) avg: O(n^2) best: O(n^2)     merge sort:  big o:  worst: O(n log n) avg: O(n log n) best: O(n log n)     Quicksort:  base case recursive case big o:  worst: O(n^2) avg: O(n log n) best: O(n log n)        Data structures:  primitives:  int float char   compound:  Array:  runtimes:  reading: O(1) insertion: O(n) deletion: O(n)   random access contigous spaces in memory to extend you have to find a bigger free space and copy the data there random access is easy, because they are contigous, to access item at index n, BASE + n(based on the fact that n is lower that BASE[MAX]) all elements must be of the same data type   Linked list:  runtimes:  reading: O(n) insertion: O(1) deletion: O(1)   deletion is O(1) only if you can access instantly the element sequential access each item holds a pointer to the next item in the list solves arrays problem of contigous memory allocation by randomly asigning one unit of space for every item in the list good if you want to access all the elements of the list at once if you want to access the last, you need to start from the first and go through every one, until you find the searched one   hash map:  model relations from one item to another an array that uses an hash function to store the values a hash function:  for every string value a different number is created for the same string the same number is created, no matter the ammount of calls knows the array size and returns valid indexes (n=array lengt, hash &amp;gt;= 0, hash &amp;lt; n - 1)   runtime:  worst:  insert: O(n) delete: O(n) read: O(n)   avg:  insert: O(1) delete: O(1) read: O(1)     collision solutions:  start a linked list at the index with multiple values   implement:  take into account the load factor:  items in htable/total slots in htable at &amp;gt;1 load factor the access time is O(n), multiple values with the same hash resize storage when lf is greater than 0.</description>
    </item>
    
  </channel>
</rss>