<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on Down the wabbit's hole</title><link>https://www.dinudev.com/categories/programming/</link><description>Recent content in Programming on Down the wabbit's hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 02 Mar 2020 13:14:00 +0200</lastBuildDate><atom:link href="https://www.dinudev.com/categories/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Javascript</title><link>https://www.dinudev.com/post/javascript/</link><pubDate>Mon, 02 Mar 2020 13:14:00 +0200</pubDate><guid>https://www.dinudev.com/post/javascript/</guid><description>react: lifecycle phases + hooks: mount: creation: ReactDOM.render() getDefaultProps() / MyComponent.defaultProps getInitialState() / this.state = ... render() children initialization componentDidMount() update: shouldComponentUpdate() render() children lifecycle methods componentDidUpdate() unmount: componentWillUnmount() children lifecycle methods instance destroyed for gc prototype: when objects are created they do not come with the myrad of metadata as inheriting classes in classical oop do, they are buckets of data, key-value pairs how this is resolved: directly: this will refer to the global object, window(browser)/global(nodejs) as a method: this will refer to the object that the func is a part of explicitly applied: call: object to be this as first param, and the rest of the params as positional apply: object to be this as first param, and the rest of the params as an array in the second param bind: object to be this as first param as a constructor object-literal pattern: organize code by the behaviour it comprises keeps your code from polluting the global namespace To read: https://github.</description></item><item><title>CRS File Format</title><link>https://www.dinudev.com/post/crs_file_format/</link><pubDate>Sun, 01 Mar 2020 18:32:00 +0200</pubDate><guid>https://www.dinudev.com/post/crs_file_format/</guid><description>Goals: learn about file formats obfuscate files File format: encrypt the raw data from the file and write to an image(RAW) compute header items dynamic addresses based on RAW size: header items addresses should not be linked in any way (if you know one address you should not be able to deduce/compute the others)</description></item><item><title>CPP</title><link>https://www.dinudev.com/post/cpp/</link><pubDate>Sun, 01 Mar 2020 17:27:00 +0200</pubDate><guid>https://www.dinudev.com/post/cpp/</guid><description>General: the public data/function members are your interface put the interface first methods with implementation declared in the class are generated inline at every use, giving a speed boost(no jump to common code), inlined methods do not benefit from the boost if they are larger than 4-5 lines I/O: a stream can be in four states: good(): read/write was successful eof(): internal file pointer is at the end of the line fail(): format error level of error(you should clear() to go back to a good()) bad(): disk error level of error</description></item><item><title>Design Patterns</title><link>https://www.dinudev.com/post/design_patterns/</link><pubDate>Fri, 28 Feb 2020 11:35:00 +0200</pubDate><guid>https://www.dinudev.com/post/design_patterns/</guid><description>Creational: Factory: a class that creates other classes when to use: the object setup requires a high level of complexity generation of different objects is needed based on environment when working with many small objects that share the same properties Abstract Factory: to be used when a system needs to be decouple from the way objects are generated the system needs to work with multiple objects Mixin: a bucket of reusable functionality(think of traits in php) collect functionality through extension it is argued it creates object pollution it is argued it adds an level of uncertainty regarding the origin of the functions(in large systems) Properties: create objects based on a template of an existing object through cloning in js Object.</description></item><item><title>Data Structures and Algorithms</title><link>https://www.dinudev.com/post/dsa/</link><pubDate>Wed, 08 Jan 2020 11:35:00 +0200</pubDate><guid>https://www.dinudev.com/post/dsa/</guid><description>Foundation: what is an algorithm? why use an algorithm? categories Algorithms: searching:
Binary search: input: sorted list of elements guess the middle number and eliminate half the remaining numbers every time big o(list of n): best avg worst: O(log n) return position of element in list or null sorting:
selection sort: big o: worst: O(n^2) avg: O(n^2) best: O(n^2) merge sort: big o: worst: O(n log n) avg: O(n log n) best: O(n log n) Quicksort: base case recursive case big o: worst: O(n^2) avg: O(n log n) best: O(n log n) Data structures: primitives: int float char compound: Array: runtimes: reading: O(1) insertion: O(n) deletion: O(n) random access contigous spaces in memory to extend you have to find a bigger free space and copy the data there random access is easy, because they are contigous, to access item at index n, BASE + n(based on the fact that n is lower that BASE[MAX]) all elements must be of the same data type Linked list: runtimes: reading: O(n) insertion: O(1) deletion: O(1) deletion is O(1) only if you can access instantly the element sequential access each item holds a pointer to the next item in the list solves arrays problem of contigous memory allocation by randomly asigning one unit of space for every item in the list good if you want to access all the elements of the list at once if you want to access the last, you need to start from the first and go through every one, until you find the searched one hash map: model relations from one item to another an array that uses an hash function to store the values a hash function: for every string value a different number is created for the same string the same number is created, no matter the ammount of calls knows the array size and returns valid indexes (n=array lengt, hash &amp;gt;= 0, hash &amp;lt; n - 1) runtime: worst: insert: O(n) delete: O(n) read: O(n) avg: insert: O(1) delete: O(1) read: O(1) collision solutions: start a linked list at the index with multiple values implement: take into account the load factor: items in htable/total slots in htable at &amp;gt;1 load factor the access time is O(n), multiple values with the same hash resize storage when lf is greater than 0.</description></item></channel></rss>